{
  "description": "var Component=(()=>{var s=Object.create;var o=Object.defineProperty;var u=Object.getOwnPropertyDescriptor;var m=Object.getOwnPropertyNames;var p=Object.getPrototypeOf,f=Object.prototype.hasOwnProperty;var y=(r,e)=>()=>(e||r((e={exports:{}}).exports,e),e.exports),g=(r,e)=>{for(var t in e)o(r,t,{get:e[t],enumerable:!0})},a=(r,e,t,i)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let c of m(e))!f.call(r,c)&&c!==t&&o(r,c,{get:()=>e[c],enumerable:!(i=u(e,c))||i.enumerable});return r};var b=(r,e,t)=>(t=r!=null?s(p(r)):{},a(e||!r||!r.__esModule?o(t,\"default\",{value:r,enumerable:!0}):t,r)),j=r=>a(o({},\"__esModule\",{value:!0}),r);var h=y((w,l)=>{l.exports=_jsx_runtime});var B={};g(B,{default:()=>v,frontmatter:()=>x});var n=b(h()),x={title:\"Count By\",excerpt:\"Implement a function that counts the number of times a value appears in an array based on a function or property name\"};function d(r){let e=Object.assign({p:\"p\",code:\"code\",ul:\"ul\",li:\"li\",em:\"em\",pre:\"pre\",h2:\"h2\",ol:\"ol\",a:\"a\"},r.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(e.p,{children:[\"Implement a function \",(0,n.jsx)(e.code,{children:\"countBy(array, iteratee)\"}),\" that creates an object composed of keys generated from the results of running each element of \",(0,n.jsx)(e.code,{children:\"array\"}),\" thru \",(0,n.jsx)(e.code,{children:\"iteratee\"}),\". The corresponding value of each key is the number of times the key was returned by \",(0,n.jsx)(e.code,{children:\"iteratee\"}),\". \",(0,n.jsx)(e.code,{children:\"iteratee\"}),\"s can either be:\"]}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Functions: \",(0,n.jsx)(e.code,{children:\"iteratee\"}),\" functions is invoked with one argument: \",(0,n.jsx)(e.em,{children:\"(value)\"}),\".\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Strings: The property of an object. E.g. \",(0,n.jsx)(e.code,{children:\"'length'\"}),\" can be used to return the number of elements of arrays.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`countBy(array, iteratee);\n`})}),`\n`,(0,n.jsx)(e.h2,{children:\"Arguments\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"array\"}),\" \",(0,n.jsx)(e.em,{children:\"(Array)\"}),\": The array to iterate over.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"iteratee\"}),\" \",(0,n.jsx)(e.em,{children:\"(Function)\"}),\": The iteratee function to transform elements. The function is invoked with one argument: \",(0,n.jsx)(e.em,{children:\"(value)\"}),\".\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"Returns\"}),`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.em,{children:\"(Object)\"}),\": Returns the composed aggregate object.\"]}),`\n`,(0,n.jsx)(e.h2,{children:\"Examples\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`countBy([6.1, 4.2, 6.3], Math.floor);\n// => { '4': 1, '6': 2 }\n\ncountBy(['one', 'two', 'three'], 'length');\n// => { '3': 2, '5': 1 }\n`})}),`\n`,(0,n.jsx)(e.h2,{children:\"Resources\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:(0,n.jsxs)(e.a,{href:\"https://lodash.com/docs/#countBy\",children:[\"Lodash \",(0,n.jsx)(e.code,{children:\"_..countBy\"})]})}),`\n`]})]})}function _(r={}){let{wrapper:e}=r.components||{};return e?(0,n.jsx)(e,Object.assign({},r,{children:(0,n.jsx)(d,r)})):d(r)}var v=_;return j(B);})();\n;return Component;",
  "files": {
    "/package.json": "{\n  \"name\": \"@gfe-questions/count-by\",\n  \"version\": \"0.0.1\",\n  \"main\": \"/src/count-by.js\",\n  \"devDependencies\": {\n    \"@types/jest\": \"29.5.0\",\n    \"typescript\": \"5.0.2\"\n  }\n}\n",
    "/tsconfig.json": "{\n  \"include\": [\"./**/*\"],\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"lib\": [\"dom\", \"esnext\"],\n    \"jsx\": \"react-jsx\"\n  }\n}\n",
    "/src/count-by-alt.js": "/**\n * @param {Array} array The array to iterate over.\n * @param {Function|string} iteratee The function invoked per iteration.\n * @returns {Object} Returns the composed aggregate object.\n */\nexport default function countBy(array, iteratee) {\n  const result = Object.create(null);\n\n  for (const element of array) {\n    const key =\n      typeof iteratee === 'function' ? iteratee(element) : element[iteratee];\n    result[key] ??= 0;\n    result[key]++;\n  }\n\n  return result;\n}\n",
    "/src/count-by.js": "/**\n * @param {Array} array The array to iterate over.\n * @param {Function|string} iteratee The function invoked per iteration.\n * @returns {Object} Returns the composed aggregate object.\n */\nexport default function countBy(array, iteratee) {\n  const result = {};\n  const iterateeFunc =\n    typeof iteratee === 'function' ? iteratee : (value) => value[iteratee];\n\n  for (const element of array) {\n    const key = iterateeFunc(element);\n    if (!Object.prototype.hasOwnProperty.call(result, key)) {\n      result[key] = 0;\n    }\n\n    result[key]++;\n  }\n\n  return result;\n}\n",
    "/src/count-by.lodash.test.js": "import { countBy } from 'lodash';\n\ndescribe('countBy', () => {\n  test('empty array', () => {\n    expect(countBy([], Math.floor)).toEqual({});\n  });\n\n  describe('function iteratees', () => {\n    test('single-element arrays', () => {\n      expect(countBy([6.1], Math.floor)).toEqual({ 6: 1 });\n    });\n\n    test('two-element arrays', () => {\n      expect(countBy([6.1, 4.2], Math.floor)).toEqual({ 4: 1, 6: 1 });\n    });\n\n    test('multiple element arrays', () => {\n      expect(countBy([6.1, 4.2, 6.3], Math.floor)).toEqual({ 4: 1, 6: 2 });\n    });\n\n    test('keys that are also properties', () => {\n      expect(countBy(['one', 'two', 'three'], () => 'length')).toEqual({\n        length: 3,\n      });\n    });\n  });\n\n  describe('property iteratees', () => {\n    test('single-element arrays', () => {\n      expect(countBy(['one'], 'length')).toEqual({ 3: 1 });\n    });\n\n    test('two-element arrays', () => {\n      expect(countBy(['one', 'two'], 'length')).toEqual({ 3: 2 });\n    });\n\n    test('multiple element arrays', () => {\n      expect(countBy(['one', 'two', 'three'], 'length')).toEqual({\n        3: 2,\n        5: 1,\n      });\n    });\n  });\n\n  test('does not mutate the original array', () => {\n    const arr = [6.1, 4.2, 6.3];\n    const result = countBy(arr, Math.floor);\n    expect(result).toEqual({ 4: 1, 6: 2 });\n    expect(arr).toEqual([6.1, 4.2, 6.3]); // Ensure original array is unchanged\n  });\n});\n",
    "/src/count-by.run.test.ts": "import countBy from './count-by';\n\ndescribe('countBy', () => {\n  test('empty array', () => {\n    expect(countBy([], Math.floor)).toEqual({});\n  });\n\n  describe('function iteratees', () => {\n    test('single-element arrays', () => {\n      expect(countBy([6.1], Math.floor)).toEqual({ 6: 1 });\n    });\n\n    test('two-element arrays', () => {\n      expect(countBy([6.1, 4.2], Math.floor)).toEqual({ 4: 1, 6: 1 });\n    });\n\n    test('multiple element arrays', () => {\n      expect(countBy([6.1, 4.2, 6.3], Math.floor)).toEqual({ 4: 1, 6: 2 });\n    });\n\n    test('keys that are also properties', () => {\n      expect(countBy(['one', 'two', 'three'], (val) => 'length')).toEqual({\n        length: 3,\n      });\n    });\n  });\n\n  describe('property iteratees', () => {\n    test('single-element arrays', () => {\n      expect(countBy(['one'], 'length')).toEqual({ 3: 1 });\n    });\n\n    test('two-element arrays', () => {\n      expect(countBy(['one', 'two'], 'length')).toEqual({ 3: 2 });\n    });\n\n    test('multiple element arrays', () => {\n      expect(countBy(['one', 'two', 'three'], 'length')).toEqual({\n        3: 2,\n        5: 1,\n      });\n    });\n  });\n\n  test('does not mutate the original array', () => {\n    const arr = [6.1, 4.2, 6.3];\n    const copy = arr.slice();\n    const result = countBy(arr, Math.floor);\n    expect(result).toEqual({ 4: 1, 6: 2 });\n    expect(arr).toEqual(copy); // Ensure original array is unchanged\n  });\n});\n",
    "/src/count-by.submit.test.ts": "import countBy from './count-by';\n\ndescribe('countBy', () => {\n  test('empty array', () => {\n    expect(countBy([], Math.floor)).toEqual({});\n  });\n\n  describe('function iteratees', () => {\n    test('single-element arrays', () => {\n      expect(countBy([6.1], Math.floor)).toEqual({ 6: 1 });\n    });\n\n    test('two-element arrays', () => {\n      expect(countBy([6.1, 4.2], Math.floor)).toEqual({ 4: 1, 6: 1 });\n    });\n\n    test('multiple element arrays', () => {\n      expect(countBy([6.1, 4.2, 6.3], Math.floor)).toEqual({ 4: 1, 6: 2 });\n    });\n\n    test('keys that are also properties', () => {\n      expect(countBy(['one', 'two', 'three'], (val) => 'length')).toEqual({\n        length: 3,\n      });\n    });\n  });\n\n  describe('property iteratees', () => {\n    test('single-element arrays', () => {\n      expect(countBy(['one'], 'length')).toEqual({ 3: 1 });\n    });\n\n    test('two-element arrays', () => {\n      expect(countBy(['one', 'two'], 'length')).toEqual({ 3: 2 });\n    });\n\n    test('multiple element arrays', () => {\n      expect(countBy(['one', 'two', 'three'], 'length')).toEqual({\n        3: 2,\n        5: 1,\n      });\n    });\n  });\n\n  test('does not mutate the original array', () => {\n    const arr = [6.1, 4.2, 6.3];\n    const copy = arr.slice();\n    const result = countBy(arr, Math.floor);\n    expect(result).toEqual({ 4: 1, 6: 2 });\n    expect(arr).toEqual(copy); // Ensure original array is unchanged\n  });\n});\n"
  },
  "format": "javascript",
  "metadata": {
    "author": null,
    "companies": [],
    "created": 1690416000,
    "difficulty": "medium",
    "duration": 15,
    "excerpt": "Implement a function that counts the number of times a value appears in an array based on a function or property name",
    "featured": false,
    "format": "javascript",
    "frameworkDefault": null,
    "frameworks": [],
    "href": "/questions/javascript/count-by",
    "importance": "low",
    "languages": [
      "js",
      "ts"
    ],
    "nextQuestions": [],
    "premium": false,
    "published": true,
    "ranking": 100,
    "similarQuestions": [
      "group-by"
    ],
    "slug": "count-by",
    "subtitle": null,
    "title": "Count By",
    "topics": []
  },
  "skeleton": {
    "js": "/**\n * @param {Array} array The array to iterate over.\n * @param {Function|string} iteratee The function invoked per iteration.\n * @returns {Object} Returns the composed aggregate object.\n */\nexport default function countBy(array, iteratee) {\n  throw 'Not implemented!';\n}",
    "ts": "export default function countBy<T>(\n  array: Array<T>,\n  iteratee: ((value: T) => any) | string,\n): { [key: string]: number } {\n  throw 'Not implemented!';\n}"
  },
  "solution": "var Component=(()=>{var m=Object.create;var i=Object.defineProperty;var f=Object.getOwnPropertyDescriptor;var p=Object.getOwnPropertyNames;var g=Object.getPrototypeOf,b=Object.prototype.hasOwnProperty;var j=(r,e)=>()=>(e||r((e={exports:{}}).exports,e),e.exports),k=(r,e)=>{for(var n in e)i(r,n,{get:e[n],enumerable:!0})},s=(r,e,n,c)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let o of p(e))!b.call(r,o)&&o!==n&&i(r,o,{get:()=>e[o],enumerable:!(c=f(e,o))||c.enumerable});return r};var v=(r,e,n)=>(n=r!=null?m(g(r)):{},s(e||!r||!r.__esModule?i(n,\"default\",{value:r,enumerable:!0}):n,r)),x=r=>s(i({},\"__esModule\",{value:!0}),r);var h=j((D,l)=>{l.exports=_jsx_runtime});var F={};k(F,{default:()=>B});var t=v(h());var a=MDXCodeBlock;var u=`/**\n * @param {Array} array The array to iterate over.\n * @param {Function|string} iteratee The function invoked per iteration.\n * @returns {Object} Returns the composed aggregate object.\n */\nexport default function countBy(array, iteratee) {\n  const result = {};\n  const iterateeFunc =\n    typeof iteratee === 'function' ? iteratee : (value) => value[iteratee];\n\n  for (const element of array) {\n    const key = iterateeFunc(element);\n    if (!Object.prototype.hasOwnProperty.call(result, key)) {\n      result[key] = 0;\n    }\n\n    result[key]++;\n  }\n\n  return result;\n}\n`;var d=`/**\n * @param {Array} array The array to iterate over.\n * @param {Function|string} iteratee The function invoked per iteration.\n * @returns {Object} Returns the composed aggregate object.\n */\nexport default function countBy(array, iteratee) {\n  const result = Object.create(null);\n\n  for (const element of array) {\n    const key =\n      typeof iteratee === 'function' ? iteratee(element) : element[iteratee];\n    result[key] ??= 0;\n    result[key]++;\n  }\n\n  return result;\n}\n`;function y(r){let e=Object.assign({h2:\"h2\",ol:\"ol\",li:\"li\",code:\"code\",p:\"p\",a:\"a\",ul:\"ul\"},r.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,t.jsxs)(e.ol,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"Create an empty \",(0,t.jsx)(e.code,{children:\"results\"}),\" object to store the count of occurrences of each key.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Determine the \",(0,t.jsx)(e.code,{children:\"iteratee\"}),\" function. If \",(0,t.jsx)(e.code,{children:\"iteratee\"}),\" is already a function, we can use it as-is. Otherwise, if a string value was provided, a function is created to access that property on an element.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Iterate through the array and determine the key for each element by calling \",(0,t.jsx)(e.code,{children:\"iteratee(element)\"}),\". If the key does not exist within the \",(0,t.jsx)(e.code,{children:\"results\"}),\" object, set the value for that key to 0. Next we can increment the value for that key.\"]}),`\n`]}),`\n`,(0,t.jsx)(a,{children:u}),`\n`,(0,t.jsxs)(e.p,{children:[\"An alternative way to increment the \",(0,t.jsx)(e.code,{children:\"result\"}),\" counter is to use the \",(0,t.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Nullish_coalescing_assignment\",children:\"nullish coalescing assignment operator\"}),\" to set the value to 0 if \",(0,t.jsx)(e.code,{children:\"key\"}),\" doesn't exist within \",(0,t.jsx)(e.code,{children:\"result\"}),\". Note that using nullish coalescing assignment operator means you might be accessing inherited properties, which is not desired, but since the object is created via \",(0,t.jsx)(e.code,{children:\"Object.create(null)\"}),\", there will not be inherited properties and is safe to use.\"]}),`\n`,(0,t.jsx)(a,{children:d}),`\n`,(0,t.jsx)(e.h2,{children:\"Resources\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:(0,t.jsxs)(e.a,{href:\"https://lodash.com/docs/#countBy\",children:[\"Lodash \",(0,t.jsx)(e.code,{children:\"_.countBy\"})]})}),`\n`]})]})}function _(r={}){let{wrapper:e}=r.components||{};return e?(0,t.jsx)(e,Object.assign({},r,{children:(0,t.jsx)(y,r)})):y(r)}var B=_;return x(F);})();\n;return Component;",
  "workspace": {
    "main": "/src/count-by.js",
    "run": "/src/count-by.run.test.ts",
    "submit": "/src/count-by.submit.test.ts"
  }
}