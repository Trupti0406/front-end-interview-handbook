{
  "description": "var Component=(()=>{var h=Object.create;var o=Object.defineProperty;var m=Object.getOwnPropertyDescriptor;var p=Object.getOwnPropertyNames;var f=Object.getPrototypeOf,u=Object.prototype.hasOwnProperty;var g=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),b=(n,e)=>{for(var t in e)o(n,t,{get:e[t],enumerable:!0})},s=(n,e,t,c)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let r of p(e))!u.call(n,r)&&r!==t&&o(n,r,{get:()=>e[r],enumerable:!(c=m(e,r))||c.enumerable});return n};var y=(n,e,t)=>(t=n!=null?h(f(n)):{},s(e||!n||!n.__esModule?o(t,\"default\",{value:n,enumerable:!0}):t,n)),k=n=>s(o({},\"__esModule\",{value:!0}),n);var l=g((F,i)=>{i.exports=_jsx_runtime});var _={};b(_,{default:()=>w,frontmatter:()=>j});var a=y(l()),j={title:\"Promisify\",excerpt:\"Implement a function that takes a function following the common error-first callback style and returns a version that returns promises\"};function d(n){let e=Object.assign({p:\"p\",code:\"code\",a:\"a\",h2:\"h2\",pre:\"pre\"},n.components);return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(e.p,{children:[\"Before promises/\",(0,a.jsx)(e.code,{children:\"async\"}),\"/\",(0,a.jsx)(e.code,{children:\"await\"}),\" became the standard, it was a convention for async APIs in JavaScript to accept callbacks as the last argument. Many async versions of Node.js APIs (e.g. \",(0,a.jsx)(e.a,{href:\"https://nodejs.org/api/fs.html#fsreadfilepath-options-callback\",children:(0,a.jsx)(e.code,{children:\"fs.readFile\"})}),\" and \",(0,a.jsx)(e.a,{href:\"https://nodejs.org/api/fs.html#fsrmpath-options-callback\",children:(0,a.jsx)(e.code,{children:\"fs.rm\"})}),\") have such signatures. Node.js' \",(0,a.jsx)(e.a,{href:\"https://nodejs.org/api/util.html#util_util_promisify_original\",children:(0,a.jsx)(e.code,{children:\"util.promisify\"})}),\" function was created to wrap around callback-based functions by returning \",(0,a.jsx)(e.code,{children:\"Promise\"}),\"s so that they can be used with \",(0,a.jsx)(e.code,{children:\"async\"}),\"/\",(0,a.jsx)(e.code,{children:\"await\"}),\".\"]}),`\n`,(0,a.jsxs)(e.p,{children:[\"Implement a function \",(0,a.jsx)(e.code,{children:\"promisify\"}),\" that takes a function following the common callback-last error-first style, i.e. taking a \",(0,a.jsx)(e.code,{children:\"(err, value) => ...\"}),\" callback as the last argument, and returns a version that returns promises.\"]}),`\n`,(0,a.jsx)(e.h2,{children:\"Examples\"}),`\n`,(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:\"language-js\",children:`// Example function with callback as last argument\n// The callback has the signature \\`(err, value) => any\\`\nfunction foo(url, options, callback) {\n  apiCall(url, options)\n    .then((data) => callback(null, data))\n    .catch((err) => callback(err));\n}\n\nconst promisifiedFoo = promisify(foo);\nconst data = await promisifiedFoo('example.com', { foo: 1 });\n`})})]})}function x(n={}){let{wrapper:e}=n.components||{};return e?(0,a.jsx)(e,Object.assign({},n,{children:(0,a.jsx)(d,n)})):d(n)}var w=x;return k(_);})();\n;return Component;",
  "format": "javascript",
  "metadata": {
    "author": null,
    "companies": [
      "amazon"
    ],
    "created": 1690070400,
    "difficulty": "medium",
    "duration": 15,
    "excerpt": "Implement a function that takes a function following the common error-first callback style and returns a version that returns promises",
    "featured": false,
    "format": "javascript",
    "frameworkDefault": null,
    "frameworks": [],
    "href": "/questions/javascript/promisify",
    "importance": "low",
    "languages": [
      "js",
      "ts"
    ],
    "nextQuestions": [
      "promisify-ii"
    ],
    "premium": true,
    "published": true,
    "ranking": 100,
    "similarQuestions": [],
    "slug": "promisify",
    "subtitle": null,
    "title": "Promisify",
    "topics": []
  },
  "skeleton": {
    "js": "/**\n * @callback func\n * @returns Function\n */\nexport default function promisify(func) {\n  throw 'Not implemented';\n}",
    "ts": "export default function promisify(func: Function): Function {\n  throw 'Not implemented';\n}"
  },
  "solution": "var Component=(()=>{var f=Object.create;var c=Object.defineProperty;var m=Object.getOwnPropertyDescriptor;var p=Object.getOwnPropertyNames;var y=Object.getPrototypeOf,g=Object.prototype.hasOwnProperty;var w=(i,e)=>()=>(e||i((e={exports:{}}).exports,e),e.exports),b=(i,e)=>{for(var r in e)c(i,r,{get:e[r],enumerable:!0})},s=(i,e,r,o)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let t of p(e))!g.call(i,t)&&t!==r&&c(i,t,{get:()=>e[t],enumerable:!(o=m(e,t))||o.enumerable});return i};var k=(i,e,r)=>(r=i!=null?f(y(i)):{},s(e||!i||!i.__esModule?c(r,\"default\",{value:i,enumerable:!0}):r,i)),v=i=>s(c({},\"__esModule\",{value:!0}),i);var l=w((I,a)=>{a.exports=_jsx_runtime});var P={};b(P,{default:()=>_});var n=k(l());var h=MDXCodeBlock;var d=`/**\n * @callback func\n * @returns Function\n */\nexport default function promisify(func) {\n  return function (...args) {\n    return new Promise((resolve, reject) => {\n      func.call(this, ...args, (err, result) =>\n        err ? reject(err) : resolve(result),\n      );\n    });\n  };\n}\n`;function u(i){let e=Object.assign({h2:\"h2\",ol:\"ol\",li:\"li\",code:\"code\",p:\"p\",h3:\"h3\",a:\"a\",ul:\"ul\"},i.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"The \",(0,n.jsx)(e.code,{children:\"promisify\"}),\" function takes a single argument \",(0,n.jsx)(e.code,{children:\"func\"}),\", which is the callback-based function you want to promisify.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"The \",(0,n.jsx)(e.code,{children:\"return\"}),\" statement returns a new function that wraps \",(0,n.jsx)(e.code,{children:\"func\"}),\". This new function is the promisified version.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Inside the returned function, we use the spread operator \",(0,n.jsx)(e.code,{children:\"...args\"}),\" to capture any arguments passed to the promisified function.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"We create a new \",(0,n.jsx)(e.code,{children:\"Promise\"}),\" that wraps the original callback-based function. The Promise constructor takes a function with two arguments: \",(0,n.jsx)(e.code,{children:\"resolve\"}),\" and \",(0,n.jsx)(e.code,{children:\"reject\"}),\". These are functions we call based on the outcome of the asynchronous operation.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Inside the Promise's function, we invoke \",(0,n.jsx)(e.code,{children:\"func\"}),\" with the provided arguments \",(0,n.jsx)(e.code,{children:\"(...args)\"}),\" and pass a callback function as its last argument as that's what \",(0,n.jsx)(e.code,{children:\"func\"}),\" expects.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"The callback function takes two arguments: \",(0,n.jsx)(e.code,{children:\"err\"}),\" (error) and \",(0,n.jsx)(e.code,{children:\"result\"}),\" (success value). If \",(0,n.jsx)(e.code,{children:\"err\"}),\" is truthy, we reject the \",(0,n.jsx)(e.code,{children:\"Promise\"}),\" with the \",(0,n.jsx)(e.code,{children:\"err\"}),\". Otherwise, we resolve the \",(0,n.jsx)(e.code,{children:\"Promise\"}),\" with the \",(0,n.jsx)(e.code,{children:\"result\"}),\".\"]}),`\n`]}),`\n`,(0,n.jsxs)(e.p,{children:[\"With the \",(0,n.jsx)(e.code,{children:\"promisify\"}),\" function, you can convert any callback-based function into a \",(0,n.jsx)(e.code,{children:\"Promise\"}),\"-based function, making it easier to work with asynchronous operations using modern Promise syntax.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"To preserve the \",(0,n.jsx)(e.code,{children:\"this\"}),\" value, the returned function should not be defined using arrow functions and \",(0,n.jsx)(e.code,{children:\"func\"}),\" should be invoked with \",(0,n.jsx)(e.code,{children:\"call\"}),\"/\",(0,n.jsx)(e.code,{children:\"apply\"}),\" and the correct \",(0,n.jsx)(e.code,{children:\"thisArg\"}),\" value.\"]}),`\n`,(0,n.jsx)(h,{children:d}),`\n`,(0,n.jsx)(e.h3,{children:\"Notes\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"The \",(0,n.jsx)(e.code,{children:\"promisify\"}),\" function assumes the callback is the last argument and that the callback uses an error-first format. If the function you are trying to promisify is not the last argument or has a different format, you cannot use this. Node.js provides a custom promisify function \",(0,n.jsx)(e.a,{href:\"https://nodejs.org/api/util.html#util_custom_promisified_functions\",children:(0,n.jsx)(e.code,{children:\"util.promisify.custom\"})}),\" that you can use for such cases.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Not every function that accepts callbacks can/should be promisified! A promise can have only one result, but a callback can be called many times (e.g. \",(0,n.jsx)(e.code,{children:\"setInterval\"}),\"). Hence promisification is only meant for functions that call the callback once because further calls will be ignored.\"]}),`\n`,(0,n.jsx)(e.h2,{children:\"Resources\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:(0,n.jsxs)(e.a,{href:\"https://nodejs.org/api/util.html#utilpromisifyoriginal\",children:[\"Node.js \",(0,n.jsx)(e.code,{children:\"util.promisify\"})]})}),`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://javascript.info/promisify\",children:\"Promisification\"})}),`\n`]})]})}function x(i={}){let{wrapper:e}=i.components||{};return e?(0,n.jsx)(e,Object.assign({},i,{children:(0,n.jsx)(u,i)})):u(i)}var _=x;return v(P);})();\n;return Component;",
  "tests": "import promisify from './promisify';\n\ndescribe('promisify', () => {\n  function delayedResolve(cb) {\n    setTimeout(() => {\n      cb(null, 42);\n    }, 10);\n  }\n\n  function asyncError(x, cb) {\n    setTimeout(() => {\n      cb(x);\n    }, 10);\n  }\n\n  describe('returns correct types', () => {\n    test('returns a function', () => {\n      const promisified = promisify(delayedResolve);\n      expect(typeof promisified).toBe('function');\n    });\n\n    test('promisified returns a promise', () => {\n      const promisified = promisify(delayedResolve);\n      expect(promisified() instanceof Promise).toBe(true);\n    });\n  });\n\n  describe('use with await', () => {\n    describe('resolved', () => {\n      test('no arguments', async () => {\n        expect.assertions(1);\n        const promisified = promisify(delayedResolve);\n        const res = await promisified();\n        expect(res).toBe(42);\n      });\n\n      test('one argument', async () => {\n        function asyncIdentity(x, cb) {\n          setTimeout(() => {\n            cb(null, x);\n          }, 10);\n        }\n\n        expect.assertions(1);\n        const promisified = promisify(asyncIdentity);\n        const res = await promisified(23);\n        expect(res).toBe(23);\n      });\n\n      test('two arguments', async () => {\n        function asyncAdd(a, b, cb) {\n          setTimeout(() => {\n            cb(null, a + b);\n          }, 10);\n        }\n\n        expect.assertions(1);\n        const promisified = promisify(asyncAdd);\n        const res = await promisified(17, 19);\n        expect(res).toBe(36);\n      });\n    });\n\n    test('rejected', async () => {\n      expect.assertions(1);\n      try {\n        const promisified = promisify(asyncError);\n        await promisified(23);\n      } catch (err) {\n        expect(err).toBe(23);\n      }\n    });\n  });\n\n  test('can access `this`', async () => {\n    expect.assertions(1);\n    function asyncAdd(a, b, cb) {\n      setTimeout(() => {\n        cb(null, a + b + this.base);\n      }, 10);\n    }\n\n    const promisifiedAdd = promisify(asyncAdd);\n    const obj = { base: 5, add: promisifiedAdd };\n    const res = await obj.add(17, 19);\n    expect(res).toBe(41);\n  });\n\n  describe('use without await', () => {\n    test('then', (done) => {\n      expect.assertions(1);\n      const promisified = promisify(delayedResolve);\n      promisified().then((res) => {\n        expect(res).toBe(42);\n        done();\n      });\n    });\n\n    test('catch', (done) => {\n      expect.assertions(1);\n      const promisified = promisify(asyncError);\n      promisified(23)\n        .then()\n        .catch((err) => {\n          expect(err).toBe(23);\n          done();\n        });\n    });\n  });\n});"
}