{
  "description": "var Component=(()=>{var h=Object.create;var r=Object.defineProperty;var m=Object.getOwnPropertyDescriptor;var f=Object.getOwnPropertyNames;var d=Object.getPrototypeOf,p=Object.prototype.hasOwnProperty;var g=(o,e)=>()=>(e||o((e={exports:{}}).exports,e),e.exports),y=(o,e)=>{for(var i in e)r(o,i,{get:e[i],enumerable:!0})},a=(o,e,i,s)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let t of f(e))!p.call(o,t)&&t!==i&&r(o,t,{get:()=>e[t],enumerable:!(s=m(e,t))||s.enumerable});return o};var b=(o,e,i)=>(i=o!=null?h(d(o)):{},a(e||!o||!o.__esModule?r(i,\"default\",{value:o,enumerable:!0}):i,o)),j=o=>a(r({},\"__esModule\",{value:!0}),o);var c=g((_,l)=>{l.exports=_jsx_runtime});var x={};y(x,{default:()=>k,frontmatter:()=>v});var n=b(c()),v={title:\"Promisify II\",excerpt:\"Implement a promisify function that allows the original function to override the return value\"};function u(o){let e=Object.assign({p:\"p\",strong:\"strong\",a:\"a\",code:\"code\",pre:\"pre\",h2:\"h2\",ul:\"ul\",li:\"li\"},o.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.strong,{children:\"Note:\"}),\" This is an advanced version of \",(0,n.jsx)(e.a,{href:\"/questions/javascript/promisify\",children:\"Promisify\"}),\", which you should complete first before attempting this question.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"In \",(0,n.jsx)(e.a,{href:\"/questions/javascript/promisify\",children:\"Promisify\"}),\", the \",(0,n.jsx)(e.code,{children:\"promisify\"}),\" function returns a promise for a function following the common callback-last error-first callback style, i.e. taking a \",(0,n.jsx)(e.code,{children:\"(err, value) => ...\"}),\" callback as the last argument. However, \",(0,n.jsx)(e.code,{children:\"promisify\"}),\" does not work for functions that do not follow that exact signature.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"In Node.js, using the \",(0,n.jsx)(e.code,{children:\"util.promisify.custom\"}),\" symbol, one can override the return value of \",(0,n.jsx)(e.code,{children:\"util.promisify()\"}),\", which is useful for cases where the original function does not follow the standard format of taking an error-first callback as the last argument. This is especially useful for functions with a legacy format that's incompatible with \",(0,n.jsx)(e.code,{children:\"util.promisify\"}),\"'s callback-last convention.\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`// Example usage in Node.js.\nconst util = require('node:util');\n\nfunction doSomething(callback, foo) {\n  // ...\n}\n\ndoSomething[util.promisify.custom] = (foo) => {\n  return getPromiseSomehow();\n};\n\nconst promisified = util.promisify(doSomething);\nconsole.log(promisified === doSomething[util.promisify.custom]);\n// prints 'true'\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"Implement a \",(0,n.jsx)(e.code,{children:\"promisify\"}),\" function that has support for custom return values. Use the symbol \",(0,n.jsx)(e.code,{children:\"Symbol('util.promisify.custom')\"}),\" as the key for the overridden value.\"]}),`\n`,(0,n.jsx)(e.h2,{children:\"Examples\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`// Example function with callback as the first argument.\n// The callback has the signature \\`(err, value) => any\\`.\nfunction foo(callback, url, options) {\n  apiCall(url, options)\n    .then((data) => callback(null, data))\n    .catch((err) => callback(err));\n}\n\nfoo[Symbol('util.promisify.custom')] = (url, options) => {\n  return new Promise((resolve, reject) => {\n    foo(\n      (err, data) => {\n        if (err) {\n          reject(err);\n        }\n        resolve(data);\n      },\n      url,\n      options,\n    );\n  });\n};\n\nconst promisifiedFoo = foo[Symbol('util.promisify.custom')]; // true\nconst data = await promisifiedFoo('example.com', { foo: 1 });\n`})}),`\n`,(0,n.jsx)(e.h2,{children:\"Resources\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://nodejs.org/api/util.html#custom-promisified-functions\",children:\"Custom promisified functions | Node.js\"})}),`\n`]})]})}function w(o={}){let{wrapper:e}=o.components||{};return e?(0,n.jsx)(e,Object.assign({},o,{children:(0,n.jsx)(u,o)})):u(o)}var k=w;return j(x);})();\n;return Component;",
  "format": "javascript",
  "metadata": {
    "author": null,
    "companies": [],
    "created": 1690070400,
    "difficulty": "medium",
    "duration": 15,
    "excerpt": "Implement a promisify function that allows the original function to override the return value",
    "featured": false,
    "format": "javascript",
    "frameworkDefault": null,
    "frameworks": [],
    "href": "/questions/javascript/promisify-ii",
    "importance": "low",
    "languages": [
      "js",
      "ts"
    ],
    "nextQuestions": [],
    "premium": true,
    "published": true,
    "ranking": 100,
    "similarQuestions": [],
    "slug": "promisify-ii",
    "subtitle": null,
    "title": "Promisify II",
    "topics": []
  },
  "skeleton": {
    "js": "/**\n * @callback func\n * @returns Function\n */\nexport default function promisify(func) {\n  throw 'Not implemented';\n}",
    "ts": "const promisifyCustomSymbol = Symbol.for('util.promisify.custom');\n\ntype Func = (...args: any[]) => void;\ntype Return<T> = (this: any, ...args: any[]) => Promise<T>;\ntype WithSymbol<T> = { [promisifyCustomSymbol]: Return<T> };\ntype Param<T> = Func | WithSymbol<T>;\n\nexport default function promisify<T>(func: Param<T>): Return<T> {\n  throw 'Not implemented';\n}"
  },
  "solution": "var Component=(()=>{var d=Object.create;var i=Object.defineProperty;var h=Object.getOwnPropertyDescriptor;var p=Object.getOwnPropertyNames;var g=Object.getPrototypeOf,b=Object.prototype.hasOwnProperty;var T=(o,e)=>()=>(e||o((e={exports:{}}).exports,e),e.exports),j=(o,e)=>{for(var t in e)i(o,t,{get:e[t],enumerable:!0})},u=(o,e,t,s)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let n of p(e))!b.call(o,n)&&n!==t&&i(o,n,{get:()=>e[n],enumerable:!(s=h(e,n))||s.enumerable});return o};var S=(o,e,t)=>(t=o!=null?d(g(o)):{},u(e||!o||!o.__esModule?i(t,\"default\",{value:o,enumerable:!0}):t,o)),x=o=>u(i({},\"__esModule\",{value:!0}),o);var m=T((M,c)=>{c.exports=_jsx_runtime});var P={};j(P,{default:()=>F});var r=S(m());var l=MDXCodeBlock;var f=`const promisifyCustomSymbol = Symbol.for('util.promisify.custom');\n\n/**\n * @callback func\n * @returns Function\n */\nexport default function promisify(func) {\n  if (func[promisifyCustomSymbol]) {\n    return func[promisifyCustomSymbol];\n  }\n\n  return function (...args) {\n    return new Promise((resolve, reject) => {\n      func.call(this, ...args, (err, result) =>\n        err ? reject(err) : resolve(result),\n      );\n    });\n  };\n}\n`;var a=`const promisifyCustomSymbol = Symbol.for('util.promisify.custom');\n\ntype Func = (...args: any[]) => void;\ntype Return<T> = (this: any, ...args: any[]) => Promise<T>;\ntype WithSymbol<T> = { [promisifyCustomSymbol]: Return<T> };\ntype Param<T> = Func | WithSymbol<T>;\n\nexport default function promisify<T>(func: Param<T>): Return<T> {\n  if ((func as WithSymbol<T>)[promisifyCustomSymbol]) {\n    return (func as WithSymbol<T>)[promisifyCustomSymbol];\n  }\n\n  return function (...args) {\n    return new Promise<T>((resolve, reject) => {\n      (func as Func).call(this, ...args, (err: any, result: T) =>\n        err ? reject(err) : resolve(result),\n      );\n    });\n  };\n}\n`;function y(o){let e=Object.assign({p:\"p\",strong:\"strong\",a:\"a\",h2:\"h2\",code:\"code\",ul:\"ul\",li:\"li\"},o.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:\"Note:\"}),\" This is an advanced version of \",(0,r.jsx)(e.a,{href:\"/questions/javascript/promisify\",children:\"Promisify\"}),\", which you should complete first before attempting this question.\"]}),`\n`,(0,r.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,r.jsxs)(e.p,{children:[\"The only addition you need to make is to check if the \",(0,r.jsx)(e.code,{children:\"func\"}),\" argument has the custom \",(0,r.jsx)(e.code,{children:\"Symbol('util.promisify.custom')\"}),\" defined and return the corresponding value if so.\"]}),`\n`,(0,r.jsx)(l,{languages:{jsx:f,tsx:a}}),`\n`,(0,r.jsx)(e.h2,{children:\"Resources\"}),`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:\"https://nodejs.org/api/util.html#custom-promisified-functions\",children:\"Custom promisified functions | Node.js\"})}),`\n`]})]})}function _(o={}){let{wrapper:e}=o.components||{};return e?(0,r.jsx)(e,Object.assign({},o,{children:(0,r.jsx)(y,o)})):y(o)}var F=_;return x(P);})();\n;return Component;",
  "tests": "import promisify from './promisify-ii';\n\ndescribe('promisify', () => {\n  function delayedResolve(cb: Function) {\n    setTimeout(() => {\n      cb(null, 42);\n    }, 10);\n  }\n\n  function asyncError(x: number, cb: Function) {\n    setTimeout(() => {\n      cb(x);\n    }, 10);\n  }\n\n  describe('returns correct types', () => {\n    test('returns a function', () => {\n      const promisified = promisify(delayedResolve);\n      expect(promisified).toBeInstanceOf(Function);\n    });\n\n    test('calling promisified returns a promise', () => {\n      const promisified = promisify(delayedResolve);\n      expect(promisified()).toBeInstanceOf(Promise);\n    });\n  });\n\n  describe('use with await', () => {\n    describe('resolved', () => {\n      test('no arguments', async () => {\n        expect.assertions(1);\n        const promisified = promisify(delayedResolve);\n        const res = await promisified();\n        expect(res).toBe(42);\n      });\n\n      test('one argument', async () => {\n        function asyncIdentity(x: number, cb: Function) {\n          setTimeout(() => {\n            cb(null, x);\n          }, 10);\n        }\n\n        expect.assertions(1);\n        const promisified = promisify(asyncIdentity);\n        const res = await promisified(23);\n        expect(res).toBe(23);\n      });\n\n      test('two arguments', async () => {\n        function asyncAdd(a: number, b: number, cb: Function) {\n          setTimeout(() => {\n            cb(null, a + b);\n          }, 10);\n        }\n\n        expect.assertions(1);\n        const promisified = promisify(asyncAdd);\n        const res = await promisified(17, 19);\n        expect(res).toBe(36);\n      });\n    });\n\n    test('rejected', async () => {\n      expect.assertions(1);\n      try {\n        const promisified = promisify(asyncError);\n        await promisified(23);\n      } catch (err) {\n        expect(err).toBe(23);\n      }\n    });\n  });\n\n  test('can access `this`', async () => {\n    expect.assertions(1);\n    function asyncAdd(this: any, a: number, b: number, cb: Function) {\n      setTimeout(() => {\n        cb(null, a + b + this.base);\n      }, 10);\n    }\n\n    const promisifiedAdd = promisify(asyncAdd);\n    const obj = { base: 5, add: promisifiedAdd };\n    const res = await obj.add(17, 19);\n    expect(res).toBe(41);\n  });\n\n  describe('use without await', () => {\n    test('then', (done) => {\n      expect.assertions(1);\n      const promisified = promisify(delayedResolve);\n      promisified().then((res) => {\n        expect(res).toBe(42);\n        done();\n      });\n    });\n\n    test('catch', (done) => {\n      expect.assertions(1);\n      const promisified = promisify(asyncError);\n      promisified(23)\n        .then()\n        .catch((err) => {\n          expect(err).toBe(23);\n          done();\n        });\n    });\n  });\n\n  describe('custom', () => {\n    test('resolve', async () => {\n      expect.assertions(1);\n      function asyncIdentityCustom<T>(cb: Function, x: T) {\n        setTimeout(() => {\n          cb(null, x);\n        }, 10);\n      }\n      const customPromisify = <T>(x: T) =>\n        new Promise((resolve) => {\n          asyncIdentityCustom((_: unknown, res: T) => resolve(res), x);\n        });\n      (asyncIdentityCustom as any)[Symbol.for('util.promisify.custom')] =\n        customPromisify;\n\n      const promisified = promisify(asyncIdentityCustom);\n      const res = await promisified(23);\n      expect(res).toBe(23);\n    });\n\n    test('reject', async () => {\n      expect.assertions(1);\n      function asyncErrorCustom(cb: Function, x: number) {\n        setTimeout(() => {\n          cb(x);\n        }, 10);\n      }\n      const customPromisify = (x: number) =>\n        new Promise((_, reject) => {\n          asyncErrorCustom((err: any) => reject(err), x);\n        });\n      (asyncErrorCustom as any)[Symbol.for('util.promisify.custom')] =\n        customPromisify;\n\n      try {\n        const promisified = promisify(asyncErrorCustom);\n        await promisified(23);\n      } catch (err) {\n        expect(err).toBe(23);\n      }\n    });\n  });\n});"
}