{
  "description": "var Component=(()=>{var u=Object.create;var r=Object.defineProperty;var p=Object.getOwnPropertyDescriptor;var h=Object.getOwnPropertyNames;var m=Object.getPrototypeOf,v=Object.prototype.hasOwnProperty;var f=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),j=(n,e)=>{for(var o in e)r(n,o,{get:e[o],enumerable:!0})},a=(n,e,o,s)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let c of h(e))!v.call(n,c)&&c!==o&&r(n,c,{get:()=>e[c],enumerable:!(s=p(e,c))||s.enumerable});return n};var x=(n,e,o)=>(o=n!=null?u(m(n)):{},a(e||!n||!n.__esModule?r(o,\"default\",{value:n,enumerable:!0}):o,n)),q=n=>a(r({},\"__esModule\",{value:!0}),n);var d=f((y,i)=>{i.exports=_jsx_runtime});var g={};j(g,{default:()=>_,frontmatter:()=>b});var t=x(d()),b={title:\"Deep Equal\",excerpt:\"Implement a function that determines if two values are equal\"};function l(n){let e=Object.assign({p:\"p\",code:\"code\",h2:\"h2\",pre:\"pre\"},n.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(e.p,{children:[\"Implement a function \",(0,t.jsx)(e.code,{children:\"deepEqual\"}),\" that performs a deep comparison between two values. It returns \",(0,t.jsx)(e.code,{children:\"true\"}),\" if two input values are deemed equal, and returns \",(0,t.jsx)(e.code,{children:\"false\"}),\" if not.\"]}),`\n`,(0,t.jsx)(e.h2,{children:\"Examples\"}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-js\",children:`const v1 = 'foo';\nconst v2 = 'foo';\n\ndeepEqual(v1, v2); // true\n\nconst v3 = { id: 1 };\nconst v4 = { id: 1 };\n\ndeepEqual(v3, v4); // true\n\nconst v5 = [1, 2, 3];\nconst v6 = [1, 2, 3];\n\ndeepEqual(v5, v6); // true\n\nconst v7 = [{ id: '1' }];\nconst v8 = [{ id: '2' }];\n\ndeepEqual(v7, v8); // false\n`})}),`\n`,(0,t.jsxs)(e.p,{children:[\"It needs to support primitive values, plain objects and arrays. For functions and other built-in objects such as \",(0,t.jsx)(e.code,{children:\"Map\"}),\" or \",(0,t.jsx)(e.code,{children:\"Set\"}),\", it should simply check for the references/identities i.e. strict equality. You don't need to handle cyclic objects, i.e. objects with circular references.\"]})]})}function E(n={}){let{wrapper:e}=n.components||{};return e?(0,t.jsx)(e,Object.assign({},n,{children:(0,t.jsx)(l,n)})):l(n)}var _=E;return q(g);})();\n;return Component;",
  "format": "javascript",
  "metadata": {
    "author": "zhenghao",
    "companies": [],
    "created": 1659916800,
    "difficulty": "medium",
    "duration": 25,
    "excerpt": "Implement a function that determines if two values are equal",
    "featured": false,
    "format": "javascript",
    "frameworkDefault": null,
    "frameworks": [],
    "href": "/questions/javascript/deep-equal",
    "importance": "mid",
    "languages": [
      "js"
    ],
    "nextQuestions": [],
    "premium": true,
    "published": true,
    "ranking": 100,
    "similarQuestions": [
      "deep-clone",
      "deep-clone-ii"
    ],
    "slug": "deep-equal",
    "title": "Deep Equal"
  },
  "skeleton": "/**\n * @param {*} valueA\n * @param {*} valueB\n * @return {boolean}\n */\nexport default function deepEqual(valueA, valueB) {\n  throw 'Not implemented!';\n}",
  "solution": "var Component=(()=>{var u=Object.create;var a=Object.defineProperty;var y=Object.getOwnPropertyDescriptor;var b=Object.getOwnPropertyNames;var f=Object.getPrototypeOf,m=Object.prototype.hasOwnProperty;var v=(o,e)=>()=>(e||o((e={exports:{}}).exports,e),e.exports),j=(o,e)=>{for(var n in e)a(o,n,{get:e[n],enumerable:!0})},c=(o,e,n,i)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let r of b(e))!m.call(o,r)&&r!==n&&a(o,r,{get:()=>e[r],enumerable:!(i=y(e,r))||i.enumerable});return o};var w=(o,e,n)=>(n=o!=null?u(f(o)):{},c(e||!o||!o.__esModule?a(n,\"default\",{value:o,enumerable:!0}):n,o)),g=o=>c(a({},\"__esModule\",{value:!0}),o);var l=v((D,s)=>{s.exports=_jsx_runtime});var x={};j(x,{default:()=>T});var t=w(l());var d=MDXCodeBlock;var h=`function shouldDeepCompare(type) {\n  return type === '[object Object]' || type === '[object Array]';\n}\n\nfunction getType(value) {\n  return Object.prototype.toString.call(value);\n}\n\n/**\n * @param {*} valueA\n * @param {*} valueB\n * @return {boolean}\n */\nexport default function deepEqual(valueA, valueB) {\n  const type1 = getType(valueA);\n  const type2 = getType(valueB);\n\n  if (type1 === type2 && shouldDeepCompare(type1) && shouldDeepCompare(type2)) {\n    const kvPairs1 = Object.entries(valueA);\n    const kvPairs2 = Object.entries(valueB);\n\n    if (kvPairs1.length !== kvPairs2.length) {\n      return false;\n    }\n\n    return kvPairs1.every(\n      // Make sure the other objects have the same properties defined.\n      ([k, v]) => Object.hasOwn(valueB, k) && deepEqual(v, valueB[k]),\n    );\n  }\n\n  return Object.is(valueA, valueB);\n}\n`;function p(o){let e=Object.assign({h2:\"h2\",p:\"p\",code:\"code\",ol:\"ol\",li:\"li\",a:\"a\",em:\"em\",pre:\"pre\",ul:\"ul\"},o.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"Value comparison in JavaScript can be deceptively simple. Normally a triple equal \",(0,t.jsx)(e.code,{children:\"===\"}),', i.e. strict equality, can do the job: for primitive values, it compares the actual values; for objects, it compares their identities/references, instead of their \"contents\". For example, ',(0,t.jsx)(e.code,{children:\"const a = {id: 1}; const b = {id:1}\"}),\" are considered different objects by \",(0,t.jsx)(e.code,{children:\"===\"}),\" even if they contain the exactly same \",(0,t.jsx)(e.code,{children:\"id\"}),\" property. Most of the time this is what you'd want. For this question though, we are going to implement a function that can deeply compare objects. Therefore we can't solely rely on \",(0,t.jsx)(e.code,{children:\"===\"}),\" for comparison.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"Outside its reference-checking nature, strict equality \",(0,t.jsx)(e.code,{children:\"===\"}),\" does have a few edge cases that it can't cover:\"]}),`\n`,(0,t.jsxs)(e.ol,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"Two \",(0,t.jsx)(e.code,{children:\"NaN\"}),\" values are considered different \",(0,t.jsx)(e.code,{children:\"NaN === NaN // false\"}),\".\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Number values \",(0,t.jsx)(e.code,{children:\"-0 \"}),\"and \",(0,t.jsx)(e.code,{children:\"+0\"}),\" are considered as equal.\"]}),`\n`]}),`\n`,(0,t.jsxs)(e.p,{children:[\"A better choice here is to use \",(0,t.jsx)(e.code,{children:\"Object.is\"}),\". This is also what React uses during its reconciliation phase to detect props change for a given component. Check out \",(0,t.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\",children:\"this MDN page\"}),\" if you want to learn more about it and see how it differs from \",(0,t.jsx)(e.code,{children:\"===\"}),\".\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"Let's move to discuss the hard part of the question about deep-comparing objects and arrays. First we need to know how to detect their data types. The \",(0,t.jsx)(e.code,{children:\"typeof\"}),\" operator is probably the first solution that came to mind but it is not enough for our use case here. First of all, when passed with \",(0,t.jsx)(e.code,{children:\"null\"}),\" it wrongly outputs \",(0,t.jsx)(e.code,{children:\"object\"}),\" . More importantly, it doesn't distinguish other built-in objects such as \",(0,t.jsx)(e.code,{children:\"Date\"}),\" and \",(0,t.jsx)(e.code,{children:\"Regex\"}),\" from plain objects and array. That is, it outputs \",(0,t.jsx)(e.code,{children:\"object\"}),\" for all of the built-in objects (except for functions). This is not ok because we can only sensibly traverse and deep-compare objects and arrays, and everything else should be compared by references via \",(0,t.jsx)(e.code,{children:\"Object.is\"}),\".\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"To get around this, you can combine the \",(0,t.jsx)(e.code,{children:\"instanceof\"}),\" operator to check for the constructor of a given object. But an easier and cleaner way to detect data types is to use \",(0,t.jsx)(e.code,{children:\"Object.prototype.toString\"}),\". Check out \",(0,t.jsx)(e.a,{href:\"https://www.zhenghao.io/posts/js-data-type\",children:\"my article\"}),\" if you want to dive deep on this topic.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"Now I have a utility function \",(0,t.jsx)(e.code,{children:\"shouldDeepCompare\"}),\" that will tell us whether we should traverse down the current property of the input object based on the data type retrieved by \",(0,t.jsx)(e.code,{children:\"getType\"}),\". When the current property is \",(0,t.jsx)(e.em,{children:\"not\"}),\" an object or an array, we can proceed to compare their types and values via \",(0,t.jsx)(e.code,{children:\"Object.is\"}),\".\"]}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-js\",children:`function shouldDeepCompare(type) {\n  return type === '[object Object]' || type === '[object Array]';\n}\n\nfunction getType(value) {\n  return Object.prototype.toString.call(value);\n}\n\nexport default function deepEqual(value1, value2) {\n  const type1 = getType(value1);\n  const type2 = getType(value2);\n\n  if (type1 === type2 && shouldDeepCompare(type1) && shouldDeepCompare(type2)) {\n    // When both props are objects or arrays, we traverse into them by calling \\`isEqual\\` again.\n  }\n\n  return Object.is(value1, value2);\n}\n`})}),`\n`,(0,t.jsxs)(e.p,{children:[\"Now let's work on the case where both input values are objects or arrays. Because we need to traverse down any objects/arrays we found in the input. If it is an array, we can just loop through the items. However if it is an object, we either use \",(0,t.jsx)(e.code,{children:\"for...in\"}),\" statement to loop through all the keys (own keys \",(0,t.jsx)(e.em,{children:\"and\"}),\" inherited keys), or we can convert its own enumerable, non-symbol-keyed properties into an array of key-value pairs with \",(0,t.jsx)(e.code,{children:\"Object.entries\"}),\" and then we can loop through that array instead. The benefits with the second approach are:\"]}),`\n`,(0,t.jsxs)(e.ol,{children:[`\n`,(0,t.jsxs)(e.li,{children:[`\n`,(0,t.jsx)(e.p,{children:\"We only get its own properties, as opposed to inherited ones.\"}),`\n`]}),`\n`,(0,t.jsxs)(e.li,{children:[`\n`,(0,t.jsx)(e.p,{children:\"We can bail out of comparison if the lengths of two arrays are different. That is, two objects/arrays have different numbers of properties/items.\"}),`\n`]}),`\n`]}),`\n`,(0,t.jsx)(e.p,{children:\"Here is the complete solution\"}),`\n`,(0,t.jsx)(d,{children:h}),`\n`,(0,t.jsx)(e.h2,{children:\"Edge Cases\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:\"Cyclic objects, i.e. objects with circular references are not handled.\"}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptors\",children:\"Property descriptors\"}),\" are not taken into account when comparing properties.\"]}),`\n`,(0,t.jsx)(e.li,{children:\"Non-enumerable properties and symbol-keyed properties are not compared.\"}),`\n`]})]})}function O(o={}){let{wrapper:e}=o.components||{};return e?(0,t.jsx)(e,Object.assign({},o,{children:(0,t.jsx)(p,o)})):p(o)}var T=O;return g(x);})();\n;return Component;",
  "tests": "import deepEqual from './deep-equal';\n\n/* eslint-disable no-undef */\ndescribe('deepEqual', () => {\n  test('primitive values', () => {\n    expect(deepEqual(0, 0)).toEqual(true);\n    expect(deepEqual(-0, +0)).toEqual(false);\n    expect(deepEqual('foo', 'foo')).toEqual(true);\n    expect(deepEqual(true, 1)).toEqual(false);\n    expect(deepEqual(true, true)).toEqual(true);\n    expect(deepEqual(false, false)).toEqual(true);\n    expect(deepEqual(undefined, null)).toEqual(false);\n    expect(deepEqual(null, null)).toEqual(true);\n    expect(deepEqual(undefined, undefined)).toEqual(true);\n    expect(deepEqual(NaN, NaN)).toEqual(true);\n  });\n\n  describe('arrays', () => {\n    test('empty', () => {\n      expect(deepEqual([], [])).toEqual(true);\n      expect(deepEqual({}, [])).toEqual(false);\n    });\n\n    test('number and strings', () => {\n      expect(deepEqual([1], [1])).toEqual(true);\n      expect(deepEqual(['1'], ['1'])).toEqual(true);\n      expect(deepEqual([1], ['1'])).toEqual(false);\n      expect(deepEqual([1, 2], [1, 2])).toEqual(true);\n      expect(deepEqual([1, 2, 3], [1, 2, 3])).toEqual(true);\n    });\n\n    test('boolean', () => {\n      expect(deepEqual([true], [true])).toEqual(true);\n      expect(deepEqual([false], [false])).toEqual(true);\n      expect(deepEqual([true], [false])).toEqual(false);\n    });\n\n    test('null-ish', () => {\n      expect(deepEqual([null], [null])).toEqual(true);\n      expect(deepEqual([undefined], [undefined])).toEqual(true);\n      expect(deepEqual([null], [undefined])).toEqual(false);\n    });\n\n    test('NaN', () => {\n      expect(deepEqual([NaN], [NaN])).toEqual(true);\n    });\n  });\n\n  describe('objects', () => {\n    test('empty', () => {\n      expect(deepEqual({}, {})).toEqual(true);\n    });\n\n    test('basic', () => {\n      expect(deepEqual({}, {})).toEqual(true);\n\n      expect(deepEqual({ foo: 'bar', id: 1 }, { foo: 'bar', id: 1 })).toEqual(\n        true,\n      );\n      expect(deepEqual({ foo: 'bar', id: 1 }, { foo: 'bar', id: '1' })).toEqual(\n        false,\n      );\n    });\n\n    test('array', () => {\n      expect(\n        deepEqual(\n          { foo: 'bar', item: [1, 2, { baz: 'baz' }] },\n          { foo: 'bar', item: [1, 2, { baz: 'baz' }] },\n        ),\n      ).toEqual(true);\n    });\n\n    test('subset objects', () => {\n      expect(\n        deepEqual(\n          { foo: 'bar', item: [1, 2, { baz: 'baz' }] },\n          { foo: 'bar', item: [1, 2, { baz: 'baz' }], id: 1 },\n        ),\n      ).toEqual(false);\n    });\n\n    test('null-ish', () => {\n      expect(\n        deepEqual({ foo: undefined, baz: 'baz' }, { bar: 'bar', baz: 'baz' }),\n      ).toEqual(false);\n\n      expect(\n        deepEqual({ foo: undefined, baz: 'baz' }, { foo: null, baz: 'baz' }),\n      ).toEqual(false);\n\n      expect(\n        deepEqual(\n          { foo: undefined, bar: 'baz' },\n          { foo: undefined, bar: 'baz' },\n        ),\n      ).toEqual(true);\n\n      expect(\n        deepEqual({ foo: null, bar: 'baz' }, { foo: null, bar: 'baz' }),\n      ).toEqual(true);\n    });\n\n    test('NaN', () => {\n      expect(deepEqual({ foo: NaN }, { foo: NaN })).toEqual(true);\n      expect(deepEqual({ foo: NaN }, { foo: null })).toEqual(false);\n    });\n  });\n});"
}