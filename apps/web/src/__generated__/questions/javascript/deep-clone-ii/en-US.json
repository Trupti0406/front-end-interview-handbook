{
  "description": "var Component=(()=>{var h=Object.create;var l=Object.defineProperty;var p=Object.getOwnPropertyDescriptor;var u=Object.getOwnPropertyNames;var b=Object.getPrototypeOf,f=Object.prototype.hasOwnProperty;var j=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),m=(n,e)=>{for(var o in e)l(n,o,{get:e[o],enumerable:!0})},i=(n,e,o,r)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let a of u(e))!f.call(n,a)&&a!==o&&l(n,a,{get:()=>e[a],enumerable:!(r=p(e,a))||r.enumerable});return n};var g=(n,e,o)=>(o=n!=null?h(b(n)):{},i(e||!n||!n.__esModule?l(o,\"default\",{value:n,enumerable:!0}):o,n)),y=n=>i(l({},\"__esModule\",{value:!0}),n);var s=j((O,c)=>{c.exports=_jsx_runtime});var C={};m(C,{default:()=>w,frontmatter:()=>x});var t=g(s()),x={title:\"Deep Clone II\",excerpt:\"Implement a function that performs a deep copy of a value, but also handles circular references\"};function d(n){let e=Object.assign({p:\"p\",strong:\"strong\",a:\"a\",code:\"code\",ul:\"ul\",li:\"li\",h2:\"h2\",pre:\"pre\"},n.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:\"Note:\"}),\" This is an advanced version of the \",(0,t.jsx)(e.a,{href:\"/questions/javascript/deep-clone\",children:\"Deep Clone\"}),\" question, you should complete that first before attempting this question.\"]}),`\n`,(0,t.jsx)(e.p,{children:`The term \"deep clone\" is not formally defined in JavaScript's language spec, but is generally well understood in the community. It is usually defined as starting at the top-level entries of the value/object and traversing the object to make copies of all the properties in the object, thus leading to a completely new object that has no references pointing back to the properties in the original object. Any changes made to the deeply-copied object will not affect the original object.`}),`\n`,(0,t.jsxs)(e.p,{children:[\"Implement a \",(0,t.jsx)(e.code,{children:\"deepClone\"}),\" function that performs deep clone as thorough as possible, taking note of the following:\"]}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:\"The input object can contain any data types.\"}),`\n`,(0,t.jsx)(e.li,{children:\"Cover the edge case where the input object is cyclic, i.e. the circular references should also be cloned.\"}),`\n`]}),`\n`,(0,t.jsx)(e.h2,{children:\"Examples\"}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-js\",children:`const obj1 = {\n  num: 0,\n  str: '',\n  boolean: true,\n  unf: undefined,\n  nul: null,\n  obj: { name: 'foo', id: 1 },\n  arr: [0, 1, 2],\n  date: new Date(),\n  reg: new RegExp('/bar/ig'),\n  [Symbol('s')]: 'baz',\n};\n\nconst clonedObj1 = deepClone(obj1);\nclonedObj1.arr.push(3);\nobj1.arr; // Should still be [0, 1, 2]\n\nconst obj2 = { a: {} };\nobj2.a.b = obj2; // Circular reference\n\nconst clonedObj2 = deepClone(obj2); // Should not cause a stack overflow by recursing into an infinite loop.\n\nclonedObj2.a.b = 'something new';\n\nobj2.a.b === obj2; // This should still be true\n`})})]})}function v(n={}){let{wrapper:e}=n.components||{};return e?(0,t.jsx)(e,Object.assign({},n,{children:(0,t.jsx)(d,n)})):d(n)}var w=v;return y(C);})();\n;return Component;",
  "format": "javascript",
  "metadata": {
    "author": "zhenghao",
    "companies": [],
    "created": 1653177600,
    "difficulty": "hard",
    "duration": 40,
    "excerpt": "Implement a function that performs a deep copy of a value, but also handles circular references",
    "featured": false,
    "format": "javascript",
    "frameworkDefault": null,
    "frameworks": [],
    "href": "/questions/javascript/deep-clone-ii",
    "importance": "mid",
    "languages": [
      "js"
    ],
    "nextQuestions": [],
    "premium": true,
    "published": true,
    "ranking": 100,
    "similarQuestions": [
      "deep-clone"
    ],
    "slug": "deep-clone-ii",
    "title": "Deep Clone II"
  },
  "skeleton": "/**\n * @param {*} value\n * @return {*}\n */\nexport default function deepClone(value) {\n  throw 'Not implemented!';\n}",
  "solution": "var Component=(()=>{var u=Object.create;var c=Object.defineProperty;var y=Object.getOwnPropertyDescriptor;var v=Object.getOwnPropertyNames;var f=Object.getPrototypeOf,m=Object.prototype.hasOwnProperty;var g=(o,e)=>()=>(e||o((e={exports:{}}).exports,e),e.exports),b=(o,e)=>{for(var n in e)c(o,n,{get:e[n],enumerable:!0})},a=(o,e,n,i)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let r of v(e))!m.call(o,r)&&r!==n&&c(o,r,{get:()=>e[r],enumerable:!(i=y(e,r))||i.enumerable});return o};var w=(o,e,n)=>(n=o!=null?u(f(o)):{},a(e||!o||!o.__esModule?c(n,\"default\",{value:o,enumerable:!0}):n,o)),j=o=>a(c({},\"__esModule\",{value:!0}),o);var s=g((T,l)=>{l.exports=_jsx_runtime});var x={};b(x,{default:()=>C});var t=w(s());var d=MDXCodeBlock;var h=`const isPrimitiveTypeOrFunction = (value) =>\n  typeof value !== 'object' || typeof value === 'function' || value === null;\n\nfunction getType(value) {\n  const lowerCaseTheFirstLetter = (str) => str[0].toLowerCase() + str.slice(1);\n  const type = typeof value;\n  if (type !== 'object') return type;\n\n  return lowerCaseTheFirstLetter(\n    Object.prototype.toString.call(value).replace(/^\\\\[object (\\\\S+)\\\\]$/, '$1'),\n  );\n}\n\n/**\n * @param {*} value\n * @return {*}\n */\nexport default function deepClone(value, cache = new Map()) {\n  if (isPrimitiveTypeOrFunction(value)) {\n    return value;\n  }\n\n  const type = getType(value);\n\n  if (type === 'set') {\n    const cloned = new Set();\n    value.forEach((item) => {\n      cloned.add(deepClone(item));\n    });\n    return cloned;\n  }\n\n  if (type === 'map') {\n    const cloned = new Map();\n    value.forEach((value, key) => {\n      cloned.set(key, deepClone(value));\n    });\n    return cloned;\n  }\n\n  if (type === 'function') {\n    return value;\n  }\n\n  if (type === 'array') {\n    return value.map((item) => deepClone(item));\n  }\n\n  if (type === 'date') {\n    return new Date(value);\n  }\n\n  if (type === 'regExp') {\n    return new RegExp(value);\n  }\n\n  if (cache.has(value)) {\n    return cache.get(value);\n  }\n\n  const cloned = Object.create(Object.getPrototypeOf(value));\n\n  cache.set(value, cloned);\n  for (const key of Reflect.ownKeys(value)) {\n    cloned[key] = isPrimitiveTypeOrFunction(value[key])\n      ? value[key]\n      : deepClone(value[key], cache);\n  }\n\n  return cloned;\n}\n`;function p(o){let e=Object.assign({p:\"p\",code:\"code\",h2:\"h2\",a:\"a\",em:\"em\",ul:\"ul\",li:\"li\",pre:\"pre\"},o.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.p,{children:\"This is a follow-up question based on Deep Clone I, with much more depth and obscure corners of the JavaScript language covered.\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"It is not realistic to expect anyone to come up with a complete deep clone solution in typical interview settings. However, this question serves a good tool to test your knowledge on checking various data types, object properties, leverage various built-in APIs and \",(0,t.jsx)(e.code,{children:\"Object\"}),\" methods to traverse a given object and various edge cases you might only encounter when writing library code.\"]}),`\n`,(0,t.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"Before we go about writing out the deep clone function, we need a way to identify the data type of a given JavaScript value. It is ok to go with \",(0,t.jsx)(e.code,{children:\"typeof\"}),\" and \",(0,t.jsx)(e.code,{children:\"instanceof\"}),\" but you have to be aware of their limitations. In this solution, I choose to leverage \",(0,t.jsx)(e.code,{children:\"Object.prototype.toString\"}),\". Check out my post \",(0,t.jsx)(e.a,{href:\"https://www.zhenghao.io/posts/js-data-type\",children:(0,t.jsx)(e.em,{children:\"A Complete Guide To Check Data Types In JavaScript\"})}),\" if you like to understand how this works exactly.\"]}),`\n`,(0,t.jsx)(e.p,{children:\"Since we want to implement it as thoroughly as possible, here are a few things to consider:\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"Our \",(0,t.jsx)(e.code,{children:\"deepClone\"}),\" should work with objects that have symbol-keyed properties. That is, symbol-keyed properties are also copied. On top of that, non-enumerable properties should also be copied. Either the \",(0,t.jsx)(e.code,{children:\"for...in\"}),\" statement or the \",(0,t.jsx)(e.code,{children:\"Object.entries\"}),\"/\",(0,t.jsx)(e.code,{children:\"Object.keys\"}),\" reveals them. We need to leverage a lesser-known API called \",(0,t.jsx)(e.code,{children:\"Reflect.ownKeys\"}),\". Check out \",(0,t.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect/ownKeys\",children:\"this MDN page\"}),\" to learn more about it.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"The input object's property descriptors should also be copied. For that, we can use the method \",(0,t.jsx)(e.code,{children:\"Object.getOwnPropertyDescriptors\"}),\".\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"The input object's prototype should not be lost after the copying. We can use \",(0,t.jsx)(e.code,{children:\"getPrototypeOf\"}),\" to get the reference to the prototype of a given object.\"]}),`\n`,(0,t.jsx)(e.li,{children:\"We should account for circular references in the input object and avoid crashing the program. We can achieve this by having a cache to store visited properties.\"}),`\n`]}),`\n`,(0,t.jsx)(d,{children:h}),`\n`,(0,t.jsx)(e.h2,{children:\"One-liner Solution\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"As of this writing, all major browsers have native support for performing deep clone via the \",(0,t.jsx)(e.code,{children:\"structuredClone\"}),\" API. Check out \",(0,t.jsx)(e.a,{href:\"https://web.dev/structured-clone/\",children:\"this article\"}),\" if you want to learn more about this API.\"]}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-js\",children:`const clonedObj = structuredClone(obj);\n`})}),`\n`,(0,t.jsx)(e.h2,{children:\"Edge Cases\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptors\",children:\"Property descriptors\"}),\" are not copied.\"]}),`\n`]})]})}function k(o={}){let{wrapper:e}=o.components||{};return e?(0,t.jsx)(e,Object.assign({},o,{children:(0,t.jsx)(p,o)})):p(o)}var C=k;return j(x);})();\n;return Component;",
  "tests": "import deepClone from './deep-clone-ii';\n\n/* eslint-disable no-undef */\n\n// TODO: Change tests to test for non-serializable properties in Jest.\ndescribe('deepClone', () => {\n  it('single primitive value', () => {\n    expect(deepClone(123)).toStrictEqual(123);\n    expect(deepClone('foo')).toStrictEqual('foo');\n    expect(deepClone(true)).toStrictEqual(true);\n    expect(deepClone(null)).toStrictEqual(null);\n  });\n\n  it('object with no nesting', () => {\n    const obj = { role: 'foo' };\n    const clonedObj = deepClone(obj);\n    expect(clonedObj).toStrictEqual({ role: 'foo' });\n    clonedObj.role = 'bar';\n    expect(obj).toStrictEqual({ role: 'foo' });\n    expect(clonedObj).toStrictEqual({ role: 'bar' });\n  });\n\n  it('object with no nesting and symbol-key prop', () => {\n    const symbol = Symbol('bar');\n    const obj = { role: 'foo', [symbol]: 'bar' };\n    const clonedObj = deepClone(obj);\n    expect(clonedObj).toMatchObject({ role: 'foo', [symbol]: 'bar' });\n    clonedObj.role = 'bar';\n    expect(obj).toMatchObject({ role: 'foo', [symbol]: 'bar' });\n  });\n\n  it('object with one-level nesting', () => {\n    const symbol = Symbol('s');\n    const date = new Date();\n    const obj = {\n      num: 0,\n      str: '',\n      boolean: true,\n      unf: undefined,\n      nul: null,\n      obj: { name: 'foo', id: 1 },\n      arr: [0, 1, 2],\n      date,\n      reg: new RegExp('/bar/ig'),\n      [symbol]: 'baz',\n    };\n    const clonedObj = deepClone(obj);\n    expect(clonedObj).toMatchObject({\n      num: 0,\n      str: '',\n      boolean: true,\n      unf: undefined,\n      nul: null,\n      obj: { name: 'foo', id: 1 },\n      arr: [0, 1, 2],\n      date,\n      reg: /\\/bar\\/ig/,\n      [symbol]: 'baz',\n    });\n    clonedObj.name = 'bar';\n    clonedObj.arr.pop();\n\n    expect(obj).toMatchObject({\n      num: 0,\n      str: '',\n      boolean: true,\n      unf: undefined,\n      nul: null,\n      obj: { name: 'foo', id: 1 },\n      arr: [0, 1, 2],\n      date,\n      reg: /\\/bar\\/ig/,\n      [symbol]: 'baz',\n    });\n  });\n\n  it('object with circular references are handled correctly', () => {\n    const obj = { a: {} };\n    obj.a.b = obj;\n    const clonedObj = deepClone(obj);\n    clonedObj.a.b = 'something new';\n    expect(obj.a.b).toMatchObject(obj);\n  });\n\n  it('object prototype is also copied', () => {\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    const Foo = function () {};\n    let foo = new Foo();\n    const cloned = deepClone(foo);\n\n    expect(Object.getPrototypeOf(cloned)).toMatchObject(\n      Object.getPrototypeOf(foo),\n    );\n  });\n});"
}