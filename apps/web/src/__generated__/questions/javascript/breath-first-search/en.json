{
  "description": "var Component=(()=>{var c=Object.create;var i=Object.defineProperty;var p=Object.getOwnPropertyDescriptor;var u=Object.getOwnPropertyNames;var g=Object.getPrototypeOf,f=Object.prototype.hasOwnProperty;var m=(t,n)=>()=>(n||t((n={exports:{}}).exports,n),n.exports),F=(t,n)=>{for(var r in n)i(t,r,{get:n[r],enumerable:!0})},h=(t,n,r,o)=>{if(n&&typeof n==\"object\"||typeof n==\"function\")for(let a of u(n))!f.call(t,a)&&a!==r&&i(t,a,{get:()=>n[a],enumerable:!(o=p(n,a))||o.enumerable});return t};var B=(t,n,r)=>(r=t!=null?c(g(t)):{},h(n||!t||!t.__esModule?i(r,\"default\",{value:t,enumerable:!0}):r,t)),v=t=>h(i({},\"__esModule\",{value:!0}),t);var d=m((S,s)=>{s.exports=_jsx_runtime});var x={};F(x,{default:()=>D,frontmatter:()=>E});var e=B(d()),E={title:\"Breadth-First Search\",excerpt:\"Implement a breadth-first search algorithm that traverses a directed graph in a breadth-first manner.\"};function l(t){let n=Object.assign({p:\"p\",h2:\"h2\",pre:\"pre\",code:\"code\",ol:\"ol\",li:\"li\"},t.components);return(0,e.jsxs)(e.Fragment,{children:[(0,e.jsx)(n.p,{children:\"Write a function that implements the breadth-first search (BFS) algorithm on a directed graph (in adjacency list format), given a starting node.\"}),`\n`,(0,e.jsx)(n.p,{children:\"BFS is an algorithm used for traversing a graph or a tree, starting from the root node and exploring all the neighbors at the current depth before moving on to nodes at the next depth level. The output from BFS is an array of the graph's nodes in the order they were traversed.\"}),`\n`,(0,e.jsx)(n.h2,{children:\"Examples\"}),`\n`,(0,e.jsx)(n.pre,{children:(0,e.jsx)(n.code,{className:\"language-js\",children:`const graph1 = {\n  A: ['B', 'C', 'D'],\n  B: ['E', 'F'],\n  C: ['G', 'H'],\n  D: ['I', 'J'],\n  E: ['D'],\n  F: [],\n  G: [],\n  H: [],\n  I: [],\n  J: [],\n};\n\nbreadthFirstSearch(graph1, 'A'); // ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J']\n\n        A\n      / | \\\\\n     B  C  D\n   / |   |   | \\\\\n  E  F   G   H  I\n         |\n         J\n\nbreadthFirstSearch(graph1, 'B'); // ['B', 'E', 'F', 'D', 'G', 'H', 'I', 'J', 'C']\n\n    B\n  / | \\\\\n E  F  A\n       | \\\\\n       C  D\n      /|   | \\\\\n     G H   I  J\n\n\nconst graph2 = {\n  'A': ['B', 'C'],\n  'B': ['D', 'E'],\n  'C': ['F', 'G'],\n  'D': [],\n  'E': [],\n  'F': [],\n  'G': [],\n};\n\nbreadthFirstSearch(graph2, 'A')); // ['A', 'B', 'C', 'D', 'E', 'F', 'G']\n\n       A\n     /   \\\\\n    B     C\n  /  \\\\   /   \\\\\n D   E  F    G\n\nbreadthFirstSearch(graph2, 'E')); // ['E']\n\n  E\n  |\n  B\n / \\\\\nD   A\n    / \\\\\n   C   F\n        \\\\\n         G\n\n`})}),`\n`,(0,e.jsx)(n.h2,{children:\"Recap (Hint)\"}),`\n`,(0,e.jsx)(n.p,{children:\"Breadth-first search (BFS) is an algorithm used for traversing a graph or a tree. The output is an array of the graph's nodes in the order of traversal. Here is an overview of how BFS works to traverse a graph, using the standard implementation that takes in an adjacency list (we use an array instead) and the root node:\"}),`\n`,(0,e.jsxs)(n.ol,{children:[`\n`,(0,e.jsx)(n.li,{children:\"Initialize a queue to store nodes to be visited. Push root node.\"}),`\n`,(0,e.jsx)(n.li,{children:\"Initialize a set to track visited nodes.\"}),`\n`,(0,e.jsxs)(n.li,{children:[\"Enter a loop that continues until the queue is empty. In each iteration of the loop:\",`\n`,(0,e.jsxs)(n.ol,{children:[`\n`,(0,e.jsx)(n.li,{children:\"Pop the top node from the queue and mark it as visited.\"}),`\n`,(0,e.jsx)(n.li,{children:\"Retrieve the neighbors of the node from the input graph.\"}),`\n`,(0,e.jsx)(n.li,{children:\"Enqueue the neighbors of the current node.\"}),`\n`]}),`\n`]}),`\n`,(0,e.jsx)(n.li,{children:\"Return the set of visited nodes.\"}),`\n`]}),`\n`,(0,e.jsx)(n.p,{children:\"BFS is useful for the same purposes as DFS, and it is especially useful for finding the shortest path between two nodes.\"})]})}function b(t={}){let{wrapper:n}=t.components||{};return n?(0,e.jsx)(n,Object.assign({},t,{children:(0,e.jsx)(l,t)})):l(t)}var D=b;return v(x);})();\n;return Component;",
  "format": "javascript",
  "metadata": {
    "author": null,
    "companies": [],
    "created": 1679788800,
    "difficulty": "medium",
    "duration": 15,
    "excerpt": "Implement a breadth-first search algorithm that traverses a directed graph in a breadth-first manner.",
    "featured": false,
    "format": "javascript",
    "frameworkDefault": null,
    "frameworks": [],
    "href": "/questions/javascript/breadth-first-search",
    "importance": "low",
    "languages": ["js"],
    "nextQuestions": [],
    "premium": false,
    "published": true,
    "ranking": 100,
    "similarQuestions": ["depth-first-search"],
    "slug": "breadth-first-search",
    "title": "Breadth-First Search"
  },
  "skeleton": "/**\n * @param {Object} graph Node to array of neighboring nodes as adjacent list.\n * @param {string} source Source node to start traversal from. It has to exist as a node in the graph.\n * @return {Array<string>} A BFS-traversed order of nodes.\n */\nexport default function breadthFirstSearch(graph, source) {\n  throw 'Not implemented!';\n}",
  "solution": "var Component=(()=>{var f=Object.create;var o=Object.defineProperty;var v=Object.getOwnPropertyDescriptor;var g=Object.getOwnPropertyNames;var m=Object.getPrototypeOf,b=Object.prototype.hasOwnProperty;var y=(r,e)=>()=>(e||r((e={exports:{}}).exports,e),e.exports),w=(r,e)=>{for(var n in e)o(r,n,{get:e[n],enumerable:!0})},h=(r,e,n,s)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let i of g(e))!b.call(r,i)&&i!==n&&o(r,i,{get:()=>e[i],enumerable:!(s=v(e,i))||s.enumerable});return r};var q=(r,e,n)=>(n=r!=null?f(m(r)):{},h(e||!r||!r.__esModule?o(n,\"default\",{value:r,enumerable:!0}):n,r)),j=r=>h(o({},\"__esModule\",{value:!0}),r);var u=y((O,d)=>{d.exports=_jsx_runtime});var F={};w(F,{default:()=>C});var t=q(u());var a=MDXCodeBlock;var c=`/**\n * @param {Object} graph Node to array of neighboring nodes.\n * @param {string=} source Source node to start traversal from. Has to be a valid node if graph is non-empty.\n * @return {string[]} A BFS-traversed order of nodes.\n */\nexport default function breadthFirstSearch(graph, source) {\n  // If there are no nodes in the graph, just return an empty array\n  if (Object.keys(graph).length === 0) {\n    return [];\n  }\n\n  // Create a queue to store the nodes to be visited.\n  // Add the root node since we're doing a level-order BFS.\n  const queue = [source];\n\n  // Initialize a set that tracks visited nodes.\n  const visited = new Set();\n\n  // While there are nodes to visit\n  while (queue.length > 0) {\n    // Dequeue the node at the front of the queue\n    const node = queue.shift();\n\n    // Skip nodes that have already been visited\n    if (visited.has(node)) {\n      continue;\n    }\n\n    // Mark the node as visited\n    visited.add(node);\n\n    // Enqueue the neighbors of the current node\n    graph[node].forEach((neighbor) => {\n      queue.push(neighbor);\n    });\n  }\n\n  // The visited nodes is the traversal order.\n  return Array.from(visited);\n}\n`;var l=`/**\n * @param {Object} graph Node to array of neighboring nodes.\n * @param {string=} source Source node to start traversal from. Has to be a valid node if graph is non-empty.\n * @return {string[]} A BFS-traversed order of nodes.\n */\nexport default function breadthFirstSearch(graph, source) {\n  // If there are no nodes in the graph, just return an empty array\n  if (Object.keys(graph).length === 0) {\n    return [];\n  }\n\n  // Initialize a queue to keep track of nodes to visit.\n  const queue = [];\n  const visited = new Set();\n\n  // Add the source node to the queue and mark it as visited.\n  queue.push(source);\n  visited.add(source);\n\n  function traverse() {\n    // If the queue is empty, we have visited all nodes, so return the visited nodes.\n    if (queue.length === 0) {\n      return Array.from(visited);\n    }\n\n    // Get the next node to visit from the queue.\n    const node = queue.shift();\n\n    // Visit each neighbor that hasn't been visited before.\n    graph[node].forEach((neighbor) => {\n      if (!visited.has(neighbor)) {\n        visited.add(neighbor);\n        queue.push(neighbor);\n      }\n    });\n\n    // Recursively call traverse to visit the next node in the queue.\n    return traverse();\n  }\n\n  // Call traverse to start the traversal.\n  return traverse();\n}\n`;function p(r){let e=Object.assign({h2:\"h2\",p:\"p\",ul:\"ul\",li:\"li\"},r.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.h2,{children:\"Clarification Questions\"}),`\n`,(0,t.jsx)(e.p,{children:\"If unspecified:\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:\"Order of traversal: Should we use a standard pre-order traversal or other orders of traversal?\"}),`\n`,(0,t.jsx)(e.li,{children:\"Input format: What is the format of the input data? Can we assume the input will be an adjacency list in the form of a JavaScript Object where keys are nodes and values are child nodes?\"}),`\n`,(0,t.jsx)(e.li,{children:\"Output format: How should the output be formatted? Are there specific requirements or can we return an array with elements in the order of traversal?\"}),`\n`,(0,t.jsx)(e.li,{children:\"Disconnected graphs: Do we have to consider or handle the case for disconnected graphs where there are multiple subgraphs that are not connected to each other?\"}),`\n`]}),`\n`,(0,t.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,t.jsx)(e.p,{children:\"The solution implements the algorithm outlined in the description.\"}),`\n`,(0,t.jsx)(a,{children:c}),`\n`,(0,t.jsx)(e.p,{children:\"We can also perform BFS recursively, which is can be more intuitive in certain cases. The recursion call stack is an implicit stack to track which nodes to visit next.\"}),`\n`,(0,t.jsx)(a,{children:l}),`\n`,(0,t.jsx)(e.h2,{children:\"Edge Cases\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:\"Empty graphs: Return an empty array without crashing.\"}),`\n`,(0,t.jsx)(e.li,{children:\"Graphs with only one-two nodes: Traverse without crashing.\"}),`\n`,(0,t.jsx)(e.li,{children:\"Cyclic graphs: Make sure not to traverse visited nodes again.\"}),`\n`,(0,t.jsx)(e.li,{children:\"Disjoint graphs: Doesn't require special handling but good to be aware of.\"}),`\n`]})]})}function x(r={}){let{wrapper:e}=r.components||{};return e?(0,t.jsx)(e,Object.assign({},r,{children:(0,t.jsx)(p,r)})):p(r)}var C=x;return j(F);})();\n;return Component;",
  "tests": "import breadthFirstSearch from './breadth-first-search';\n\ndescribe('breadthFirstSearch', () => {\n  test('empty graph', () => {\n    expect(breadthFirstSearch({}, null)).toEqual([]);\n  });\n\n  test('graphs with one node', () => {\n    expect(breadthFirstSearch({ A: [] }, 'A')).toEqual(['A']);\n  });\n\n  test('graphs with two nodes', () => {\n    expect(breadthFirstSearch({ A: ['B'], B: [] }, 'A')).toEqual(['A', 'B']);\n    expect(breadthFirstSearch({ A: ['A', 'B'], B: [] }, 'A')).toEqual([\n      'A',\n      'B',\n    ]);\n    expect(breadthFirstSearch({ A: ['A', 'B'], B: [] }, 'B')).toEqual(['B']);\n    expect(breadthFirstSearch({ A: ['A', 'B'], B: ['A'] }, 'B')).toEqual([\n      'B',\n      'A',\n    ]);\n  });\n\n  test('graphs with multiple nodes', () => {\n    expect(breadthFirstSearch({ A: ['B'], B: ['C'], C: [] }, 'A')).toEqual([\n      'A',\n      'B',\n      'C',\n    ]);\n    expect(breadthFirstSearch({ A: ['B', 'C'], B: [], C: [] }, 'A')).toEqual([\n      'A',\n      'B',\n      'C',\n    ]);\n    expect(\n      breadthFirstSearch(\n        { A: ['B', 'C'], B: [], C: [], D: ['B'], E: ['C'] },\n        'A',\n      ),\n    ).toEqual(['A', 'B', 'C']);\n    expect(\n      breadthFirstSearch(\n        { A: ['D', 'E'], B: [], C: [], D: ['B'], E: ['C'] },\n        'A',\n      ),\n    ).toEqual(['A', 'D', 'E', 'B', 'C']);\n    expect(\n      breadthFirstSearch(\n        {\n          A: ['D', 'E'],\n          B: ['A', 'B', 'C', 'D', 'E'],\n          C: [],\n          D: ['B'],\n          E: ['C'],\n        },\n        'A',\n      ),\n    ).toEqual(['A', 'D', 'E', 'B', 'C']);\n    // Graph taken from https://www.geeksforgeeks.org/breadth-first-traversal-for-a-graph/\n    const graph = {\n      A: ['B', 'C'],\n      B: ['A', 'D', 'E'],\n      C: ['A', 'E'],\n      D: ['B', 'E', 'F'],\n      E: ['B', 'C', 'D', 'F'],\n      F: ['D', 'E'],\n    };\n    expect(breadthFirstSearch(graph, 'A')).toEqual([\n      'A',\n      'B',\n      'C',\n      'D',\n      'E',\n      'F',\n    ]);\n    expect(breadthFirstSearch(graph, 'B')).toEqual([\n      'B',\n      'A',\n      'D',\n      'E',\n      'C',\n      'F',\n    ]);\n    expect(breadthFirstSearch(graph, 'C')).toEqual([\n      'C',\n      'A',\n      'E',\n      'B',\n      'D',\n      'F',\n    ]);\n    expect(breadthFirstSearch(graph, 'D')).toEqual([\n      'D',\n      'B',\n      'E',\n      'F',\n      'A',\n      'C',\n    ]);\n  });\n\n  test('disjoint graphs', () => {\n    expect(\n      breadthFirstSearch({ A: ['B'], B: [], C: [], D: ['C'] }, 'A'),\n    ).toEqual(['A', 'B']);\n    expect(\n      breadthFirstSearch({ A: ['B'], B: [], C: [], D: ['C'] }, 'C'),\n    ).toEqual(['C']);\n    expect(\n      breadthFirstSearch({ A: ['B'], B: [], C: [], D: ['C'] }, 'D'),\n    ).toEqual(['D', 'C']);\n  });\n\n  test('cyclic graphs', () => {\n    expect(breadthFirstSearch({ A: ['A'] }, 'A')).toEqual(['A']);\n    expect(\n      breadthFirstSearch(\n        {\n          A: ['B', 'C', 'D'],\n          B: ['E', 'F'],\n          C: ['G', 'H'],\n          D: ['I', 'J'],\n          E: ['D'],\n          F: [],\n          G: [],\n          H: [],\n          I: [],\n          J: [],\n        },\n        'A',\n      ),\n    ).toEqual(['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J']);\n    expect(\n      breadthFirstSearch(\n        {\n          A: ['B', 'C', 'D'],\n          B: ['E', 'F'],\n          C: ['G', 'H'],\n          D: ['I', 'J'],\n          E: ['D'],\n          F: [],\n          G: [],\n          H: [],\n          I: [],\n          J: [],\n        },\n        'B',\n      ),\n    ).toEqual(['B', 'E', 'F', 'D', 'G', 'H', 'I', 'J']);\n    expect(\n      breadthFirstSearch(\n        {\n          A: ['B', 'C'],\n          B: ['D', 'E'],\n          C: ['F', 'G'],\n          D: [],\n          E: [],\n          F: [],\n          G: [],\n        },\n        'A',\n      ),\n    ).toEqual(['A', 'B', 'C', 'D', 'E', 'F', 'G']);\n    expect(\n      breadthFirstSearch(\n        {\n          A: ['B', 'C'],\n          B: ['D', 'E'],\n          C: ['F', 'G'],\n          D: [],\n          E: [],\n          F: [],\n          G: [],\n        },\n        'E',\n      ),\n    ).toEqual(['E']);\n  });\n});"
}
