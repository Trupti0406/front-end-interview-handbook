{
  "description": "var Component=(()=>{var d=Object.create;var o=Object.defineProperty;var m=Object.getOwnPropertyDescriptor;var h=Object.getOwnPropertyNames;var y=Object.getPrototypeOf,u=Object.prototype.hasOwnProperty;var f=(r,e)=>()=>(e||r((e={exports:{}}).exports,e),e.exports),g=(r,e)=>{for(var a in e)o(r,a,{get:e[a],enumerable:!0})},p=(r,e,a,c)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let n of h(e))!u.call(r,n)&&n!==a&&o(r,n,{get:()=>e[n],enumerable:!(c=m(e,n))||c.enumerable});return r};var x=(r,e,a)=>(a=r!=null?d(y(r)):{},p(e||!r||!r.__esModule?o(a,\"default\",{value:r,enumerable:!0}):a,r)),j=r=>p(o({},\"__esModule\",{value:!0}),r);var l=f((v,i)=>{i.exports=_jsx_runtime});var w={};g(w,{default:()=>_,frontmatter:()=>b});var t=x(l()),b={title:\"Array.prototype.map\",excerpt:\"Implement the Array.prototype.map() method\"};function s(r){let e=Object.assign({p:\"p\",code:\"code\",h2:\"h2\",pre:\"pre\",a:\"a\"},r.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.code,{children:\"Array.prototype.map\"}),\" creates a new array populated with the results of calling a provided function on every element in the calling array.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"Implement \",(0,t.jsx)(e.code,{children:\"Array.prototype.map\"}),\". To avoid overwriting the actual \",(0,t.jsx)(e.code,{children:\"Array.prototype.map\"}),\" which is being used by the autograder, we shall instead implement it as \",(0,t.jsx)(e.code,{children:\"Array.prototype.myMap\"}),\".\"]}),`\n`,(0,t.jsx)(e.h2,{children:\"Examples\"}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-js\",children:`[1, 2, 3, 4].myMap((i) => i); // [1, 2, 3, 4]\n[1, 2, 3, 4].myMap((i) => i * i); // [1, 4, 9, 16]\n`})}),`\n`,(0,t.jsx)(e.h2,{children:\"Notes\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"The map callback function takes in more than just the element! There's also a second parameter for \",(0,t.jsx)(e.code,{children:\"Array.prototype.map\"}),\" as well. You are recommended to read the specification for \",(0,t.jsx)(e.code,{children:\"Array.prototype.map\"}),\" on \",(0,t.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map\",children:\"MDN Docs\"}),\" before attempting.\"]})]})}function A(r={}){let{wrapper:e}=r.components||{};return e?(0,t.jsx)(e,Object.assign({},r,{children:(0,t.jsx)(s,r)})):s(r)}var _=A;return j(w);})();\n;return Component;",
  "format": "javascript",
  "metadata": {
    "author": null,
    "companies": [
      "amazon",
      "apple"
    ],
    "created": 1652918400,
    "difficulty": "easy",
    "duration": 15,
    "excerpt": "Implement the Array.prototype.map() method",
    "featured": false,
    "format": "javascript",
    "frameworkDefault": null,
    "frameworks": [],
    "href": "/questions/javascript/array-map",
    "importance": "mid",
    "languages": [
      "js",
      "ts"
    ],
    "nextQuestions": [
      "contact-form",
      "curry"
    ],
    "premium": true,
    "published": true,
    "ranking": 100,
    "similarQuestions": [
      "array-square",
      "array-filter",
      "array-reduce"
    ],
    "slug": "array-map",
    "title": "Array.prototype.map"
  },
  "skeleton": {
    "js": "/**\n * @template T, U\n * @param { (value: T) => U } callbackFn\n * @param {any} [thisArg]\n * @return {Array<U>}\n */\nArray.prototype.myMap = function (callbackFn, thisArg) {\n  throw 'Not implemented!';\n};",
    "ts": "interface Array<T> {\n  myMap<U>(callbackFn: (value: T) => U, thisArg?: any): Array<U>;\n}\n\nArray.prototype.myMap = function (callbackFn, thisArg) {\n  throw 'Not implemented!';\n};"
  },
  "solution": "var Component=(()=>{var y=Object.create;var i=Object.defineProperty;var m=Object.getOwnPropertyDescriptor;var f=Object.getOwnPropertyNames;var g=Object.getPrototypeOf,k=Object.prototype.hasOwnProperty;var b=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),w=(t,e)=>{for(var r in e)i(t,r,{get:e[r],enumerable:!0})},l=(t,e,r,c)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let a of f(e))!k.call(t,a)&&a!==r&&i(t,a,{get:()=>e[a],enumerable:!(c=m(e,a))||c.enumerable});return t};var A=(t,e,r)=>(r=t!=null?y(g(t)):{},l(e||!t||!t.__esModule?i(r,\"default\",{value:t,enumerable:!0}):r,t)),v=t=>l(i({},\"__esModule\",{value:!0}),t);var s=b((T,h)=>{h.exports=_jsx_runtime});var S={};w(S,{default:()=>M});var n=A(s());var o=MDXCodeBlock;var d=`/**\n * @template T, U\n * @param { (value: T) => U } callbackFn\n * @param {any} [thisArg]\n * @return {Array<U>}\n */\nArray.prototype.myMap = function (callbackFn, thisArg) {\n  const len = this.length;\n  const array = new Array(len);\n\n  for (let k = 0; k < len; k++) {\n    // Ignore index if value is not defined for index (e.g. in sparse arrays).\n    if (Object.hasOwn(this, k)) {\n      array[k] = callbackFn.call(thisArg, this[k], k, this);\n    }\n  }\n\n  return array;\n};\n`;var p=`Array.prototype.myMap = function (callbackFn, thisArg) {\n  if (\n    typeof callbackFn !== 'function' ||\n    !callbackFn.call ||\n    !callbackFn.apply\n  ) {\n    throw new TypeError(\\`\\${callbackFn} is not a function\\`);\n  }\n\n  const len = this.length;\n  const A = new Array(len);\n  let k = 0;\n\n  while (k < len) {\n    // Ignore index if value is not defined for index (e.g. in sparse arrays).\n    const kPresent = Object.hasOwn(this, k);\n    if (kPresent) {\n      const kValue = this[k];\n      const mappedValue = callbackFn.call(thisArg, kValue, k, this);\n      A[k] = mappedValue;\n    }\n    k = k + 1;\n  }\n\n  return A;\n};\n`;function u(t){let e=Object.assign({p:\"p\",code:\"code\",h2:\"h2\",ul:\"ul\",li:\"li\",pre:\"pre\",a:\"a\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(e.p,{children:[\"This question is pretty straightforward and just tests that you know how to access the array values within \",(0,n.jsx)(e.code,{children:\"Array.prototype\"}),\" methods (using \",(0,n.jsx)(e.code,{children:\"this\"}),\").\"]}),`\n`,(0,n.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"Initialize a new array to store the mapped results. As we loop through the array (via \",(0,n.jsx)(e.code,{children:\"this\"}),\"), call the callback on each array element with the following parameters: \",(0,n.jsx)(e.code,{children:\"element\"}),\", \",(0,n.jsx)(e.code,{children:\"index\"}),\", \",(0,n.jsx)(e.code,{children:\"array\"}),\", and \",(0,n.jsx)(e.code,{children:\"this\"}),\". This can be done by either using \",(0,n.jsx)(e.code,{children:\"Function.prototype.call\"}),\" or \",(0,n.jsx)(e.code,{children:\"Function.prototype.apply\"}),\".\"]}),`\n`,(0,n.jsx)(o,{children:d}),`\n`,(0,n.jsx)(e.h2,{children:\"Edge Cases\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Passing the \",(0,n.jsx)(e.code,{children:\"index\"}),\" and \",(0,n.jsx)(e.code,{children:\"array\"}),\" to the map callback.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Calling the map callback with the correct \",(0,n.jsx)(e.code,{children:\"this\"}),\" if \",(0,n.jsx)(e.code,{children:\"thisArg\"}),\" is specified.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Sparse arrays (e.g. \",(0,n.jsx)(e.code,{children:\"[1, 2, , 4]\"}),\"). The empty values should be ignored while traversing the array.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"Notes\"}),`\n`,(0,n.jsx)(e.p,{children:\"Mutating the array in the map callback is a bad idea and can cause unintended consequences. The provided solution does not follow the TC39 specification for array mutation scenarios, neither does the autograder check for the specification behavior for mutations.\"}),`\n`,(0,n.jsx)(e.p,{children:\"You probably won't be asked to implement the specification behavior during interviews but it is still a positive signal to mention that mutation of the array within the callback is possible but your code might not follow the specifications for it.\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"The \",(0,n.jsx)(e.code,{children:\"thisArg\"}),\" doesn't do anything if the callback is defined as an arrow function as arrow functions don't have their own bindings to \",(0,n.jsx)(e.code,{children:\"this\"}),\".\"]}),`\n`,(0,n.jsx)(e.h2,{children:\"One-liner Solution\"}),`\n`,(0,n.jsx)(e.p,{children:\"You can cheat the autograder by doing this.\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`Array.prototype.myMap = Array.prototype.map;\n`})}),`\n`,(0,n.jsx)(e.h2,{children:\"Spec Solution\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"Here's a solution that is based off the \",(0,n.jsxs)(e.a,{href:\"https://tc39.es/ecma262/multipage/array-maped-collections.html#sec-array.prototype.map\",children:[(0,n.jsx)(e.code,{children:\"Array.prototype.map\"}),\" ECMAScript specification\"]}),\".\"]}),`\n`,(0,n.jsx)(o,{children:p}),`\n`,(0,n.jsx)(e.h2,{children:\"Resources\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:(0,n.jsxs)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map\",children:[(0,n.jsx)(e.code,{children:\"Array.prototype.map\"}),\" | MDN\"]})}),`\n`,(0,n.jsx)(e.li,{children:(0,n.jsxs)(e.a,{href:\"https://tc39.es/ecma262/multipage/array-maped-collections.html#sec-array.prototype.map\",children:[(0,n.jsx)(e.code,{children:\"Array.prototype.map\"}),\" ECMAScript specification\"]})}),`\n`]})]})}function j(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(u,t)})):u(t)}var M=j;return v(S);})();\n;return Component;",
  "tests": "import './array-map';\n\nconst identity = (element) => element;\nconst square = (element) => element * element;\nconst multiplyByIndex = (element, index) => element * index;\nconst squareAlt = (element, index, array) => element * array[index];\nconst usesThis = function (element) {\n  return element * this;\n};\nconst usesThisArrowFn = (element) => element * this;\n\n/* eslint-disable no-undef */\ndescribe('Array.prototype.myMap', () => {\n  test('empty array', () => {\n    expect([].myMap(identity)).toEqual([]);\n    expect([].myMap(square)).toEqual([]);\n  });\n\n  test('one value', () => {\n    expect([10].myMap(identity)).toEqual([10]);\n    expect([10].myMap(square)).toEqual([100]);\n  });\n\n  test('two values', () => {\n    expect([-4, 10].myMap(identity)).toEqual([-4, 10]);\n    expect([-4, 10].myMap(square)).toEqual([16, 100]);\n  });\n\n  test('multiple values', () => {\n    expect([1, 2, 3, 4].myMap(identity)).toEqual([1, 2, 3, 4]);\n    expect([1, 2, 3, 4, 5].myMap(square)).toEqual([1, 4, 9, 16, 25]);\n  });\n\n  test('reducer uses index argument when provided', () => {\n    expect([1, 2, 3].myMap(multiplyByIndex)).toEqual([0, 2, 6]);\n    expect([-1, -3, 4].myMap(multiplyByIndex)).toEqual([-0, -3, 8]);\n  });\n\n  test('reducer uses array argument when provided', () => {\n    expect([1, 2, 3, 4].myMap(squareAlt)).toEqual([1, 4, 9, 16]);\n    expect([-1, -3, 4].myMap(squareAlt)).toEqual([1, 9, 16]);\n  });\n\n  test('uses this argument', () => {\n    expect([1, 2, 3, 4].myMap(usesThis)).toEqual([NaN, NaN, NaN, NaN]);\n    expect([1, 2, 3, 4].myMap(usesThis, 10)).toEqual([10, 20, 30, 40]);\n    expect([1, 2, 3, 4].myMap(usesThisArrowFn)).toEqual([NaN, NaN, NaN, NaN]);\n    expect([1, 2, 3, 4].myMap(usesThisArrowFn, 10)).toEqual([\n      NaN,\n      NaN,\n      NaN,\n      NaN,\n    ]);\n  });\n\n  test('sparse arrays', () => {\n    // eslint-disable-next-line no-sparse-arrays\n    expect([1, 2, , 4].myMap(identity)).toEqual([1, 2, , 4]);\n    // eslint-disable-next-line no-sparse-arrays\n    expect([1, 2, , 4].myMap(square)).toEqual([1, 4, , 16]);\n  });\n});"
}