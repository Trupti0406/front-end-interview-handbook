{
  "description": "var Component=(()=>{var d=Object.create;var s=Object.defineProperty;var h=Object.getOwnPropertyDescriptor;var p=Object.getOwnPropertyNames;var u=Object.getPrototypeOf,f=Object.prototype.hasOwnProperty;var j=(r,e)=>()=>(e||r((e={exports:{}}).exports,e),e.exports),v=(r,e)=>{for(var o in e)s(r,o,{get:e[o],enumerable:!0})},i=(r,e,o,c)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let t of p(e))!f.call(r,t)&&t!==o&&s(r,t,{get:()=>e[t],enumerable:!(c=h(e,t))||c.enumerable});return r};var b=(r,e,o)=>(o=r!=null?d(u(r)):{},i(e||!r||!r.__esModule?s(o,\"default\",{value:r,enumerable:!0}):o,r)),g=r=>i(s({},\"__esModule\",{value:!0}),r);var l=j((k,a)=>{a.exports=_jsx_runtime});var y={};v(y,{default:()=>x,frontmatter:()=>w});var n=b(l()),w={title:\"Promise.race\",excerpt:\"Implement the Promise.race() function that resolves or rejects when any of the input elements are resolved or rejected\"};function m(r){let e=Object.assign({blockquote:\"blockquote\",p:\"p\",code:\"code\",em:\"em\",a:\"a\",h2:\"h2\",pre:\"pre\"},r.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(e.blockquote,{children:[`\n`,(0,n.jsxs)(e.p,{children:[\"The \",(0,n.jsx)(e.code,{children:\"Promise.race()\"}),\" method returns a promise that fulfills or rejects as soon as one of the promises in an iterable fulfills or rejects, with the value or reason from that promise.\"]}),`\n`]}),`\n`,(0,n.jsxs)(e.blockquote,{children:[`\n`,(0,n.jsx)(e.p,{children:\"If the iterable passed is empty, the promise returned will be forever pending.\"}),`\n`]}),`\n`,(0,n.jsxs)(e.blockquote,{children:[`\n`,(0,n.jsxs)(e.p,{children:[\"If the iterable contains one or more non-promise value and/or an already settled promise, then \",(0,n.jsx)(e.code,{children:\"Promise.race()\"}),\" will resolve to the first of these values found in the iterable.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsxs)(e.em,{children:[\"Source: \",(0,n.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/race\",children:\"Promise.race() - JavaScript | MDN\"})]})}),`\n`,(0,n.jsxs)(e.p,{children:[\"Let's implement our own version of \",(0,n.jsx)(e.code,{children:\"Promise.race()\"}),\", a \",(0,n.jsx)(e.code,{children:\"promiseRace\"}),\" function, with the difference being the function takes in an array instead of an iterable. Be sure to read the description carefully and implement accordingly!\"]}),`\n`,(0,n.jsx)(e.h2,{children:\"Examples\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`const p0 = new Promise((resolve) => {\n  setTimeout(() => {\n    resolve(42);\n  }, 100);\n});\nconst p1 = new Promise((resolve, reject) => {\n  setTimeout(() => {\n    reject('Err!');\n  }, 400);\n});\n\nawait promiseRace([p0, p1]); // 42\n`})}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`const p0 = Promise.resolve(42);\nconst p1 = new Promise((resolve, reject) => {\n  setTimeout(() => {\n    resolve(21);\n  }, 100);\n});\n\nawait promiseRace([p0, p1]); // 42\n`})}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`const p0 = new Promise((resolve) => {\n  setTimeout(() => {\n    resolve(42);\n  }, 400);\n});\nconst p1 = new Promise((resolve, reject) => {\n  setTimeout(() => {\n    reject('Err!');\n  }, 100);\n});\n\ntry {\n  await promiseRace([p0, p1]);\n} catch (err) {\n  console.log(err); // 'Err!'\n}\n`})})]})}function P(r={}){let{wrapper:e}=r.components||{};return e?(0,n.jsx)(e,Object.assign({},r,{children:(0,n.jsx)(m,r)})):m(r)}var x=P;return g(y);})();\n;return Component;",
  "format": "javascript",
  "metadata": {
    "author": "yangshun",
    "companies": [],
    "created": 1655596800,
    "difficulty": "easy",
    "duration": 15,
    "excerpt": "Implement the Promise.race() function that resolves or rejects when any of the input elements are resolved or rejected",
    "featured": false,
    "format": "javascript",
    "frameworkDefault": null,
    "frameworks": [],
    "href": "/questions/javascript/promise-race",
    "importance": "mid",
    "languages": [
      "js",
      "ts"
    ],
    "nextQuestions": [],
    "premium": true,
    "published": true,
    "ranking": 100,
    "similarQuestions": [
      "promise-all",
      "promise-all-settled",
      "promise-any"
    ],
    "slug": "promise-race",
    "title": "Promise.race"
  },
  "skeleton": {
    "js": "/**\n * @param {Array} iterable\n * @return {Promise}\n */\nexport default function promiseRace(iterable) {\n  throw 'Not implemented!';\n}",
    "ts": "export default function promiseRace<T extends readonly unknown[] | []>(\n  iterable: T,\n): Promise<Awaited<T[number]>> {\n  throw 'Not implemented!';\n}"
  },
  "solution": "var Component=(()=>{var p=Object.create;var o=Object.defineProperty;var f=Object.getOwnPropertyDescriptor;var v=Object.getOwnPropertyNames;var w=Object.getPrototypeOf,y=Object.prototype.hasOwnProperty;var P=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),g=(n,e)=>{for(var i in e)o(n,i,{get:e[i],enumerable:!0})},h=(n,e,i,l)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let t of v(e))!y.call(n,t)&&t!==i&&o(n,t,{get:()=>e[t],enumerable:!(l=f(e,t))||l.enumerable});return n};var b=(n,e,i)=>(i=n!=null?p(w(n)):{},h(e||!n||!n.__esModule?o(i,\"default\",{value:n,enumerable:!0}):i,n)),j=n=>h(o({},\"__esModule\",{value:!0}),n);var d=P((k,a)=>{a.exports=_jsx_runtime});var R={};g(R,{default:()=>M});var r=b(d());var c=MDXCodeBlock;var s=`/**\n * @param {Array} iterable\n * @return {Promise}\n */\nexport default function promiseRace(iterable) {\n  return new Promise((resolve, reject) => {\n    if (iterable.length === 0) {\n      return;\n    }\n\n    iterable.forEach(async (item) => {\n      try {\n        const value = await item;\n        resolve(value);\n      } catch (err) {\n        reject(err);\n      }\n    });\n  });\n}\n`;var m=`/**\n * @param {Array} iterable\n * @return {Promise}\n */\nexport default function promiseRace(iterable) {\n  return new Promise((resolve, reject) => {\n    if (iterable.length === 0) {\n      return;\n    }\n\n    iterable.forEach((item) => Promise.resolve(item).then(resolve, reject));\n  });\n}\n`;function u(n){let e=Object.assign({p:\"p\",code:\"code\",h2:\"h2\",ol:\"ol\",li:\"li\",ul:\"ul\",a:\"a\"},n.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(e.p,{children:[\"Async programming is frequently tested during interviews. Understanding how \",(0,r.jsx)(e.code,{children:\"Promise.race\"}),\" works under the hood will help you in understanding the mechanisms behind similar \",(0,r.jsx)(e.code,{children:\"Promise\"}),\"-related functions like \",(0,r.jsx)(e.code,{children:\"Promise.any\"}),\", \",(0,r.jsx)(e.code,{children:\"Promise.all\"}),\", \",(0,r.jsx)(e.code,{children:\"Promise.allSettled\"}),\" etc.\"]}),`\n`,(0,r.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,r.jsx)(e.p,{children:\"There are a few aspects to this question we need to bear in mind and handle:\"}),`\n`,(0,r.jsxs)(e.ol,{children:[`\n`,(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:\"Promise\"}),\"s are meant to be chained, so the function needs to return a \",(0,r.jsx)(e.code,{children:\"Promise\"}),\".\"]}),`\n`,(0,r.jsxs)(e.li,{children:[\"If the input array is empty, the returned \",(0,r.jsx)(e.code,{children:\"Promise\"}),\" will be forever pending.\"]}),`\n`,(0,r.jsxs)(e.li,{children:[\"The input array can contain non-\",(0,r.jsx)(e.code,{children:\"Promise\"}),\"s.\"]}),`\n`]}),`\n`,(0,r.jsxs)(e.p,{children:[\"We'll return a \",(0,r.jsx)(e.code,{children:\"Promise\"}),\" at the top level of the function. We first check if the input array is empty, and just return without resolving or rejecting.\"]}),`\n`,(0,r.jsxs)(e.p,{children:[\"We then need to attempt resolving every item in the input array. This can be achieved using \",(0,r.jsx)(e.code,{children:\"Array.prototype.forEach\"}),\" or \",(0,r.jsx)(e.code,{children:\"Array.prototype.map\"}),\".\"]}),`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsx)(e.li,{children:\"If a item is resolved, resolve with the value.\"}),`\n`,(0,r.jsx)(e.li,{children:\"If a item is rejected, reject with the reason.\"}),`\n`]}),`\n`,(0,r.jsxs)(e.p,{children:[\"Since it's a race, we don't have to do much. Whichever item is resolved/rejected first wins and calls the \",(0,r.jsx)(e.code,{children:\"resolve\"}),\"/\",(0,r.jsx)(e.code,{children:\"reject\"}),\" function respectively.\"]}),`\n`,(0,r.jsxs)(e.p,{children:[\"One thing to note here is that because the input array can contain non-\",(0,r.jsx)(e.code,{children:\"Promise\"}),\" values, if we are not \",(0,r.jsx)(e.code,{children:\"await\"}),\"-ing them, we need to wrap each value with \",(0,r.jsx)(e.code,{children:\"Promise.resolve()\"}),\" which allows us to use \",(0,r.jsx)(e.code,{children:\".then()\"}),\" on each of them and we don't have to differentiate between \",(0,r.jsx)(e.code,{children:\"Promise\"}),\" vs non-\",(0,r.jsx)(e.code,{children:\"Promise\"}),\" values and whether they need to be resolved.\"]}),`\n`,(0,r.jsx)(c,{children:s}),`\n`,(0,r.jsxs)(e.p,{children:[\"Here's an alternative version which uses \",(0,r.jsx)(e.code,{children:\"Promise.then()\"}),\" if you prefer not to use \",(0,r.jsx)(e.code,{children:\"async\"}),\"/\",(0,r.jsx)(e.code,{children:\"await\"}),\", which is much shorter.\"]}),`\n`,(0,r.jsx)(c,{children:m}),`\n`,(0,r.jsx)(e.h2,{children:\"Edge Cases\"}),`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsx)(e.li,{children:\"Empty input array. A forever-pending promise should be returned.\"}),`\n`,(0,r.jsxs)(e.li,{children:[\"If the array contains non-\",(0,r.jsx)(e.code,{children:\"Promise\"}),\" values, \",(0,r.jsx)(e.code,{children:\"Promise.race()\"}),\" will resolve to the first of these values found in the iterable.\"]}),`\n`]}),`\n`,(0,r.jsx)(e.h2,{children:\"Techniques\"}),`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsxs)(e.li,{children:[\"Knowledge of \",(0,r.jsx)(e.code,{children:\"Promise\"}),\"s, how to construct one, how to use them.\"]}),`\n`,(0,r.jsx)(e.li,{children:\"Async programming.\"}),`\n`]}),`\n`,(0,r.jsx)(e.h2,{children:\"Resources\"}),`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/race\",children:\"Promise.race() - JavaScript | MDN\"})}),`\n`]})]})}function A(n={}){let{wrapper:e}=n.components||{};return e?(0,r.jsx)(e,Object.assign({},n,{children:(0,r.jsx)(u,n)})):u(n)}var M=A;return j(R);})();\n;return Component;",
  "tests": "import promiseRace from './promise-race';\n// import promiseRace from './solution/promiseRaceThen';\n\ndescribe('promiseRace', () => {\n  test('empty input array', (done) => {\n    expect.assertions(1);\n    const promise = promiseRace([]);\n    expect(promise).toBeInstanceOf(Promise);\n    promise.then(\n      (value) => {\n        expect(value).toBeTruthy();\n      },\n      (reason) => {\n        expect(reason).toBeTruthy();\n      },\n    );\n\n    setTimeout(() => {\n      done();\n    }, 10);\n  });\n\n  describe('one promise', () => {\n    describe('resolve', () => {\n      test('value', async () => {\n        expect.assertions(1);\n        const p0 = 2;\n\n        const res = await promiseRace([p0]);\n        expect(res).toEqual(2);\n      });\n\n      test('instant', async () => {\n        expect.assertions(1);\n        const p0 = Promise.resolve(2);\n\n        const res = await promiseRace([p0]);\n        expect(res).toEqual(2);\n      });\n\n      test('delayed', async () => {\n        expect.assertions(1);\n        const p0 = new Promise((resolve) => {\n          setTimeout(() => {\n            resolve(2);\n          }, 10);\n        });\n\n        const res = await promiseRace([p0]);\n        expect(res).toEqual(2);\n      });\n    });\n\n    describe('reject', () => {\n      test('instant', async () => {\n        expect.assertions(1);\n        const p0 = Promise.reject(2);\n\n        await expect(promiseRace([p0])).rejects.toBe(2);\n      });\n\n      test('delayed', async () => {\n        expect.assertions(1);\n        const p0 = new Promise((_, reject) => {\n          setTimeout(() => {\n            reject(2);\n          }, 10);\n        });\n\n        await expect(promiseRace([p0])).rejects.toBe(2);\n      });\n    });\n  });\n\n  describe('multiple promises', () => {\n    describe('all resolve', () => {\n      test('instant', async () => {\n        expect.assertions(1);\n        const p0 = Promise.resolve(2);\n        const p1 = Promise.resolve(3);\n\n        const res = await promiseRace([p0, p1]);\n        expect(res).toEqual(2);\n      });\n\n      test('delayed', async () => {\n        expect.assertions(1);\n        const p0 = Promise.resolve(2);\n        const p1 = new Promise((resolve) => {\n          setTimeout(() => {\n            resolve(3);\n          }, 10);\n        });\n\n        const res = await promiseRace([p0, p1]);\n        expect(res).toEqual(2);\n      });\n\n      test('mixture', async () => {\n        expect.assertions(1);\n        const p0 = new Promise((resolve) => {\n          setTimeout(() => {\n            resolve(2);\n          }, 10);\n        });\n        const p1 = Promise.resolve(3);\n        const p2 = 4;\n\n        const res = await promiseRace([p0, p1, p2]);\n        expect(res).toEqual(3);\n      });\n\n      test('many delayed', async () => {\n        expect.assertions(1);\n        const p0 = new Promise((resolve) => {\n          setTimeout(() => {\n            resolve(1);\n          }, 200);\n        });\n        const p1 = new Promise((resolve) => {\n          setTimeout(() => {\n            resolve(2);\n          }, 100);\n        });\n        const p2 = new Promise((resolve) => {\n          setTimeout(() => {\n            resolve(3);\n          }, 10);\n        });\n\n        const res = await promiseRace([p0, p1, p2]);\n        expect(res).toEqual(3);\n      });\n    });\n\n    describe('all reject', () => {\n      test('instant', async () => {\n        expect.assertions(1);\n        const p0 = Promise.reject(2);\n        const p1 = Promise.reject(3);\n\n        await expect(promiseRace([p0, p1])).rejects.toBe(2);\n      });\n\n      test('delayed', async () => {\n        expect.assertions(1);\n        const p0 = new Promise((_, reject) => {\n          setTimeout(() => {\n            reject(3);\n          }, 1);\n        });\n        const p1 = new Promise((_, reject) => {\n          setTimeout(() => {\n            reject(2);\n          }, 10);\n        });\n\n        await expect(promiseRace([p0, p1])).rejects.toBe(3);\n      });\n\n      test('mixture', async () => {\n        expect.assertions(1);\n        const p0 = Promise.reject(42);\n        const p1 = new Promise((_, reject) => {\n          setTimeout(() => {\n            reject(2);\n          }, 10);\n        });\n\n        await expect(promiseRace([p0, p1])).rejects.toBe(42);\n      });\n    });\n\n    describe('mix of resolve and reject', () => {\n      test('instant resolve delayed reject', async () => {\n        expect.assertions(1);\n        const p0 = Promise.resolve(42);\n        const p1 = new Promise((_, reject) => {\n          setTimeout(() => {\n            reject(2);\n          }, 10);\n        });\n\n        const res = await promiseRace([p0, p1]);\n        expect(res).toEqual(42);\n      });\n\n      test('instant resolve instant reject', async () => {\n        expect.assertions(1);\n        const p0 = Promise.resolve(42);\n        const p1 = Promise.reject(2);\n\n        const res = await promiseRace([p0, p1]);\n        expect(res).toEqual(42);\n      });\n\n      test('instant reject instant resolve', async () => {\n        expect.assertions(1);\n        const p0 = Promise.reject(42);\n        const p1 = Promise.resolve(2);\n\n        await expect(promiseRace([p0, p1])).rejects.toBe(42);\n      });\n\n      test('instant rejects', async () => {\n        expect.assertions(1);\n        const p0 = Promise.reject(42);\n        const p1 = Promise.reject(43);\n\n        await expect(promiseRace([p0, p1])).rejects.toBe(42);\n      });\n\n      test('delayed resolve', async () => {\n        expect.assertions(1);\n        const p0 = new Promise((resolve) => {\n          setTimeout(() => {\n            resolve(1);\n          }, 10);\n        });\n        const p1 = new Promise((_, reject) => {\n          setTimeout(() => {\n            reject(2);\n          }, 100);\n        });\n        const p2 = new Promise((resolve) => {\n          setTimeout(() => {\n            resolve(3);\n          }, 200);\n        });\n\n        await expect(promiseRace([p0, p1, p2])).resolves.toBe(1);\n      });\n\n      test('delayed reject', async () => {\n        expect.assertions(1);\n        const p0 = new Promise((_, reject) => {\n          setTimeout(() => {\n            reject(1);\n          }, 200);\n        });\n        const p1 = new Promise((resolve) => {\n          setTimeout(() => {\n            resolve(2);\n          }, 100);\n        });\n        const p2 = new Promise((_, reject) => {\n          setTimeout(() => {\n            reject(3);\n          }, 10);\n        });\n\n        await expect(promiseRace([p0, p1, p2])).rejects.toBe(3);\n      });\n    });\n  });\n});"
}