{
  "description": "var Component=(()=>{var p=Object.create;var a=Object.defineProperty;var h=Object.getOwnPropertyDescriptor;var m=Object.getOwnPropertyNames;var y=Object.getPrototypeOf,f=Object.prototype.hasOwnProperty;var u=(r,e)=>()=>(e||r((e={exports:{}}).exports,e),e.exports),g=(r,e)=>{for(var n in e)a(r,n,{get:e[n],enumerable:!0})},i=(r,e,n,l)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let o of m(e))!f.call(r,o)&&o!==n&&a(r,o,{get:()=>e[o],enumerable:!(l=h(e,o))||l.enumerable});return r};var x=(r,e,n)=>(n=r!=null?p(y(r)):{},i(e||!r||!r.__esModule?a(n,\"default\",{value:r,enumerable:!0}):n,r)),j=r=>i(a({},\"__esModule\",{value:!0}),r);var s=u((F,c)=>{c.exports=_jsx_runtime});var _={};g(_,{default:()=>A,frontmatter:()=>v});var t=x(s()),v={title:\"Array.prototype.filter\",excerpt:\"Implement the Array.prototype.filter() method\"};function d(r){let e=Object.assign({p:\"p\",code:\"code\",h2:\"h2\",pre:\"pre\",a:\"a\"},r.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.code,{children:\"Array.prototype.filter\"}),\" creates a new array populated with the results of calling a provided function on every element in the calling array.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"Implement \",(0,t.jsx)(e.code,{children:\"Array.prototype.filter\"}),\". To avoid overwriting the actual \",(0,t.jsx)(e.code,{children:\"Array.prototype.filter\"}),\" which is being used by the autograder, we shall instead implement it as \",(0,t.jsx)(e.code,{children:\"Array.prototype.myFilter\"}),\".\"]}),`\n`,(0,t.jsx)(e.h2,{children:\"Examples\"}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-js\",children:`[1, 2, 3, 4].myFilter((value) => value % 2 == 0); // [2, 4]\n[1, 2, 3, 4].myFilter((value) => value < 3); // [1, 2]\n`})}),`\n`,(0,t.jsx)(e.h2,{children:\"Notes\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"The filter callback function takes in more than just the element! There's also a second parameter for \",(0,t.jsx)(e.code,{children:\"Array.prototype.filter\"}),\" as well. You are recommended to read the specification for \",(0,t.jsx)(e.code,{children:\"Array.prototype.filter\"}),\" on \",(0,t.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter\",children:\"MDN Docs\"}),\" before attempting.\"]})]})}function b(r={}){let{wrapper:e}=r.components||{};return e?(0,t.jsx)(e,Object.assign({},r,{children:(0,t.jsx)(d,r)})):d(r)}var A=b;return j(_);})();\n;return Component;",
  "format": "javascript",
  "metadata": {
    "author": null,
    "companies": [
      "amazon",
      "apple"
    ],
    "created": 1656201600,
    "difficulty": "easy",
    "duration": 15,
    "excerpt": "Implement the Array.prototype.filter() method",
    "featured": true,
    "format": "javascript",
    "frameworkDefault": null,
    "frameworks": [],
    "href": "/questions/javascript/array-filter",
    "importance": "mid",
    "languages": [
      "js"
    ],
    "nextQuestions": [
      "array-map",
      "array-reduce"
    ],
    "premium": true,
    "published": true,
    "ranking": 100,
    "similarQuestions": [
      "array-square",
      "array-map",
      "array-reduce"
    ],
    "slug": "array-filter",
    "title": "Array.prototype.filter"
  },
  "skeleton": "/**\n * @callback callbackFn\n * @param {object} [thisArg]\n * @return {Array}\n */\nArray.prototype.myFilter = function (callbackFn, thisArg) {\n  throw 'Not implemented!';\n};",
  "solution": "var Component=(()=>{var f=Object.create;var l=Object.defineProperty;var y=Object.getOwnPropertyDescriptor;var k=Object.getOwnPropertyNames;var g=Object.getPrototypeOf,b=Object.prototype.hasOwnProperty;var m=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),w=(n,e)=>{for(var r in e)l(n,r,{get:e[r],enumerable:!0})},a=(n,e,r,c)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let i of k(e))!b.call(n,i)&&i!==r&&l(n,i,{get:()=>e[i],enumerable:!(c=y(e,i))||c.enumerable});return n};var A=(n,e,r)=>(r=n!=null?f(g(n)):{},a(e||!n||!n.__esModule?l(r,\"default\",{value:n,enumerable:!0}):r,n)),v=n=>a(l({},\"__esModule\",{value:!0}),n);var h=m((O,s)=>{s.exports=_jsx_runtime});var C={};w(C,{default:()=>S});var t=A(h());var o=MDXCodeBlock;var d=`/**\n * @callback callbackFn\n * @param {object} [thisArg]\n * @return {Array}\n */\nArray.prototype.myFilter = function (callbackFn, thisArg) {\n  const len = this.length;\n  const results = [];\n\n  for (let k = 0; k < len; k++) {\n    // Cache value in case the callback function modifies it.\n    const kValue = this[k];\n    if (\n      // Ignore index if value is not defined for index (e.g. in sparse arrays).\n      Object.hasOwn(this, k) &&\n      callbackFn.call(thisArg, kValue, k, this)\n    ) {\n      results.push(kValue);\n    }\n  }\n\n  return results;\n};\n`;var p=`Array.prototype.myFilter = function (callbackFn, thisArg) {\n  if (\n    typeof callbackFn !== 'function' ||\n    !callbackFn.call ||\n    !callbackFn.apply\n  ) {\n    throw new TypeError(\\`\\${callbackFn} is not a function\\`);\n  }\n\n  const len = this.length;\n  const A = [];\n  let k = 0;\n  let to = 0;\n\n  while (k < len) {\n    // Ignore index if value is not defined for index (e.g. in sparse arrays).\n    const kPresent = Object.hasOwn(this, k);\n    if (kPresent) {\n      const kValue = this[k];\n      const selected = Boolean(callbackFn.call(thisArg, kValue, k, this));\n      if (selected === true) {\n        A[to] = kValue;\n        to += 1;\n      }\n    }\n    k += 1;\n  }\n\n  return A;\n};\n`;function u(n){let e=Object.assign({p:\"p\",code:\"code\",h2:\"h2\",ul:\"ul\",li:\"li\",pre:\"pre\",a:\"a\"},n.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(e.p,{children:[\"This question is pretty straightforward and just tests that you know how to access the array values within \",(0,t.jsx)(e.code,{children:\"Array.prototype\"}),\" methods (using \",(0,t.jsx)(e.code,{children:\"this\"}),\").\"]}),`\n`,(0,t.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"Initialize a new array to store the filtered results. As we loop through the array (via \",(0,t.jsx)(e.code,{children:\"this\"}),\"), call the callback on each array element with the following parameters: \",(0,t.jsx)(e.code,{children:\"element\"}),\", \",(0,t.jsx)(e.code,{children:\"index\"}),\", \",(0,t.jsx)(e.code,{children:\"array\"}),\", and \",(0,t.jsx)(e.code,{children:\"this\"}),\". This be done by either using \",(0,t.jsx)(e.code,{children:\"Function.prototype.call\"}),\" or \",(0,t.jsx)(e.code,{children:\"Function.prototype.apply\"}),\".\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"If the callback evaluates to \",(0,t.jsx)(e.code,{children:\"true\"}),\", push the element into the \",(0,t.jsx)(e.code,{children:\"results\"}),\".\"]}),`\n`,(0,t.jsx)(o,{children:d}),`\n`,(0,t.jsx)(e.h2,{children:\"Edge Cases\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"Passing the \",(0,t.jsx)(e.code,{children:\"index\"}),\" and \",(0,t.jsx)(e.code,{children:\"array\"}),\" to the filter callback.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Invoking the filter callback with the correct \",(0,t.jsx)(e.code,{children:\"this\"}),\" if \",(0,t.jsx)(e.code,{children:\"thisArg\"}),\" is specified.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Sparse arrays, e.g. \",(0,t.jsx)(e.code,{children:\"[1, 2, , 4]\"}),\". The empty values should be ignored while traversing the array.\"]}),`\n`]}),`\n`,(0,t.jsx)(e.h2,{children:\"Notes\"}),`\n`,(0,t.jsx)(e.p,{children:\"Mutating the array in the filter callback is a bad idea and can cause unintended consequences. The provided solution does not follow the TC39 specification for array mutation scenarios, neither does the autograder check for the specification behavior for mutations.\"}),`\n`,(0,t.jsx)(e.p,{children:\"You probably won't be asked to implement the specification behavior during interviews but it is still a positive signal to mention that mutation of the array within the callback is possible but your code might not follow the specifications for it.\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"The \",(0,t.jsx)(e.code,{children:\"thisArg\"}),\" doesn't do anything if the callback is defined as an arrow function as arrow functions don't have their own bindings to \",(0,t.jsx)(e.code,{children:\"this\"}),\".\"]}),`\n`,(0,t.jsx)(e.h2,{children:\"One-liner Solution\"}),`\n`,(0,t.jsx)(e.p,{children:\"You can cheat the autograder by doing this.\"}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-js\",children:`Array.prototype.myFilter = Array.prototype.filter;\n`})}),`\n`,(0,t.jsx)(e.h2,{children:\"Spec Solution\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"Here's a solution that is based off the \",(0,t.jsxs)(e.a,{href:\"https://tc39.es/ecma262/multipage/array-filtered-collections.html#sec-array.prototype.filter\",children:[(0,t.jsx)(e.code,{children:\"Array.prototype.filter\"}),\" ECMAScript specification\"]}),\".\"]}),`\n`,(0,t.jsx)(o,{children:p}),`\n`,(0,t.jsx)(e.h2,{children:\"Resources\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:(0,t.jsxs)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter\",children:[(0,t.jsx)(e.code,{children:\"Array.prototype.filter\"}),\" | MDN\"]})}),`\n`,(0,t.jsx)(e.li,{children:(0,t.jsxs)(e.a,{href:\"https://tc39.es/ecma262/multipage/array-filtered-collections.html#sec-array.prototype.filter\",children:[(0,t.jsx)(e.code,{children:\"Array.prototype.filter\"}),\" ECMAScript specification\"]})}),`\n`]})]})}function j(n={}){let{wrapper:e}=n.components||{};return e?(0,t.jsx)(e,Object.assign({},n,{children:(0,t.jsx)(u,n)})):u(n)}var S=j;return v(C);})();\n;return Component;",
  "tests": "import './array-filter';\n\nconst isEven = (element) => element % 2 === 0;\nconst isOdd = (element) => element % 2 === 1;\nconst isEvenIndex = (_, index) => index % 2 === 0;\nconst isOddIndex = (_, index) => index % 2 === 1;\nconst isSquareEven = (_, index, array) =>\n  (array[index] * array[index]) % 2 === 0;\nconst isSquareOdd = (_, index, array) =>\n  (array[index] * array[index]) % 2 === 1;\nconst isThisProductEven = function (element) {\n  return (element * this) % 2 === 0;\n};\nconst isThisProductEvenArrowFn = (element) => (element * this) % 2 === 0;\n\n/* eslint-disable no-undef */\ndescribe('Array.prototype.myFilter', () => {\n  test('empty array', () => {\n    expect([].myFilter(isEven)).toStrictEqual([]);\n    expect([].myFilter(isOdd)).toStrictEqual([]);\n  });\n\n  test('one value', () => {\n    expect([1].myFilter(isEven)).toStrictEqual([]);\n    expect([1].myFilter(isOdd)).toStrictEqual([1]);\n  });\n\n  test('two values', () => {\n    expect([1, 10].myFilter(isEven)).toStrictEqual([10]);\n    expect([1, 10].myFilter(isOdd)).toStrictEqual([1]);\n  });\n\n  test('multiple values', () => {\n    expect([1, 2, 3, 5, 7, 8, 9].myFilter(isEven)).toStrictEqual([2, 8]);\n    expect([1, 2, 3, 5, 7, 8, 9].myFilter(isOdd)).toStrictEqual([\n      1, 3, 5, 7, 9,\n    ]);\n  });\n\n  test('reducer uses index argument when provided', () => {\n    expect([1, 2, 3].myFilter(isEvenIndex)).toStrictEqual([1, 3]);\n    expect([-1, -3, 4, 99].myFilter(isOddIndex)).toStrictEqual([-3, 99]);\n  });\n\n  test('reducer uses array argument when provided', () => {\n    expect([1, 2, 3, 4].myFilter(isSquareEven)).toStrictEqual([2, 4]);\n    expect([-3, 4, 1, 5].myFilter(isSquareOdd)).toStrictEqual([-3, 1, 5]);\n  });\n\n  test('uses this argument', () => {\n    expect([1, 2, 3, 4].myFilter(isThisProductEven)).toStrictEqual([]);\n    expect([1, 2, 3, 4].myFilter(isThisProductEven, 10)).toStrictEqual([\n      1, 2, 3, 4,\n    ]);\n    expect([1, 2, 3, 4].myFilter(isThisProductEven, 9)).toStrictEqual([2, 4]);\n    expect([1, 2, 3, 4].myFilter(isThisProductEvenArrowFn)).toStrictEqual([]);\n    expect([1, 2, 3, 4].myFilter(isThisProductEvenArrowFn, 10)).toStrictEqual(\n      [],\n    );\n    expect([1, 2, 3, 4].myFilter(isThisProductEvenArrowFn, 9)).toStrictEqual(\n      [],\n    );\n  });\n\n  test('sparse arrays', () => {\n    expect([, , ,].myFilter(isEven)).toStrictEqual([]);\n    // Sparse arrays have `undefined` as the values. Use === undefined to\n    // include them even after filtering.\n    expect([, , ,].myFilter((val) => val === undefined)).toStrictEqual([]);\n    expect([1, 2, , 4].myFilter(isEven)).toStrictEqual([2, 4]);\n    expect([1, , 2, , 4, 7, 9].myFilter(isOdd)).toStrictEqual([1, 7, 9]);\n  });\n});"
}