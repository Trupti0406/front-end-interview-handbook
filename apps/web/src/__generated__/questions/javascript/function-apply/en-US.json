{
  "description": "var Component=(()=>{var d=Object.create;var r=Object.defineProperty;var s=Object.getOwnPropertyDescriptor;var u=Object.getOwnPropertyNames;var m=Object.getPrototypeOf,y=Object.prototype.hasOwnProperty;var g=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),f=(n,e)=>{for(var o in e)r(n,o,{get:e[o],enumerable:!0})},i=(n,e,o,a)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let c of u(e))!y.call(n,c)&&c!==o&&r(n,c,{get:()=>e[c],enumerable:!(a=s(e,c))||a.enumerable});return n};var j=(n,e,o)=>(o=n!=null?d(m(n)):{},i(e||!n||!n.__esModule?r(o,\"default\",{value:n,enumerable:!0}):o,n)),v=n=>i(r({},\"__esModule\",{value:!0}),n);var p=g((A,l)=>{l.exports=_jsx_runtime});var _={};f(_,{default:()=>b,frontmatter:()=>x});var t=j(p()),x={title:\"Function.prototype.apply\",excerpt:\"Implement the Function.prototype.apply() function that calls the function with a given `this` value and arguments as an array\"};function h(n){let e=Object.assign({blockquote:\"blockquote\",p:\"p\",code:\"code\",em:\"em\",a:\"a\",h2:\"h2\",pre:\"pre\"},n.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(e.blockquote,{children:[`\n`,(0,t.jsxs)(e.p,{children:[\"The \",(0,t.jsx)(e.code,{children:\"Function.prototype.apply()\"}),\" method calls the specified function with a given \",(0,t.jsx)(e.code,{children:\"this\"}),\" value, and \",(0,t.jsx)(e.code,{children:\"arguments\"}),\" provided as an array (or an array-like object).\"]}),`\n`]}),`\n`,(0,t.jsx)(e.p,{children:(0,t.jsxs)(e.em,{children:[\"Source: \",(0,t.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_objects/Function/apply\",children:\"Function.prototype.apply() - JavaScript | MDN\"})]})}),`\n`,(0,t.jsxs)(e.p,{children:[\"Implement your own \",(0,t.jsx)(e.code,{children:\"Function.prototype.apply\"}),\" without calling the native \",(0,t.jsx)(e.code,{children:\"apply\"}),\" method. To avoid overwriting the actual \",(0,t.jsx)(e.code,{children:\"Function.prototype.apply\"}),\", implement the function as \",(0,t.jsx)(e.code,{children:\"Function.prototype.myApply\"}),\".\"]}),`\n`,(0,t.jsx)(e.h2,{children:\"Examples\"}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-js\",children:`function multiplyAge(multiplier = 1) {\n  return this.age * multiplier;\n}\n\nconst mary = {\n  age: 21,\n};\n\nconst john = {\n  age: 42,\n};\n\nmultiplyAge.myApply(mary); // 21\nmultiplyAge.myApply(john, [2]); // 84\n`})})]})}function F(n={}){let{wrapper:e}=n.components||{};return e?(0,t.jsx)(e,Object.assign({},n,{children:(0,t.jsx)(h,n)})):h(n)}var b=F;return v(_);})();\n;return Component;",
  "format": "javascript",
  "metadata": {
    "author": null,
    "companies": [],
    "created": 1690329600,
    "difficulty": "easy",
    "duration": 10,
    "excerpt": "Implement the Function.prototype.apply() function that calls the function with a given `this` value and arguments as an array",
    "featured": false,
    "format": "javascript",
    "frameworkDefault": null,
    "frameworks": [],
    "href": "/questions/javascript/function-apply",
    "importance": "mid",
    "languages": [
      "js",
      "ts"
    ],
    "nextQuestions": [],
    "premium": true,
    "published": true,
    "ranking": 100,
    "similarQuestions": [
      "function-bind",
      "function-call"
    ],
    "slug": "function-apply",
    "subtitle": null,
    "title": "Function.prototype.apply",
    "topics": []
  },
  "skeleton": {
    "js": "/**\n * @param {any} thisArg\n * @param {Array<any>} args\n * @return {any}\n */\nFunction.prototype.myApply = function (thisArg, args) {\n  throw 'Not implemented!';\n};",
    "ts": "interface Function {\n  myApply(thisArg: any, args: any[]): any;\n}\n\nFunction.prototype.myApply = function (thisArg, args) {\n  throw 'Not implemented!';\n};"
  },
  "solution": "var Component=(()=>{var g=Object.create;var a=Object.defineProperty;var f=Object.getOwnPropertyDescriptor;var b=Object.getOwnPropertyNames;var A=Object.getPrototypeOf,w=Object.prototype.hasOwnProperty;var F=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),x=(t,e)=>{for(var i in e)a(t,i,{get:e[i],enumerable:!0})},l=(t,e,i,c)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let r of b(e))!w.call(t,r)&&r!==i&&a(t,r,{get:()=>e[r],enumerable:!(c=f(e,r))||c.enumerable});return t};var j=(t,e,i)=>(i=t!=null?g(A(t)):{},l(e||!t||!t.__esModule?a(i,\"default\",{value:t,enumerable:!0}):i,t)),v=t=>l(a({},\"__esModule\",{value:!0}),t);var s=F((X,d)=>{d.exports=_jsx_runtime});var D={};x(D,{default:()=>M});var n=j(s());var o=MDXCodeBlock;var h=`/**\n * @param {any} thisArg\n * @param {Array<any>} args\n * @return {any}\n */\nFunction.prototype.myApply = function (thisArg, args = []) {\n  return this.bind(thisArg)(...args);\n};\n`;var p=`/**\n * @param {any} thisArg\n * @param {Array<any>} args\n * @return {any}\n */\nFunction.prototype.myApply = function (thisArg, args = []) {\n  return this.bind(thisArg, ...args)();\n};\n`;var u=`/**\n * @param {any} thisArg\n * @param {Array<any>} args\n * @return {any}\n */\nFunction.prototype.myApply = function (thisArg, args = []) {\n  return this.call(thisArg, ...args);\n};\n`;var y=`/**\n * @param {any} thisArg\n * @param {Array<any>} args\n * @return {any}\n */\nFunction.prototype.myApply = function (thisArg, args = []) {\n  const sym = Symbol();\n  const wrapperObj = Object(thisArg);\n  Object.defineProperty(wrapperObj, sym, {\n    enumerable: false,\n    value: this,\n  });\n\n  return wrapperObj[sym](...args);\n};\n`;function m(t){let e=Object.assign({p:\"p\",code:\"code\",h2:\"h2\",h3:\"h3\",pre:\"pre\",ul:\"ul\",li:\"li\",em:\"em\",a:\"a\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(e.p,{children:[\"The \",(0,n.jsx)(e.code,{children:\"Function.prototype.apply()\"}),\" function is a built-in method in JavaScript that allows you to call a function with a specified this value and an array of arguments. Like \",(0,n.jsx)(e.code,{children:\"Function.prototype.call()\"}),\", it allows you to explicitly define the context (\",(0,n.jsx)(e.code,{children:\"this\"}),\" value) in which the function will be executed.\"]}),`\n`,(0,n.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"As \",(0,n.jsx)(e.code,{children:\"Function.prototype.apply()\"}),\" takes in an array of arguments, we have to define a default empty array parameter for \",(0,n.jsx)(e.code,{children:\"args\"}),\" if we are to spread it, because we can only spread iterables.\"]}),`\n`,(0,n.jsxs)(e.h3,{children:[\"Solution 1: Using \",(0,n.jsx)(e.code,{children:\"bind\"})]}),`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.code,{children:\"bind\"}),\", \",(0,n.jsx)(e.code,{children:\"apply\"}),\", and \",(0,n.jsx)(e.code,{children:\"call\"}),\" can be viewed as sibling functions. They're highly similar in terms of function signature and usage. Within \",(0,n.jsx)(e.code,{children:\"Function.prototype\"}),\" methods, \",(0,n.jsx)(e.code,{children:\"this\"}),\" refers to the \",(0,n.jsx)(e.code,{children:\"Function\"}),\" object itself. If the \",(0,n.jsx)(e.code,{children:\"this\"}),\" context is not used at all, the following will work:\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`Function.prototype.myApply = function (thisArg, args = []) {\n  return this(...args);\n};\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"However, \",(0,n.jsx)(e.code,{children:\"thisArg\"}),\" is still used widely in modern code, so we need another way to do this. \",(0,n.jsx)(e.code,{children:\"Function.prototype.bind\"}),\" creates a new function with a specified \",(0,n.jsx)(e.code,{children:\"this\"}),\" value and initial arguments, without executing the original function immediately. It allows you to permanently bind a specific context (\",(0,n.jsx)(e.code,{children:\"this\"}),\" value) to the function and partially apply arguments if needed. This is exactly what we need to bridge the gap in the solution above.\"]}),`\n`,(0,n.jsx)(o,{children:h}),`\n`,(0,n.jsxs)(e.p,{children:[\"Or you can also pass the \",(0,n.jsx)(e.code,{children:\"args\"}),\" into \",(0,n.jsx)(e.code,{children:\"bind()\"}),\" before executing it.\"]}),`\n`,(0,n.jsx)(o,{children:p}),`\n`,(0,n.jsxs)(e.h3,{children:[\"Solution 2: Using \",(0,n.jsx)(e.code,{children:\"call\"})]}),`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.code,{children:\"Function.prototype.call\"}),\" and \",(0,n.jsx)(e.code,{children:\"Function.prototype.apply\"}),\" are very similar. Here's an easy way to remember each function's signature:\"]}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"Function.prototype.call\"}),\" takes in a \",(0,n.jsx)(e.em,{children:\"c\"}),\"omma-separated list of arguments.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"Function.prototype.apply\"}),\" takes in an \",(0,n.jsx)(e.em,{children:\"a\"}),\"aray of arguments.\"]}),`\n`]}),`\n`,(0,n.jsx)(o,{children:u}),`\n`,(0,n.jsxs)(e.h3,{children:[\"Solution 3: Using \",(0,n.jsx)(e.code,{children:\"Symbol\"})]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Another approach is to create a \",(0,n.jsx)(e.code,{children:\"Symbol\"}),\" and add it as a property to a newly-created \",(0,n.jsx)(e.code,{children:\"Object\"}),\" with \",(0,n.jsx)(e.code,{children:\"thisArg\"}),\" bound to it. This is very similar to one of the solutions to the \",(0,n.jsx)(e.a,{href:\"/questions/javascript/function-bind\",children:(0,n.jsx)(e.code,{children:\"Function.prototype.bind\"})}),\" question.\"]}),`\n`,(0,n.jsx)(o,{children:y})]})}function C(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(m,t)})):m(t)}var M=C;return v(D);})();\n;return Component;",
  "tests": "import './function-apply';\n\ndescribe('Function.prototype.myApply', () => {\n  const person = {\n    name: 'John',\n  };\n  function getName() {\n    return this.name;\n  }\n  function sum(...args) {\n    return args.reduce((acc, num) => acc + num, 0);\n  }\n  function greeting(prefix, message) {\n    return `${prefix} ${this.name}, ${message}`;\n  }\n\n  test('Function.prototype.myApply is a function', () => {\n    expect(typeof Function.prototype.myApply).toBe('function');\n  });\n\n  test('`this` is bound', () => {\n    expect(getName.myApply(person)).toStrictEqual('John');\n  });\n\n  describe('without `this`', () => {\n    test('single parameter', () => {\n      expect(sum.myApply(null, [1])).toBe(1);\n    });\n\n    test('two parameters', () => {\n      expect(sum.myApply(null, [1, 2])).toBe(3);\n    });\n\n    test('three parameters', () => {\n      expect(sum.myApply(null, [1, 2, 3])).toBe(6);\n    });\n  });\n\n  test('`this` and parameters', () => {\n    expect(greeting.myApply(person, ['Hello', 'how are you?'])).toStrictEqual(\n      'Hello John, how are you?',\n    );\n  });\n});"
}