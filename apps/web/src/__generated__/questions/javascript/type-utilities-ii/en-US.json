{
  "description": "var Component=(()=>{var h=Object.create;var r=Object.defineProperty;var u=Object.getOwnPropertyDescriptor;var p=Object.getOwnPropertyNames;var f=Object.getPrototypeOf,v=Object.prototype.hasOwnProperty;var y=(i,e)=>()=>(e||i((e={exports:{}}).exports,e),e.exports),m=(i,e)=>{for(var t in e)r(i,t,{get:e[t],enumerable:!0})},o=(i,e,t,l)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let c of p(e))!v.call(i,c)&&c!==t&&r(i,c,{get:()=>e[c],enumerable:!(l=u(e,c))||l.enumerable});return i};var j=(i,e,t)=>(t=i!=null?h(f(i)):{},o(e||!i||!i.__esModule?r(t,\"default\",{value:i,enumerable:!0}):t,i)),b=i=>o(r({},\"__esModule\",{value:!0}),i);var d=y((_,a)=>{a.exports=_jsx_runtime});var O={};m(O,{default:()=>x,frontmatter:()=>g});var n=j(d()),g={title:\"Type Utilities II\",excerpt:\"Implement utilities to determine non-primitive variable types in JavaScript\"};function s(i){let e=Object.assign({p:\"p\",a:\"a\",ul:\"ul\",li:\"li\",code:\"code\"},i.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(e.p,{children:[\"JavaScript is a dynamically typed language, which means the types of variable types can be changed during runtime. Many interview questions involve recursion of objects that can hold values of different types and how to handle each value type differs according to the type (e.g. different code is needed to iterate over an array vs an object). Knowledge of handling the JavaScript types is crucial to solving questions like \",(0,n.jsx)(e.a,{href:\"/questions/javascript/deep-clone\",children:\"Deep Clone\"}),\" and \",(0,n.jsx)(e.a,{href:\"/questions/javascript/deep-equal\",children:\"Deep Equal\"}),\".\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"In \",(0,n.jsx)(e.a,{href:\"/questions/javascript/type-utilities\",children:\"Type Utilities\"}),\", we have implemented utility functions to determine the types of primitive values. In this question, we will implement the following utility functions to determine the types of non-primitive values.\"]}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"isArray(value)\"}),\": Return \",(0,n.jsx)(e.code,{children:\"true\"}),\" if \",(0,n.jsx)(e.code,{children:\"value\"}),\" is an array, \",(0,n.jsx)(e.code,{children:\"false\"}),\" otherwise.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"isFunction(value)\"}),\": Return \",(0,n.jsx)(e.code,{children:\"true\"}),\" if \",(0,n.jsx)(e.code,{children:\"value\"}),\" is a function, \",(0,n.jsx)(e.code,{children:\"false\"}),\" otherwise.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"isObject(value)\"}),\": Return \",(0,n.jsx)(e.code,{children:\"true\"}),\" if \",(0,n.jsx)(e.code,{children:\"value\"}),\" is an object (e.g. arrays, functions, objects, etc, but not including \",(0,n.jsx)(e.code,{children:\"null\"}),\" and \",(0,n.jsx)(e.code,{children:\"undefined\"}),\"), \",(0,n.jsx)(e.code,{children:\"false\"}),\" otherwise.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"isPlainObject(value)\"}),\": Return \",(0,n.jsx)(e.code,{children:\"true\"}),\" if \",(0,n.jsx)(e.code,{children:\"value\"}),\" is a plain object, \",(0,n.jsx)(e.code,{children:\"false\"}),\" otherwise (for arrays, functions, etc).\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"A plain object, or what is commonly known as a Plain Old JavaScript Object (POJO) is any object whose prototype is \",(0,n.jsx)(e.code,{children:\"Object.prototype\"}),\" or an object created via \",(0,n.jsx)(e.code,{children:\"Object.create(null)\"}),\".\"]}),`\n`]}),`\n`]}),`\n`]})]})}function w(i={}){let{wrapper:e}=i.components||{};return e?(0,n.jsx)(e,Object.assign({},i,{children:(0,n.jsx)(s,i)})):s(i)}var x=w;return b(O);})();\n;return Component;",
  "format": "javascript",
  "metadata": {
    "author": "yangshun",
    "companies": [],
    "created": 1649894400,
    "difficulty": "easy",
    "duration": 15,
    "excerpt": "Implement utilities to determine non-primitive variable types in JavaScript",
    "featured": false,
    "format": "javascript",
    "frameworkDefault": null,
    "frameworks": [],
    "href": "/questions/javascript/type-utilities-ii",
    "importance": "low",
    "languages": [
      "js",
      "ts"
    ],
    "nextQuestions": [
      "is-empty",
      "deep-clone",
      "deep-equal"
    ],
    "premium": false,
    "published": true,
    "ranking": 100,
    "similarQuestions": [
      "type-utilities"
    ],
    "slug": "type-utilities-ii",
    "title": "Type Utilities II"
  },
  "skeleton": {
    "js": "export function isArray(value) {\n  throw 'Not implemented!';\n}\n\nexport function isFunction(value) {\n  throw 'Not implemented!';\n}\n\nexport function isObject(value) {\n  throw 'Not implemented!';\n}\n\nexport function isPlainObject(value) {\n  throw 'Not implemented!';\n}",
    "ts": "export function isArray(value: any): boolean {\n  throw 'Not implemented!';\n}\n\nexport function isFunction(value: any): boolean {\n  throw 'Not implemented!';\n}\n\nexport function isObject(value: any): boolean {\n  throw 'Not implemented!';\n}\n\nexport function isPlainObject(value: any): boolean {\n  throw 'Not implemented!';\n}"
  },
  "solution": "var Component=(()=>{var p=Object.create;var c=Object.defineProperty;var f=Object.getOwnPropertyDescriptor;var y=Object.getOwnPropertyNames;var j=Object.getPrototypeOf,b=Object.prototype.hasOwnProperty;var v=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),O=(n,e)=>{for(var o in e)c(n,o,{get:e[o],enumerable:!0})},i=(n,e,o,l)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let r of y(e))!b.call(n,r)&&r!==o&&c(n,r,{get:()=>e[r],enumerable:!(l=f(e,r))||l.enumerable});return n};var m=(n,e,o)=>(o=n!=null?p(j(n)):{},i(e||!n||!n.__esModule?c(o,\"default\",{value:n,enumerable:!0}):o,n)),w=n=>i(c({},\"__esModule\",{value:!0}),n);var d=v((k,a)=>{a.exports=_jsx_runtime});var P={};O(P,{default:()=>g});var t=m(d());var s=MDXCodeBlock;var u=`export function isArray(value) {\n  return Array.isArray(value);\n}\n\n// Alternative to isArray.\nexport function isArrayAlt(value) {\n  // For null and undefined.\n  if (value == null) {\n    return false;\n  }\n\n  return value.constructor === Array;\n}\n\nexport function isFunction(value) {\n  return typeof value === 'function';\n}\n\nexport function isObject(value) {\n  // For null and undefined.\n  if (value == null) {\n    return false;\n  }\n\n  const type = typeof value;\n  return type === 'object' || type === 'function';\n}\n\nexport function isPlainObject(value) {\n  // For null and undefined.\n  if (value == null) {\n    return false;\n  }\n\n  const prototype = Object.getPrototypeOf(value);\n  return prototype === null || prototype === Object.prototype;\n}\n\n// Alternative to isPlainObject, Lodash's implementation.\nexport function isPlainObjectAlternative(value) {\n  if (!isObject(value)) {\n    return false;\n  }\n\n  // For objects created via Object.create(null);\n  if (Object.getPrototypeOf(value) === null) {\n    return true;\n  }\n\n  let proto = value;\n  while (Object.getPrototypeOf(proto) !== null) {\n    proto = Object.getPrototypeOf(proto);\n  }\n\n  return Object.getPrototypeOf(value) === proto;\n}\n`;function h(n){let e=Object.assign({h2:\"h2\",h3:\"h3\",code:\"code\",p:\"p\",ol:\"ol\",li:\"li\",ul:\"ul\"},n.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,t.jsx)(e.h3,{children:(0,t.jsx)(e.code,{children:\"isArray\"})}),`\n`,(0,t.jsxs)(e.p,{children:[\"Since ES5, there exists an \",(0,t.jsx)(e.code,{children:\"Array.isArray()\"}),\" function which does exactly what we need here.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"However, if we're not allowed to use this or need to support old browsers, we can check the constructor of the object. However, some values like \",(0,t.jsx)(e.code,{children:\"null\"}),\" and \",(0,t.jsx)(e.code,{children:\"undefined\"}),\" have to be specially handled.\"]}),`\n`,(0,t.jsx)(e.h3,{children:(0,t.jsx)(e.code,{children:\"isFunction\"})}),`\n`,(0,t.jsxs)(e.p,{children:[\"We can simply use \",(0,t.jsx)(e.code,{children:\"typeof value === 'function'\"}),\" to check.\"]}),`\n`,(0,t.jsx)(e.h3,{children:(0,t.jsx)(e.code,{children:\"isObject\"})}),`\n`,(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.code,{children:\"null\"}),\" and \",(0,t.jsx)(e.code,{children:\"undefined\"}),\" are considered \",(0,t.jsx)(e.code,{children:\"Object\"}),\"s, so we need to handle them specially as well. \",(0,t.jsx)(e.code,{children:\"Function\"}),\"s are also objects.\"]}),`\n`,(0,t.jsx)(e.h3,{children:(0,t.jsx)(e.code,{children:\"isPlainObject\"})}),`\n`,(0,t.jsx)(e.p,{children:\"There are two types of plain objects:\"}),`\n`,(0,t.jsxs)(e.ol,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"Objects without prototypes, created using \",(0,t.jsx)(e.code,{children:\"Object.create(null)\"}),\"s.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Object defined using literals (e.g. \",(0,t.jsx)(e.code,{children:\"let a = {}\"}),\").\"]}),`\n`]}),`\n`,(0,t.jsxs)(e.p,{children:[\"To check for the first case, \",(0,t.jsx)(e.code,{children:\"Object.getPrototypeOf(value)\"}),\" will be exactly \",(0,t.jsx)(e.code,{children:\"null\"}),\". To check for the second case, we can use the constructor of its prototype, similar to how we check if an object is an \",(0,t.jsx)(e.code,{children:\"Array\"}),\".\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"Lodash's implementation of \",(0,t.jsx)(e.code,{children:\"isPlainObject\"}),\" traverses the object's prototype chain but that's unnecessary if we check the constructor.\"]}),`\n`,(0,t.jsx)(s,{children:u}),`\n`,(0,t.jsx)(e.h2,{children:\"Techniques\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:\"Familiarity with JavaScript types.\"}),`\n`,(0,t.jsx)(e.li,{children:\"Object and prototypes.\"}),`\n`]})]})}function A(n={}){let{wrapper:e}=n.components||{};return e?(0,t.jsx)(e,Object.assign({},n,{children:(0,t.jsx)(h,n)})):h(n)}var g=A;return w(P);})();\n;return Component;",
  "tests": "import {\n  isArray,\n  isFunction,\n  isObject,\n  isPlainObject,\n} from './type-utilities-ii';\n\ndescribe('Type utilities for non-primitives', () => {\n  describe('isArray', () => {\n    test('array', () => {\n      expect(isArray([])).toBe(true);\n      expect(isArray([1, 2])).toBe(true);\n      expect(isArray([1])).toBe(true);\n      expect(isArray(new Array(3))).toBe(true);\n      expect(isArray(Array(3))).toBe(true);\n      expect(isArray(Array.from({ length: 10 }, (_, i) => i))).toBe(true);\n    });\n\n    test('non-array', () => {\n      expect(isArray()).toBe(false);\n      expect(isArray(true)).toBe(false);\n      expect(isArray(false)).toBe(false);\n      expect(isArray('true')).toBe(false);\n      expect(isArray(new Date())).toBe(false);\n      expect(isArray(new Error())).toBe(false);\n      expect(isArray({ a: 1 })).toBe(false);\n      expect(isArray(/x/)).toBe(false);\n      expect(isArray('a')).toBe(false);\n      expect(isArray(null)).toBe(false);\n      expect(isArray(undefined)).toBe(false);\n      expect(isArray(1)).toBe(false);\n      expect(isArray(NaN)).toBe(false);\n      expect(isArray(Symbol('symbol'))).toBe(false);\n      expect(isArray(new Uint8Array(32))).toBe(false);\n    });\n  });\n\n  describe('isFunction', () => {\n    test('function declarations', () => {\n      function identity(x) {\n        return x;\n      }\n      expect(isFunction(identity)).toBe(true);\n    });\n\n    test('arrow functions', () => {\n      const identity = (x) => {\n        return x;\n      };\n      expect(isFunction(identity)).toBe(true);\n    });\n\n    test('non-function', () => {\n      expect(isFunction(true)).toBe(false);\n      expect(isFunction(false)).toBe(false);\n      expect(isFunction('true')).toBe(false);\n      expect(isFunction([1, 2, 3])).toBe(false);\n      expect(isFunction(new Date())).toBe(false);\n      expect(isFunction(new Error())).toBe(false);\n      expect(isFunction({ a: 1 })).toBe(false);\n      expect(isFunction(/x/)).toBe(false);\n      expect(isFunction('a')).toBe(false);\n      expect(isFunction(null)).toBe(false);\n      expect(isFunction(undefined)).toBe(false);\n      expect(isFunction(1)).toBe(false);\n      expect(isFunction(NaN)).toBe(false);\n      expect(isFunction(Symbol('symbol'))).toBe(false);\n    });\n  });\n\n  describe('isObject', () => {\n    test('object', () => {\n      expect(isObject([1, 2, 3])).toBe(true);\n      expect(isObject(Object(false))).toBe(true);\n      expect(isObject(new Date())).toBe(true);\n      expect(isObject(new Error())).toBe(true);\n      expect(isObject({ a: 1 })).toBe(true);\n      expect(isObject(Object(0))).toBe(true);\n      expect(isObject(/x/)).toBe(true);\n      expect(isObject(Object('a'))).toBe(true);\n      expect(isObject(new Set())).toBe(true);\n      expect(isObject(new Map())).toBe(true);\n      expect(isObject(() => {})).toBe(true);\n    });\n\n    test('class instance', () => {\n      class Foo {\n        constructor(value) {\n          this.value = value;\n        }\n      }\n\n      expect(isObject(new Foo(1))).toBe(true);\n    });\n\n    test('function instance', () => {\n      function Foo(value) {\n        this.value = value;\n      }\n\n      expect(isObject(new Foo(1))).toBe(true);\n    });\n\n    test('non-object', () => {\n      expect(isObject(true)).toBe(false);\n      expect(isObject(false)).toBe(false);\n      expect(isObject('true')).toBe(false);\n      expect(isObject('a')).toBe(false);\n      expect(isObject(null)).toBe(false);\n      expect(isObject(undefined)).toBe(false);\n      expect(isObject(1)).toBe(false);\n      expect(isObject(NaN)).toBe(false);\n      expect(isObject(Symbol('symbol'))).toBe(false);\n    });\n  });\n\n  describe('isPlainObject', () => {\n    test('object literals', () => {\n      function Foo(value) {\n        this.value = value;\n      }\n\n      expect(isPlainObject({})).toBe(true);\n      expect(isPlainObject({ a: 1 })).toBe(true);\n      expect(isPlainObject({ constructor: Foo })).toBe(true);\n    });\n\n    test('object without prototype', () => {\n      expect(isPlainObject(Object.create(null))).toBe(true);\n    });\n\n    test('class instance', () => {\n      class Foo {\n        constructor(value) {\n          this.value = value;\n        }\n      }\n\n      expect(isPlainObject(new Foo(1))).toBe(false);\n    });\n\n    test('function instance', () => {\n      function Foo(value) {\n        this.value = value;\n      }\n\n      expect(isPlainObject(new Foo(1))).toBe(false);\n    });\n\n    test('non-plain objects', () => {\n      expect(isPlainObject(true)).toBe(false);\n      expect(isPlainObject(false)).toBe(false);\n      expect(isPlainObject('true')).toBe(false);\n      expect(isPlainObject([1, 2, 3])).toBe(false);\n      expect(isPlainObject(new Date())).toBe(false);\n      expect(isPlainObject(new Error())).toBe(false);\n      expect(isPlainObject(/x/)).toBe(false);\n      expect(isPlainObject('a')).toBe(false);\n      expect(isPlainObject(null)).toBe(false);\n      expect(isPlainObject(undefined)).toBe(false);\n      expect(isPlainObject(1)).toBe(false);\n      expect(isPlainObject(NaN)).toBe(false);\n      expect(isPlainObject(Symbol('symbol'))).toBe(false);\n      expect(isPlainObject(new Set())).toBe(false);\n      expect(isPlainObject(new Map())).toBe(false);\n    });\n  });\n});"
}