{
  "description": "var Component=(()=>{var p=Object.create;var r=Object.defineProperty;var h=Object.getOwnPropertyDescriptor;var m=Object.getOwnPropertyNames;var b=Object.getPrototypeOf,g=Object.prototype.hasOwnProperty;var u=(t,n)=>()=>(n||t((n={exports:{}}).exports,n),n.exports),j=(t,n)=>{for(var i in n)r(t,i,{get:n[i],enumerable:!0})},s=(t,n,i,o)=>{if(n&&typeof n==\"object\"||typeof n==\"function\")for(let a of m(n))!g.call(t,a)&&a!==i&&r(t,a,{get:()=>n[a],enumerable:!(o=h(n,a))||o.enumerable});return t};var x=(t,n,i)=>(i=t!=null?p(b(t)):{},s(n||!t||!t.__esModule?r(i,\"default\",{value:t,enumerable:!0}):i,t)),f=t=>s(r({},\"__esModule\",{value:!0}),t);var d=u((y,c)=>{c.exports=_jsx_runtime});var M={};j(M,{default:()=>z,frontmatter:()=>v});var e=x(d()),v={title:\"HTML Serializer\",excerpt:\"Implement a function to serialize an object into a HTML string with indentation\"};function l(t){let n=Object.assign({p:\"p\",h2:\"h2\",pre:\"pre\",code:\"code\"},t.components);return(0,e.jsxs)(e.Fragment,{children:[(0,e.jsx)(n.p,{children:\"Given an object which resembles a DOM tree, implement a function that serializes the object into a formatted string with proper indentation (one tab per nesting level) and one tag per line.\"}),`\n`,(0,e.jsx)(n.h2,{children:\"Examples\"}),`\n`,(0,e.jsx)(n.pre,{children:(0,e.jsx)(n.code,{className:\"language-js\",children:`const tree = {\n  tag: 'body',\n  children: [\n    { tag: 'div', children: [{ tag: 'span', children: ['foo', 'bar'] }] },\n    { tag: 'div', children: ['baz'] },\n  ],\n};\n\nserializeNode(tree);\n// Output:\n\\`<body>\n\t<div>\n\t\t<span>\n\t\t\tfoo\n\t\t\tbar\n\t\t</span>\n\t</div>\n\t<div>\n\t\tbaz\n\t</div>\n</body>\\`;\n`})})]})}function _(t={}){let{wrapper:n}=t.components||{};return n?(0,e.jsx)(n,Object.assign({},t,{children:(0,e.jsx)(l,t)})):l(t)}var z=_;return f(M);})();\n;return Component;",
  "format": "javascript",
  "metadata": {
    "author": "zhenghao",
    "companies": [],
    "created": 1654992000,
    "difficulty": "medium",
    "duration": 20,
    "excerpt": "Implement a function to serialize an object into a HTML string with indentation",
    "featured": false,
    "format": "javascript",
    "frameworkDefault": null,
    "frameworks": [],
    "href": "/questions/javascript/html-serializer",
    "importance": "low",
    "languages": [
      "html",
      "js",
      "ts"
    ],
    "nextQuestions": [],
    "premium": true,
    "published": true,
    "ranking": 100,
    "similarQuestions": [
      "json-stringify"
    ],
    "slug": "html-serializer",
    "title": "HTML Serializer"
  },
  "skeleton": {
    "js": "/**\n * @param {Node} node\n * @return {string}\n */\nexport default function serializeNode(node) {\n  throw 'Not implemented!';\n}",
    "ts": "export default function serializeNode(node: Node): string {\n  throw 'Not implemented!';\n}"
  },
  "solution": "var Component=(()=>{var p=Object.create;var i=Object.defineProperty;var g=Object.getOwnPropertyDescriptor;var f=Object.getOwnPropertyNames;var m=Object.getPrototypeOf,w=Object.prototype.hasOwnProperty;var b=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),y=(n,e)=>{for(var r in e)i(n,r,{get:e[r],enumerable:!0})},s=(n,e,r,a)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let o of f(e))!w.call(n,o)&&o!==r&&i(n,o,{get:()=>e[o],enumerable:!(a=g(e,o))||a.enumerable});return n};var v=(n,e,r)=>(r=n!=null?p(m(n)):{},s(e||!n||!n.__esModule?i(r,\"default\",{value:n,enumerable:!0}):r,n)),j=n=>s(i({},\"__esModule\",{value:!0}),n);var c=b((D,d)=>{d.exports=_jsx_runtime});var N={};y(N,{default:()=>M});var t=v(c());var l=MDXCodeBlock;var h=`/**\n * @param {Node} node\n * @return {string}\n */\nexport default function serializeNode(obj, indent = '\\\\t') {\n  function traverse(node, depth = 0) {\n    return node.children\n      ? [\n          \\`\\${indent.repeat(depth)}<\\${node.tag}>\\`,\n          ...node.children.flatMap((child) => traverse(child, depth + 1)),\n          \\`\\${indent.repeat(depth)}</\\${node.tag}>\\`,\n        ]\n      : \\`\\${indent.repeat(depth)}\\${node}\\`;\n  }\n\n  return traverse(obj).join('\\\\n');\n}\n`;function u(n){let e=Object.assign({p:\"p\",h2:\"h2\",ol:\"ol\",li:\"li\",code:\"code\",pre:\"pre\",ul:\"ul\"},n.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.p,{children:\"This seems like an unusual question because normally we don't programmatically generate HTML strings from an object. We normally just write JSX or other template syntax and let Prettier do the formatting.\"}),`\n`,`\n`,(0,t.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,t.jsx)(e.p,{children:\"Let's work backward from the desired output. In order to form such an output string, we need a way to collect all the information about this DOM tree and organize them to the desired format. And in order to acquire the info about each node, we need to visit them one by one, i.e. traversing the object. Effectively, we can split the task into two sub-tasks:\"}),`\n`,(0,t.jsxs)(e.ol,{children:[`\n`,(0,t.jsx)(e.li,{children:\"Traverse the object recursively.\"}),`\n`,(0,t.jsx)(e.li,{children:\"Extract and organize the info to form the output.\"}),`\n`]}),`\n`,(0,t.jsxs)(e.p,{children:[\"There are two ways to traverse a tree - Depth-first search and Breadth-first search. If you have taken data structure courses on Trees before, you should be really familiar with these two approaches. If you don't know know that much, don't worry. Let's first take a step back and observe the \",(0,t.jsx)(e.code,{children:\"tree\"}),\" object. We can see that each object has a similar structure and there is a pattern - items in the \",(0,t.jsx)(e.code,{children:\"children\"}),\" property look like its parent, with the exception that some items in \",(0,t.jsx)(e.code,{children:\"children\"}),\" are strings, representing a leaf text node in typical DOM trees. Whenever we see a pattern like this, we should immediately think of recursion. Not to say recursion is the only and best way to solve problems like this, but it usually is a good place to start looking.\"]}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-js\",children:`const tree = {\n  tag: 'body',\n  children: [\n    { tag: 'div', children: [{ tag: 'span', children: ['foo', 'bar'] }] },\n    { tag: 'div', children: ['baz'] },\n  ],\n};\n`})}),`\n`,(0,t.jsxs)(e.p,{children:[\"Let's continue on the traversing part. As we have discussed, we would want to use recursion to process the \",(0,t.jsx)(e.code,{children:\"tree\"}),\" object. And it is easy to tell when we should stop recursion for a given input: if the input has a \",(0,t.jsx)(e.code,{children:\"children\"}),\" property, we keep on exploring the tree by calling the function itself on the items in \",(0,t.jsx)(e.code,{children:\"children\"}),\"; otherwise, we know we are at the leaf node and we should stop and return the input (i.e. the \",(0,t.jsx)(e.code,{children:\"string\"}),\").\"]}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-js\",children:`function traverse(input) {\n  // Every recursion needs a base case.\n  if (!input.children) {\n    return input;\n  }\n\n  // Loop through every child.\n  for (const child of input.children) {\n    // Recurse into each child via traverse(child)\n  }\n}\n`})}),`\n`,(0,t.jsxs)(e.p,{children:[\"We figured out roughly how we want to traverse the \",(0,t.jsx)(e.code,{children:\"tree\"}),\" object so we can visit every node in the tree. Let's move on to what we need to do exactly on every node.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"For a leaf text node, all we need to do is to return the string as-is. For a host node with \",(0,t.jsx)(e.code,{children:\"children\"}),\", we need to get its tag name, put it into an open and closing tag, and wrap that around its children. For example, for \",(0,t.jsx)(e.code,{children:\"{ tag: 'span', children: ['bar1', 'bar2'] }\"}),\", the output would be:\"]}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-js\",children:`\\`<span>\n  bar1\n  bar2\n</span>\\`;\n`})}),`\n`,(0,t.jsxs)(e.p,{children:[\"Note that we probably don't want to manipulate the strings directly during each visit as the code can get really hairy. Instead, we can first store each line of the output string in an array, i.e. \",(0,t.jsx)(e.code,{children:\"['<span >', ' bar1', ' bar2', '</span>']\"}),\" and concatenate them via \",(0,t.jsx)(e.code,{children:\"join('\\\\n')\"}),\" before returning.\"]}),`\n`,(0,t.jsx)(e.p,{children:\"Here is an initial but incomplete solution:\"}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-js\",children:`function serializeNode(root) {\n  function traverse(root) {\n    return root.children\n      ? [\\`<\\${root.tag}>\\`, ...root.children.flatMap(traverse), \\`</\\${root.tag}>\\`]\n      : root;\n  }\n\n  return traverse(root).join('\\\\n');\n}\n`})}),`\n`,(0,t.jsxs)(e.p,{children:[\"It might look very terse to you but if you take a closer look at it, you would realize that it is doing exactly what is described above. We simply replaced the \",(0,t.jsx)(e.code,{children:\"if\"}),\" statement with a ternary operator \",(0,t.jsx)(e.code,{children:\"? ... : ...\"}),\" and \",(0,t.jsx)(e.code,{children:\"for ... of\"}),\" statement with a \",(0,t.jsx)(e.code,{children:\"flatMap\"}),\". You might not be familiar with \",(0,t.jsx)(e.code,{children:\"flatMap\"}),\" but it is basically \",(0,t.jsx)(e.code,{children:\"map\"}),\" that automatically concatenate/flatten every sub-array items in the resulting array.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"However this solution is not complete because it doesn't indent the output string properly. Here is the output we get with our current solution by passing the \",(0,t.jsx)(e.code,{children:\"tree\"}),\" object to it:\"]}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-js\",children:`\\`<body>\n<div>\n<span>\nbar\nbar2\n</span>\n</div>\n<div>\nbaz\n</div>\n</body>\\`;\n`})}),`\n`,(0,t.jsx)(e.p,{children:\"We can tell that the level of indentation is dictated by the current depth of recursion. One way to achieve that is to pass a depth argument to the recursion call which increments by 1 after going one level deeper into the recursion call stack. While we are at it, we can also parameterize the character for indentation so the user can choose to indent by one tab or spaces.\"}),`\n`,(0,t.jsx)(e.p,{children:\"Here is the final solution:\"}),`\n`,(0,t.jsx)(l,{children:h}),`\n`,(0,t.jsx)(e.h2,{children:\"Edge Cases\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:\"The solution doesn't works with DOM trees that only contain text nodes.\"}),`\n`]})]})}function x(n={}){let{wrapper:e}=n.components||{};return e?(0,t.jsx)(e,Object.assign({},n,{children:(0,t.jsx)(u,n)})):u(n)}var M=x;return j(N);})();\n;return Component;",
  "tests": "import serializeNode from './html-serializer';\n\n/* eslint-disable no-undef */\ndescribe('HTML serializer', () => {\n  describe('single tag', () => {\n    test('single children', () => {\n      expect(\n        serializeNode({\n          tag: 'div',\n          children: ['foo'],\n        }),\n      ).toEqual('<div>\\n\\tfoo\\n</div>');\n    });\n\n    test('single tag two children', () => {\n      expect(\n        serializeNode({ children: ['bar1', 'bar2'], tag: 'span' }),\n      ).toEqual('<span>\\n\\tbar1\\n\\tbar2\\n</span>');\n    });\n  });\n\n  test('deeply nested', () => {\n    expect(\n      serializeNode({\n        tag: 'body',\n        children: [\n          { tag: 'div', children: [{ tag: 'span', children: ['foo', 'bar'] }] },\n          { tag: 'div', children: ['baz'] },\n        ],\n      }),\n    ).toEqual(\n      '<body>\\n\\t<div>\\n\\t\\t<span>\\n\\t\\t\\tfoo\\n\\t\\t\\tbar\\n\\t\\t</span>\\n\\t</div>\\n\\t<div>\\n\\t\\tbaz\\n\\t</div>\\n</body>',\n    );\n  });\n});"
}