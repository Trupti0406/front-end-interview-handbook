{
  "description": "var Component=(()=>{var c=Object.create;var r=Object.defineProperty;var h=Object.getOwnPropertyDescriptor;var m=Object.getOwnPropertyNames;var p=Object.getPrototypeOf,b=Object.prototype.hasOwnProperty;var q=(i,e)=>()=>(e||i((e={exports:{}}).exports,e),e.exports),f=(i,e)=>{for(var t in e)r(i,t,{get:e[t],enumerable:!0})},u=(i,e,t,l)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let s of m(e))!b.call(i,s)&&s!==t&&r(i,s,{get:()=>e[s],enumerable:!(l=h(e,s))||l.enumerable});return i};var k=(i,e,t)=>(t=i!=null?c(p(i)):{},u(e||!i||!i.__esModule?r(t,\"default\",{value:i,enumerable:!0}):t,i)),g=i=>u(r({},\"__esModule\",{value:!0}),i);var d=q((_,o)=>{o.exports=_jsx_runtime});var j={};f(j,{default:()=>x,frontmatter:()=>D});var n=k(d()),D={title:\"Data Selection\",excerpt:\"Implement a function to filter rows of data matching a specified requirement\"};function a(i){let e=Object.assign({p:\"p\",pre:\"pre\",code:\"code\",ul:\"ul\",li:\"li\",h2:\"h2\"},i.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.p,{children:\"A data set of gym sessions looks like this:\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`[\n  { user: 8, duration: 50, equipment: ['bench'] },\n  { user: 7, duration: 150, equipment: ['dumbbell'] },\n  { user: 1, duration: 10, equipment: ['barbell'] },\n  { user: 7, duration: 100, equipment: ['bike', 'kettlebell'] },\n  { user: 7, duration: 200, equipment: ['bike'] },\n  { user: 2, duration: 200, equipment: ['treadmill'] },\n  { user: 2, duration: 200, equipment: ['bike'] },\n];\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"Each session has the following fields:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"user\"}),\": User ID of the session's user.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"duration\"}),\": Duration of the session, in minutes.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"equipment\"}),\": Array of equipment used during the sessions, in alphabetical order.\"]}),`\n`]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Implement a method \",(0,n.jsx)(e.code,{children:\"selectData\"}),\", which is used to return sessions from the data. It has the interface \",(0,n.jsx)(e.code,{children:\"selectData(sessions [, options])\"}),\". The options available should include:\"]}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"user\"}),\": Select only sessions with this \",(0,n.jsx)(e.code,{children:\"id\"}),\".\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"minDuration\"}),\": Select only sessions with \",(0,n.jsx)(e.code,{children:\"duration\"}),\" equal to or greater than this value.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"equipment\"}),\": Select only sessions where at least one of the specified equipments were used.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"merge\"}),\": If set to \",(0,n.jsx)(e.code,{children:\"true\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Sessions from the same \",(0,n.jsx)(e.code,{children:\"user\"}),\" should be merged into one object. When merging:\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Sum up the \",(0,n.jsx)(e.code,{children:\"duration\"}),\" fields.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Combine all the \",(0,n.jsx)(e.code,{children:\"equipment\"}),\" used, de-duplicating the values and sort alphabetically.\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsx)(e.li,{children:\"The other filter options should be applied to the merged data.\"}),`\n`]}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.p,{children:[\"The order of the results should always remain unchanged from the original set, and in the case of merging sessions with duplicate users, the row should take the place of the latest occurrence of that \",(0,n.jsx)(e.code,{children:\"user\"}),\". The input objects should not be modified.\"]}),`\n`,(0,n.jsx)(e.h2,{children:\"Examples\"}),`\n`,(0,n.jsx)(e.p,{children:\"The following examples use the data set above:\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`selectData(sessions);\n// [\n//   { user: 8, duration: 50, equipment: ['bench'] },\n//   { user: 7, duration: 150, equipment: ['dumbbell', 'kettlebell'] },\n//   { user: 1, duration: 10, equipment: ['barbell'] },\n//   { user: 7, duration: 100, equipment: ['bike', 'kettlebell'] },\n//   { user: 7, duration: 200, equipment: ['bike'] },\n//   { user: 2, duration: 200, equipment: ['treadmill'] },\n//   { user: 2, duration: 200, equipment: ['bike'] },\n// ];\n\nselectData(sessions, { user: 2 });\n// [\n//   { user: 2, duration: 200, equipment: ['treadmill'] },\n//   { user: 2, duration: 200, equipment: ['bike'] },\n// ];\n\nselectData(sessions, { minDuration: 200 });\n// [\n//   { user: 7, duration: 200, equipment: ['bike'] },\n//   { user: 2, duration: 200, equipment: ['treadmill'] },\n//   { user: 2, duration: 200, equipment: ['bike'] },\n// ];\n\nselectData(sessions, { minDuration: 400 });\n// [];\n\nselectData(sessions, { equipment: ['bike', 'dumbbell'] });\n// [\n//   { user: 7, duration: 150, equipment: ['dumbbell', 'kettlebell'] },\n//   { user: 7, duration: 100, equipment: ['bike', 'kettlebell'] },\n//   { user: 7, duration: 200, equipment: ['bike'] },\n//   { user: 2, duration: 200, equipment: ['bike'] },\n// ];\n\nselectData(sessions, { merge: true });\n// [\n//   { user: 8, duration: 50, equipment: ['bench'] },\n//   { user: 1, duration: 10, equipment: ['dumbbell'] },\n//   { user: 7, duration: 450, equipment: ['bike', 'dumbbell', 'kettlebell'] },\n//   { user: 2, duration: 400, equipment: ['bike', 'treadmill'] },\n// ];\n\nselectData(sessions, { merge: true, minDuration: 400 });\n// [\n//   { user: 7, duration: 450, equipment: ['bike', 'dumbbell', 'kettlebell'] },\n//   { user: 2, duration: 400, equipment: ['bike', 'treadmill'] },\n// ];\n`})})]})}function w(i={}){let{wrapper:e}=i.components||{};return e?(0,n.jsx)(e,Object.assign({},i,{children:(0,n.jsx)(a,i)})):a(i)}var x=w;return g(j);})();\n;return Component;",
  "format": "javascript",
  "metadata": {
    "author": null,
    "companies": [
      "soundcloud"
    ],
    "created": 1655596800,
    "difficulty": "hard",
    "duration": 30,
    "excerpt": "Implement a function to filter rows of data matching a specified requirement",
    "featured": false,
    "format": "javascript",
    "frameworkDefault": null,
    "frameworks": [],
    "href": "/questions/javascript/data-selection",
    "importance": "high",
    "languages": [
      "js"
    ],
    "nextQuestions": [],
    "premium": true,
    "published": true,
    "ranking": 100,
    "similarQuestions": [
      "unique-array"
    ],
    "slug": "data-selection",
    "title": "Data Selection"
  },
  "skeleton": "/**\n * @param {Array<{{user: number, duration: number, equipment: Array<string>}}>} sessions\n * @param {{user?: number, minDuration?: number, equipment?: Array<string>, merge?: boolean}} [options]\n * @return {Array}\n */\nexport default function selectData(sessions, options) {\n  throw 'Not implemented!';\n}",
  "solution": "var Component=(()=>{var p=Object.create;var o=Object.defineProperty;var m=Object.getOwnPropertyDescriptor;var f=Object.getOwnPropertyNames;var w=Object.getPrototypeOf,b=Object.prototype.hasOwnProperty;var g=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),q=(n,e)=>{for(var i in e)o(n,i,{get:e[i],enumerable:!0})},c=(n,e,i,r)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let t of f(e))!b.call(n,t)&&t!==i&&o(n,t,{get:()=>e[t],enumerable:!(r=m(e,t))||r.enumerable});return n};var y=(n,e,i)=>(i=n!=null?p(w(n)):{},c(e||!n||!n.__esModule?o(i,\"default\",{value:n,enumerable:!0}):i,n)),v=n=>c(o({},\"__esModule\",{value:!0}),n);var h=g((A,a)=>{a.exports=_jsx_runtime});var D={};q(D,{default:()=>j});var s=y(h());var d=MDXCodeBlock;var l=`function setHasOverlap(setA, setB) {\n  // Bundler doesn't transpile properly when doing for-of for sets.\n  for (const val of Array.from(setA)) {\n    if (setB.has(val)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n/**\n * @param {Array<{{user: number, duration: number, equipment: Array<string>}}>} sessions\n * @param {{user?: number, minDuration?: number, equipment?: Array<string>, merge?: boolean}} [options]\n * @return {Array}\n */\nexport default function selectData(sessions, options = {}) {\n  const reversedSessions = sessions.slice().reverse(); // Make a copy and reverse.\n  const userSessions = {};\n  const sessionsProcessed = [];\n\n  reversedSessions.forEach((session) => {\n    if (options.merge && Object.hasOwn(userSessions, session.user)) {\n      const userSession = userSessions[session.user];\n      userSession.duration += session.duration;\n      session.equipment.forEach((equipment) => {\n        userSession.equipment.add(equipment);\n      });\n    } else {\n      const clonedSession = {\n        ...session,\n        equipment: new Set(session.equipment),\n      };\n\n      if (options.merge) {\n        userSessions[session.user] = clonedSession;\n      }\n\n      sessionsProcessed.push(clonedSession);\n    }\n  });\n\n  sessionsProcessed.reverse();\n\n  const results = [];\n  const optionEquipments = new Set(options.equipment);\n  sessionsProcessed.forEach((session) => {\n    if (\n      (options.user != null && options.user !== session.user) ||\n      (optionEquipments.size > 0 &&\n        !setHasOverlap(optionEquipments, session.equipment)) ||\n      (options.minDuration != null && options.minDuration > session.duration)\n    ) {\n      return;\n    }\n\n    results.push({\n      ...session,\n      equipment: Array.from(session.equipment).sort(),\n    });\n  });\n\n  return results;\n}\n`;function u(n){let e=Object.assign({p:\"p\",h2:\"h2\",ul:\"ul\",li:\"li\",code:\"code\",ol:\"ol\",h3:\"h3\",blockquote:\"blockquote\"},n.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(e.p,{children:\"This question assesses one's familiarity with JavaScript language.\"}),`\n`,(0,s.jsx)(e.h2,{children:\"Clarification Questions\"}),`\n`,(0,s.jsxs)(e.ul,{children:[`\n`,(0,s.jsxs)(e.li,{children:[\"What is the expected behavior if \",(0,s.jsx)(e.code,{children:\"options\"}),\" contains \",(0,s.jsx)(e.code,{children:\"equipment: []\"}),\"?\",`\n`,(0,s.jsxs)(e.ul,{children:[`\n`,(0,s.jsxs)(e.li,{children:[\"It should treat it as \",(0,s.jsx)(e.code,{children:\"equipment\"}),\" is not specified at all, but we won't test that case.\"]}),`\n`]}),`\n`]}),`\n`]}),`\n`,(0,s.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,s.jsx)(e.p,{children:\"Let's break the question down into two parts:\"}),`\n`,(0,s.jsxs)(e.ol,{children:[`\n`,(0,s.jsx)(e.li,{children:\"Filtering the sessions according to the options.\"}),`\n`,(0,s.jsxs)(e.li,{children:[\"Merging the sessions by the \",(0,s.jsx)(e.code,{children:\"user\"}),\" field if \",(0,s.jsx)(e.code,{children:\"merge: true\"}),\" is present in the \",(0,s.jsx)(e.code,{children:\"options\"}),\".\"]}),`\n`]}),`\n`,(0,s.jsx)(e.h3,{children:\"Filtering the sessions according to the options\"}),`\n`,(0,s.jsxs)(e.p,{children:[\"Filtering according to the \",(0,s.jsx)(e.code,{children:\"user\"}),\" and \",(0,s.jsx)(e.code,{children:\"minDuration\"}),\" is pretty straightforward. We can use basic operators to check if the \",(0,s.jsx)(e.code,{children:\"user\"}),\" fields match and whether \",(0,s.jsx)(e.code,{children:\"duration > minDuration\"}),\".\"]}),`\n`,(0,s.jsxs)(e.p,{children:[\"To match the equipments, we have to determine if the \",(0,s.jsx)(e.code,{children:\"equipment\"}),\" between the \",(0,s.jsx)(e.code,{children:\"options\"}),\" and each session has overlaps. One way is to convert both \",(0,s.jsx)(e.code,{children:\"equipment\"}),\" fields into \",(0,s.jsx)(e.code,{children:\"Set\"}),\"s so that we can perform lookup in O(1) time. We implement a \",(0,s.jsx)(e.code,{children:\"setHasOverlap\"}),\" function to achieve that.\"]}),`\n`,(0,s.jsxs)(e.h3,{children:[\"Merging the sessions by \",(0,s.jsx)(e.code,{children:\"user\"}),\" field\"]}),`\n`,(0,s.jsxs)(e.p,{children:[\"This is the tricky part of the question. We have to merge the data for sessions with the same \",(0,s.jsx)(e.code,{children:\"user\"}),\" field and also preserve the order. Note the requirement that:\"]}),`\n`,(0,s.jsxs)(e.blockquote,{children:[`\n`,(0,s.jsx)(e.p,{children:\"in the case of merging sessions with duplicate users, the row should take the place of the latest occurrence of that user. The input objects should not be modified.\"}),`\n`]}),`\n`,(0,s.jsxs)(e.p,{children:[\"It would be easier if the question asked for first occurrence of that user as we can push the session into the array and the position will be the correct final position. If we encounter sessions for the same user again, we can update that earlier session without changing its position in the array. Thankfully, an elegant trick would be to reverse the input array first as \",(0,s.jsx)(e.code,{children:\"reversedSessions\"}),\" and we can treat it as if the question asked to maintain the order of first occurrence of the user.\"]}),`\n`,(0,s.jsxs)(e.p,{children:[\"We use a new array \",(0,s.jsx)(e.code,{children:\"sessionsProcessed\"}),\", which will eventually contain sessions in the correct order and the merged user sessions. The array will be be the one we operate on when filtering according to the options.\"]}),`\n`,(0,s.jsxs)(e.p,{children:[\"As we iterate through \",(0,s.jsx)(e.code,{children:\"reversedSessions\"}),\", for each session, we see if the \",(0,s.jsx)(e.code,{children:\"user\"}),\" has been encountered before. If it is the first time, we add a new entry to \",(0,s.jsx)(e.code,{children:\"sessionsProcessed\"}),\". Otherwise, we update the combined session with the current session data.\"]}),`\n`,(0,s.jsxs)(e.p,{children:[\"To modify the combined session for a user, we create a \",(0,s.jsx)(e.code,{children:\"userSessions\"}),\" object with the key being the user ID and value being the combined session object. Modifying the combined session object can be done through looking up the \",(0,s.jsx)(e.code,{children:\"userSessions\"}),\" object with the user ID and modifying the value if it exists. The object within \",(0,s.jsx)(e.code,{children:\"sessionsProcessed\"}),\" will be updated as well because they are the same object.\"]}),`\n`,(0,s.jsx)(d,{children:l}),`\n`,(0,s.jsx)(e.h2,{children:\"Techniques\"}),`\n`,(0,s.jsxs)(e.ul,{children:[`\n`,(0,s.jsxs)(e.li,{children:[\"Familiarity with JavaScript data structures like \",(0,s.jsx)(e.code,{children:\"Array\"}),\"s and \",(0,s.jsx)(e.code,{children:\"Set\"}),\"s.\"]}),`\n`]})]})}function k(n={}){let{wrapper:e}=n.components||{};return e?(0,s.jsx)(e,Object.assign({},n,{children:(0,s.jsx)(u,n)})):u(n)}var j=k;return v(D);})();\n;return Component;",
  "tests": "import selectData from './data-selection';\n\nconst dataSmall = [\n  { user: 8, duration: 50, equipment: ['bench'] },\n  { user: 7, duration: 150, equipment: ['dumbbell', 'kettlebell'] },\n  { user: 1, duration: 10, equipment: ['barbell'] },\n  { user: 7, duration: 100, equipment: ['bike', 'kettlebell'] },\n  { user: 7, duration: 200, equipment: ['bike'] },\n  { user: 2, duration: 200, equipment: ['treadmill'] },\n  { user: 2, duration: 200, equipment: ['bike'] },\n];\n\n/* eslint-disable no-undef */\ndescribe('selectData', () => {\n  test('empty data', () => {\n    expect(selectData([])).toEqual([]);\n    expect(selectData([], { user: 2 })).toEqual([]);\n    expect(selectData([], { merge: true })).toEqual([]);\n  });\n\n  test('does not mutate data', () => {\n    selectData(dataSmall, { user: 1 });\n    selectData(dataSmall, { minDuration: 150 });\n    selectData(dataSmall, {\n      merge: true,\n      equipment: ['treadmill', 'bench', 'barbell', 'dumbbell', 'bike'],\n    });\n    expect(dataSmall).toEqual(dataSmall);\n  });\n\n  test('no options', () => {\n    expect(selectData(dataSmall)).toEqual(dataSmall);\n  });\n\n  describe('user option', () => {\n    test('user with single session', () => {\n      expect(selectData(dataSmall, { user: 1 })).toEqual([\n        { user: 1, duration: 10, equipment: ['barbell'] },\n      ]);\n    });\n\n    test('user with multiple sessions', () => {\n      expect(selectData(dataSmall, { user: 2 })).toEqual([\n        { user: 2, duration: 200, equipment: ['treadmill'] },\n        { user: 2, duration: 200, equipment: ['bike'] },\n      ]);\n    });\n\n    test('non-existing user', () => {\n      expect(selectData(dataSmall, { user: 99 })).toEqual([]);\n    });\n  });\n\n  describe('minDuration option', () => {\n    test('low minDuration', () => {\n      expect(selectData(dataSmall, { minDuration: 150 })).toEqual([\n        { user: 7, duration: 150, equipment: ['dumbbell', 'kettlebell'] },\n        { user: 7, duration: 200, equipment: ['bike'] },\n        { user: 2, duration: 200, equipment: ['treadmill'] },\n        { user: 2, duration: 200, equipment: ['bike'] },\n      ]);\n      expect(selectData(dataSmall, { minDuration: 151 })).toEqual([\n        { user: 7, duration: 200, equipment: ['bike'] },\n        { user: 2, duration: 200, equipment: ['treadmill'] },\n        { user: 2, duration: 200, equipment: ['bike'] },\n      ]);\n      expect(selectData(dataSmall, { minDuration: 200 })).toEqual([\n        { user: 7, duration: 200, equipment: ['bike'] },\n        { user: 2, duration: 200, equipment: ['treadmill'] },\n        { user: 2, duration: 200, equipment: ['bike'] },\n      ]);\n    });\n\n    test('high minDuration', () => {\n      expect(selectData(dataSmall, { minDuration: 400 })).toEqual([]);\n    });\n  });\n\n  describe('equipment option', () => {\n    test('no matching equipment', () => {\n      expect(selectData(dataSmall, { equipment: ['nah'] })).toEqual([]);\n    });\n\n    test('one equipment specified', () => {\n      expect(selectData(dataSmall, { equipment: ['bike'] })).toEqual([\n        { user: 7, duration: 100, equipment: ['bike', 'kettlebell'] },\n        { user: 7, duration: 200, equipment: ['bike'] },\n        { user: 2, duration: 200, equipment: ['bike'] },\n      ]);\n    });\n\n    test('multiple equipments specified', () => {\n      expect(\n        selectData(dataSmall, { equipment: ['bike', 'dumbbell'] }),\n      ).toEqual([\n        { user: 7, duration: 150, equipment: ['dumbbell', 'kettlebell'] },\n        { user: 7, duration: 100, equipment: ['bike', 'kettlebell'] },\n        { user: 7, duration: 200, equipment: ['bike'] },\n        { user: 2, duration: 200, equipment: ['bike'] },\n      ]);\n      expect(\n        selectData(dataSmall, {\n          equipment: ['bike', 'dumbbell', 'kettlebell'],\n        }),\n      ).toEqual([\n        { user: 7, duration: 150, equipment: ['dumbbell', 'kettlebell'] },\n        { user: 7, duration: 100, equipment: ['bike', 'kettlebell'] },\n        { user: 7, duration: 200, equipment: ['bike'] },\n        { user: 2, duration: 200, equipment: ['bike'] },\n      ]);\n    });\n  });\n\n  describe('merge option', () => {\n    test('without other options', () => {\n      expect(selectData(dataSmall, { merge: true })).toEqual([\n        { user: 8, duration: 50, equipment: ['bench'] },\n        { user: 1, duration: 10, equipment: ['barbell'] },\n        {\n          user: 7,\n          duration: 450,\n          equipment: ['bike', 'dumbbell', 'kettlebell'],\n        },\n        { user: 2, duration: 400, equipment: ['bike', 'treadmill'] },\n      ]);\n    });\n\n    test('with user', () => {\n      expect(selectData(dataSmall, { merge: true, user: 1 })).toEqual([\n        { user: 1, duration: 10, equipment: ['barbell'] },\n      ]);\n      expect(selectData(dataSmall, { merge: true, user: 2 })).toEqual([\n        { user: 2, duration: 400, equipment: ['bike', 'treadmill'] },\n      ]);\n      expect(selectData(dataSmall, { merge: true, user: 7 })).toEqual([\n        {\n          user: 7,\n          duration: 450,\n          equipment: ['bike', 'dumbbell', 'kettlebell'],\n        },\n      ]);\n    });\n\n    test('with minDuration', () => {\n      expect(selectData(dataSmall, { merge: true, minDuration: 1000 })).toEqual(\n        [],\n      );\n      expect(selectData(dataSmall, { merge: true, minDuration: 400 })).toEqual([\n        {\n          user: 7,\n          duration: 450,\n          equipment: ['bike', 'dumbbell', 'kettlebell'],\n        },\n        { user: 2, duration: 400, equipment: ['bike', 'treadmill'] },\n      ]);\n    });\n\n    test('with equipment', () => {\n      expect(\n        selectData(dataSmall, { merge: true, equipment: ['bike'] }),\n      ).toEqual([\n        {\n          user: 7,\n          duration: 450,\n          equipment: ['bike', 'dumbbell', 'kettlebell'],\n        },\n        { user: 2, duration: 400, equipment: ['bike', 'treadmill'] },\n      ]);\n      expect(\n        selectData(dataSmall, { merge: true, equipment: ['treadmill'] }),\n      ).toEqual([{ user: 2, duration: 400, equipment: ['bike', 'treadmill'] }]);\n      expect(\n        selectData(dataSmall, {\n          merge: true,\n          equipment: ['treadmill', 'bench', 'barbell', 'dumbbell', 'bike'],\n        }),\n      ).toEqual([\n        { user: 8, duration: 50, equipment: ['bench'] },\n        { user: 1, duration: 10, equipment: ['barbell'] },\n        {\n          user: 7,\n          duration: 450,\n          equipment: ['bike', 'dumbbell', 'kettlebell'],\n        },\n        { user: 2, duration: 400, equipment: ['bike', 'treadmill'] },\n      ]);\n    });\n\n    test('with multiple options', () => {\n      expect(\n        selectData(dataSmall, {\n          merge: true,\n          minDuration: 400,\n          equipment: ['treadmill', 'bench', 'barbell', 'dumbbell', 'bike'],\n        }),\n      ).toEqual([\n        {\n          user: 7,\n          duration: 450,\n          equipment: ['bike', 'dumbbell', 'kettlebell'],\n        },\n        { user: 2, duration: 400, equipment: ['bike', 'treadmill'] },\n      ]);\n      expect(\n        selectData(dataSmall, {\n          merge: true,\n          minDuration: 400,\n          equipment: ['treadmill'],\n        }),\n      ).toEqual([{ user: 2, duration: 400, equipment: ['bike', 'treadmill'] }]);\n    });\n  });\n});"
}