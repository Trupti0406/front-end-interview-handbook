{
  "description": "var Component=(()=>{var p=Object.create;var a=Object.defineProperty;var b=Object.getOwnPropertyDescriptor;var h=Object.getOwnPropertyNames;var u=Object.getPrototypeOf,j=Object.prototype.hasOwnProperty;var m=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),f=(n,e)=>{for(var t in e)a(n,t,{get:e[t],enumerable:!0})},r=(n,e,t,l)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let c of h(e))!j.call(n,c)&&c!==t&&a(n,c,{get:()=>e[c],enumerable:!(l=b(e,c))||l.enumerable});return n};var g=(n,e,t)=>(t=n!=null?p(u(n)):{},r(e||!n||!n.__esModule?a(t,\"default\",{value:n,enumerable:!0}):t,n)),x=n=>r(a({},\"__esModule\",{value:!0}),n);var s=m((_,i)=>{i.exports=_jsx_runtime});var C={};f(C,{default:()=>v,frontmatter:()=>y});var o=g(s()),y={title:\"Deep Clone\",excerpt:\"Implement a function that performs a deep copy of a value\"};function d(n){let e=Object.assign({p:\"p\",code:\"code\",h2:\"h2\",pre:\"pre\"},n.components);return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(e.p,{children:`The term \"deep clone\" is not formally defined in JavaScript's language specification, but is generally well understood in the community. A deep clone makes a copy of JavaScript value, leading to a completely new value that has no references pointing back to the properties in the original object (if it's an object). Any changes made to the deep-copied object will not affect the original object.`}),`\n`,(0,o.jsxs)(e.p,{children:[\"Implement a \",(0,o.jsx)(e.code,{children:\"deepClone\"}),\" function that performs a deep clone operation on JavaScript objects. You can assume the input object only contains JSON-serializable values, i.e. \",(0,o.jsx)(e.code,{children:\"null\"}),\", \",(0,o.jsx)(e.code,{children:\"boolean\"}),\", \",(0,o.jsx)(e.code,{children:\"number\"}),\", \",(0,o.jsx)(e.code,{children:\"string\"}),\", and will not contain any other built-in objects such as \",(0,o.jsx)(e.code,{children:\"Date\"}),\", \",(0,o.jsx)(e.code,{children:\"Regex\"}),\", \",(0,o.jsx)(e.code,{children:\"Map\"}),\" or \",(0,o.jsx)(e.code,{children:\"Set\"}),\".\"]}),`\n`,(0,o.jsx)(e.h2,{children:\"Examples\"}),`\n`,(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:\"language-js\",children:`const obj1 = { user: { role: 'admin' } };\nconst clonedObj1 = deepClone(obj1);\n\nclonedObj1.user.role = 'guest'; // Change the cloned user's role to 'guest'.\nclonedObj1.user.role; // 'guest'\nobj1.user.role; // Should still be 'admin'.\n\nconst obj2 = { foo: [{ bar: 'baz' }] };\nconst clonedObj2 = deepClone(obj2);\n\nobj2.foo[0].bar = 'bax'; // Modify the original object.\nobj2.foo[0].bar; // 'bax'\nclonedObj2.foo[0].bar; // Should still be 'baz'.\n`})})]})}function O(n={}){let{wrapper:e}=n.components||{};return e?(0,o.jsx)(e,Object.assign({},n,{children:(0,o.jsx)(d,n)})):d(n)}var v=O;return x(C);})();\n;return Component;",
  "format": "javascript",
  "metadata": {
    "author": "zhenghao",
    "companies": [],
    "created": 1653091200,
    "difficulty": "medium",
    "duration": 25,
    "excerpt": "Implement a function that performs a deep copy of a value",
    "featured": false,
    "format": "javascript",
    "frameworkDefault": null,
    "frameworks": [],
    "href": "/questions/javascript/deep-clone",
    "importance": "high",
    "languages": [
      "js",
      "ts"
    ],
    "nextQuestions": [
      "todo-list",
      "deep-equal",
      "deep-clone-ii"
    ],
    "premium": false,
    "published": true,
    "ranking": 100,
    "similarQuestions": [
      "deep-equal",
      "deep-clone-ii"
    ],
    "slug": "deep-clone",
    "title": "Deep Clone"
  },
  "skeleton": {
    "js": "/**\n * @param {*} value\n * @return {*}\n */\nexport default function deepClone(value) {\n  throw 'Not implemented!';\n}",
    "ts": "export default function deepClone<T>(value: T): T {\n  throw 'Not implemented!';\n}"
  },
  "solution": "var Component=(()=>{var u=Object.create;var o=Object.defineProperty;var b=Object.getOwnPropertyDescriptor;var y=Object.getOwnPropertyNames;var f=Object.getPrototypeOf,m=Object.prototype.hasOwnProperty;var j=(r,e)=>()=>(e||r((e={exports:{}}).exports,e),e.exports),v=(r,e)=>{for(var t in e)o(r,t,{get:e[t],enumerable:!0})},c=(r,e,t,l)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let i of y(e))!m.call(r,i)&&i!==t&&o(r,i,{get:()=>e[i],enumerable:!(l=b(e,i))||l.enumerable});return r};var g=(r,e,t)=>(t=r!=null?u(f(r)):{},c(e||!r||!r.__esModule?o(t,\"default\",{value:r,enumerable:!0}):t,r)),w=r=>c(o({},\"__esModule\",{value:!0}),r);var d=j((J,a)=>{a.exports=_jsx_runtime});var C={};v(C,{default:()=>k});var n=g(d());var s=MDXCodeBlock;var h=`/**\n * @param {*} value\n * @return {*}\n */\nexport default function deepClone(value) {\n  if (typeof value !== 'object' || value === null) return value;\n\n  if (Array.isArray(value)) {\n    return value.map((item) => deepClone(item));\n  }\n\n  return Object.fromEntries(\n    Object.entries(value).map(([key, value]) => [key, deepClone(value)]),\n  );\n}\n`;function p(r){let e=Object.assign({p:\"p\",code:\"code\",h2:\"h2\",h3:\"h3\",pre:\"pre\",ul:\"ul\",li:\"li\",a:\"a\"},r.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(e.p,{children:[\"Writing out a complete deep clone solution from scratch is almost impossible under typical interview constraints. In typical interview settings, the scope is fairly limited, and interviewers are more interested in how you would detect different data types and your ability to leverage various built-in APIs and \",(0,n.jsx)(e.code,{children:\"Object\"}),\" methods to traverse a given object.\"]}),`\n`,(0,n.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,n.jsxs)(e.h3,{children:[\"Solution 1: \",(0,n.jsx)(e.code,{children:\"JSON.stringify\"})]}),`\n`,(0,n.jsxs)(e.p,{children:[\"The easiest (but flawed) way to deep copy an object in JavaScript is to first serialize it and then deserialize it back via \",(0,n.jsx)(e.code,{children:\"JSON.stringify\"}),\" and \",(0,n.jsx)(e.code,{children:\"JSON.parse\"}),\".\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`const obj = { user: { role: 'admin' } };\nconst clonedObj = JSON.parse(JSON.stringify(obj)); // {user: {role: \"admin\"}}\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"Although this approach is acceptable given the input object only contains \",(0,n.jsx)(e.code,{children:\"null\"}),\", \",(0,n.jsx)(e.code,{children:\"boolean\"}),\", \",(0,n.jsx)(e.code,{children:\"number\"}),\", \",(0,n.jsx)(e.code,{children:\"string\"}),\", you should be aware of the downsides of this approach:\"]}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"We can only copy non-symbol-keyed properties whose values are supported by JSON. Unsupported data types are simply ignored.\"}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"JSON.stringify\"}),\" also has other a few surprising behaviors such as converting \",(0,n.jsx)(e.code,{children:\"Date\"}),\" objects to ISO timestamp strings, \",(0,n.jsx)(e.code,{children:\"NaN\"}),\" and \",(0,n.jsx)(e.code,{children:\"Infinity\"}),\" becoming \",(0,n.jsx)(e.code,{children:\"null\"}),\" etc.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h3,{children:\"Solution 2\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"Here is a solution that doesn't rely on \",(0,n.jsx)(e.code,{children:\"JSON.stringify\"}),\" and \",(0,n.jsx)(e.code,{children:\"JSON.parse\"}),\".\"]}),`\n`,(0,n.jsx)(s,{children:h}),`\n`,(0,n.jsx)(e.p,{children:\"There are generally two ways we can traverse an object:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Loop through the keys with the old school \",(0,n.jsx)(e.code,{children:\"for ... in\"}),\" statement.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Converting the object into an array of keys with \",(0,n.jsx)(e.code,{children:\"Object.keys\"}),\", or an array of a key-value tuple with \",(0,n.jsx)(e.code,{children:\"Object.entries\"}),\".\"]}),`\n`]}),`\n`,(0,n.jsxs)(e.p,{children:[\"With the \",(0,n.jsx)(e.code,{children:\"for ... in\"}),\" statement, inherited enumerable properties are processed as well. On the other hand, \",(0,n.jsx)(e.code,{children:\"Object.keys\"}),\" and \",(0,n.jsx)(e.code,{children:\"Object.entries\"}),\" only care about the properties directly defined on the object, and this is usually what we want.\"]}),`\n`,(0,n.jsx)(e.h2,{children:\"Edge Cases\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty#description\",children:\"Non-enumerable\"}),\" and \",(0,n.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol\",children:\"symbol-keyed\"}),\" properties are ignored.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptors\",children:\"Property descriptors\"}),\" are not respected and copied into the cloned object.\"]}),`\n`,(0,n.jsx)(e.li,{children:\"If the object has circular references, the current solution will break and cause a stack overflow by recursion into an infinite loop.\"}),`\n`,(0,n.jsx)(e.li,{children:\"The prototype is not copied.\"}),`\n`]}),`\n`,(0,n.jsxs)(e.p,{children:[\"We will address these edge cases in \",(0,n.jsx)(e.a,{href:\"/questions/javascript/deep-clone-ii\",children:\"Deep Clone II\"}),\".\"]}),`\n`,(0,n.jsx)(e.h2,{children:\"One-liner Solution\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"As of this writing, all major browsers have native support for performing deep clone via the \",(0,n.jsx)(e.code,{children:\"structuredClone\"}),\" API. Check out \",(0,n.jsx)(e.a,{href:\"https://web.dev/structured-clone/\",children:\"this article\"}),\" if you want to learn more about this API.\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`const clonedObj = structuredClone(obj);\n`})})]})}function S(r={}){let{wrapper:e}=r.components||{};return e?(0,n.jsx)(e,Object.assign({},r,{children:(0,n.jsx)(p,r)})):p(r)}var k=S;return w(C);})();\n;return Component;",
  "tests": "import deepClone from './deep-clone';\n\ndescribe('deepClone', () => {\n  test('Single primitive value', () => {\n    expect(deepClone('foo')).toEqual('foo');\n    expect(deepClone(123)).toEqual(123);\n    expect(deepClone(true)).toEqual(true);\n    expect(deepClone(false)).toEqual(false);\n    expect(deepClone(null)).toEqual(null);\n  });\n\n  test('Object with no nesting', () => {\n    const obj = { role: 'foo' };\n    const clonedObj = deepClone(obj);\n    clonedObj.role = 'bar';\n    expect(obj).toEqual({ role: 'foo' });\n  });\n\n  test('Object with one-level nesting', () => {\n    const obj = { user: { role: 'admin', id: '123' } };\n    const clonedObj = deepClone(obj);\n    clonedObj.user.role = 'bar';\n    expect(obj).toEqual({ user: { role: 'admin', id: '123' } });\n  });\n\n  test('Object with two-level nesting', () => {\n    const obj = { a: { b: { c: 'd' } }, e: 'f' };\n    const clonedObj = deepClone(obj);\n    clonedObj.a.b = {};\n    expect(obj).toEqual({ a: { b: { c: 'd' } }, e: 'f' });\n  });\n\n  test('Object with arrays', () => {\n    const obj = { foo: [{ bar: 'baz' }] };\n    const clonedObj = deepClone(obj);\n    clonedObj.foo[0].bar = 'bax';\n\n    expect(obj).toEqual({ foo: [{ bar: 'baz' }] });\n  });\n\n  test('Array with objects', () => {\n    const obj = [{ a: 'foo' }, { b: 'bar' }];\n    const clonedObj = deepClone(obj);\n    clonedObj[1].b = 'baz';\n\n    expect(obj).toEqual([{ a: 'foo' }, { b: 'bar' }]);\n  });\n\n  test('Array with nested objects', () => {\n    const obj = [{ a: { id: 'foo' } }, { b: { id: 'baz' } }];\n    const clonedObj = deepClone(obj);\n    clonedObj[1].b = { id: 'bax' };\n\n    expect(obj).toEqual([{ a: { id: 'foo' } }, { b: { id: 'baz' } }]);\n  });\n});"
}