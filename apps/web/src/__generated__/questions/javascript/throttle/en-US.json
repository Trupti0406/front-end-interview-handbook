{
  "description": "var Component=(()=>{var s=Object.create;var c=Object.defineProperty;var m=Object.getOwnPropertyDescriptor;var u=Object.getOwnPropertyNames;var f=Object.getPrototypeOf,p=Object.prototype.hasOwnProperty;var b=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),g=(n,e)=>{for(var i in e)c(n,i,{get:e[i],enumerable:!0})},a=(n,e,i,l)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let o of u(e))!p.call(n,o)&&o!==i&&c(n,o,{get:()=>e[o],enumerable:!(l=m(e,o))||l.enumerable});return n};var w=(n,e,i)=>(i=n!=null?s(f(n)):{},a(e||!n||!n.__esModule?c(i,\"default\",{value:n,enumerable:!0}):i,n)),x=n=>a(c({},\"__esModule\",{value:!0}),n);var h=b((k,r)=>{r.exports=_jsx_runtime});var y={};g(y,{default:()=>j,frontmatter:()=>v});var t=w(h()),v={title:\"Throttle\",excerpt:\"Implement a function to control the execution of a function by limiting how many times it can execute over time\"};function d(n){let e=Object.assign({p:\"p\",code:\"code\",h2:\"h2\",pre:\"pre\",ul:\"ul\",li:\"li\",a:\"a\"},n.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(e.p,{children:[\"Throttling is a technique used to control how many times we allow a function to be executed over time. When a JavaScript function is said to be throttled with a wait time of X milliseconds, it can only be invoked at most once every X milliseconds. The callback is invoked immediately and cannot be invoked again for the rest of the \",(0,t.jsx)(e.code,{children:\"wait\"}),\" duration.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"Implement a \",(0,t.jsx)(e.code,{children:\"throttle\"}),\" function which accepts a callback function and a \",(0,t.jsx)(e.code,{children:\"wait\"}),\" duration. Calling \",(0,t.jsx)(e.code,{children:\"throttle()\"}),\" returns a function which throttled invocations of the callback function following the behavior described above.\"]}),`\n`,(0,t.jsx)(e.h2,{children:\"Examples\"}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-js\",children:`let i = 0;\nfunction increment() {\n  i++;\n}\nconst throttledIncrement = throttle(increment, 100);\n\n// t = 0: Call throttledIncrement(). i is now 1.\nthrottledIncrement(); // i = 1\n\n// t = 50: Call throttledIncrement() again.\n//  i is still 1 because 100ms have not passed.\nthrottledIncrement(); // i = 1\n\n// t = 101: Call throttledIncrement() again. i is now 2.\n//  i can be incremented because it has been more than 100ms\n//  since the last throttledIncrement() call at t = 0.\nthrottledIncrement(); // i = 2\n`})}),`\n`,(0,t.jsx)(e.h2,{children:\"Follow Up\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:\"Throttle with cancel and leading/trailing options.\"}),`\n`]}),`\n`,(0,t.jsx)(e.h2,{children:\"Reading\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:\"https://lodash.com/docs/4.17.15#throttle\",children:\"Throttle on Lodash Documentation\"})}),`\n`]})]})}function I(n={}){let{wrapper:e}=n.components||{};return e?(0,t.jsx)(e,Object.assign({},n,{children:(0,t.jsx)(d,n)})):d(n)}var j=I;return x(y);})();\n;return Component;",
  "format": "javascript",
  "metadata": {
    "author": "yangshun",
    "companies": [
      "google",
      "walmart",
      "yelp"
    ],
    "created": 1649894400,
    "difficulty": "medium",
    "duration": 15,
    "excerpt": "Implement a function to control the execution of a function by limiting how many times it can execute over time",
    "featured": false,
    "format": "javascript",
    "frameworkDefault": null,
    "frameworks": [],
    "href": "/questions/javascript/throttle",
    "importance": "high",
    "languages": [
      "js",
      "ts"
    ],
    "nextQuestions": [],
    "premium": true,
    "published": true,
    "ranking": 100,
    "similarQuestions": [
      "debounce"
    ],
    "slug": "throttle",
    "subtitle": null,
    "title": "Throttle",
    "topics": []
  },
  "skeleton": {
    "js": "/**\n * @callback func\n * @param {number} wait\n * @return {Function}\n */\nexport default function throttle(func, wait) {\n  throw 'Not implemented!';\n}",
    "ts": "export default function throttle(func: Function, wait: number): Function {\n  throw 'Not implemented!';\n}"
  },
  "solution": "var Component=(()=>{var f=Object.create;var l=Object.defineProperty;var p=Object.getOwnPropertyDescriptor;var m=Object.getOwnPropertyNames;var w=Object.getPrototypeOf,g=Object.prototype.hasOwnProperty;var k=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),b=(t,e)=>{for(var i in e)l(t,i,{get:e[i],enumerable:!0})},r=(t,e,i,c)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let o of m(e))!g.call(t,o)&&o!==i&&l(t,o,{get:()=>e[o],enumerable:!(c=p(e,o))||c.enumerable});return t};var v=(t,e,i)=>(i=t!=null?f(w(t)):{},r(e||!t||!t.__esModule?l(i,\"default\",{value:t,enumerable:!0}):i,t)),y=t=>r(l({},\"__esModule\",{value:!0}),t);var a=k((C,h)=>{h.exports=_jsx_runtime});var F={};b(F,{default:()=>j});var n=v(a());var d=MDXCodeBlock;var s=`/**\n * @callback func\n * @param {number} wait\n * @return {Function}\n */\nexport default function throttle(func, wait = 0) {\n  let shouldThrottle = false;\n\n  return function (...args) {\n    if (shouldThrottle) {\n      return;\n    }\n\n    shouldThrottle = true;\n    setTimeout(function () {\n      shouldThrottle = false;\n    }, wait);\n\n    func.apply(this, args);\n  };\n}\n`;function u(t){let e=Object.assign({p:\"p\",a:\"a\",h2:\"h2\",code:\"code\",h3:\"h3\",ul:\"ul\",li:\"li\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(e.p,{children:[\"Throttle, along with \",(0,n.jsx)(e.a,{href:\"/questions/javascript/debounce\",children:\"debounce\"}),\", are among the most common front end interview questions; it's the front end equivalent of inverting a binary tree. Hence you should make sure that you are very familiar with the question.\"]}),`\n`,(0,n.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"Given that there's a \",(0,n.jsx)(e.code,{children:\"wait\"}),\" duration before the function can be invoked again, we know that we will need a timer, and \",(0,n.jsx)(e.code,{children:\"setTimeout\"}),\" is the first thing that comes to mind.\"]}),`\n`,(0,n.jsx)(e.p,{children:\"We will also need to return a function which wraps around the callback function parameter. This function needs to do a few things:\"}),`\n`,(0,n.jsx)(e.h3,{children:\"1) Throttle invocation\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"It invokes the callback function immediately and doesn't allow only invocation again until a duration of \",(0,n.jsx)(e.code,{children:\"wait\"}),\" has passed. Since we need to keep track of whether there is an existing timer, we can use a boolean variable \",(0,n.jsx)(e.code,{children:\"shouldThrottle\"}),\" to do so, which acts as a lock, preventing further invocations of the callback until the lock is released. We set \",(0,n.jsx)(e.code,{children:\"shouldThrottle\"}),\" to \",(0,n.jsx)(e.code,{children:\"true\"}),\" when the function is first called, invoke the function, and set a timeout to release the lock after \",(0,n.jsx)(e.code,{children:\"wait\"}),\". Future calls of the throttled function will not do anything if the lock is present.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h3,{children:\"2) Calls the callback function with the right parameters\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"Throttled functions are used like the original functions, so we should forward the value of \",(0,n.jsx)(e.code,{children:\"this\"}),\" and function arguments when invoking the original callback functions.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"You may be tempted to use \",(0,n.jsx)(e.code,{children:\"func(...args)\"}),\" but \",(0,n.jsx)(e.code,{children:\"this\"}),\" will be lost if callback functions are invoked that way. Hence we have use \",(0,n.jsx)(e.code,{children:\"Function.prototype.apply()\"}),\"/\",(0,n.jsx)(e.code,{children:\"Function.prototype.call()\"}),\" which allows us to specify \",(0,n.jsx)(e.code,{children:\"this\"}),\" as the first argument.\"]}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.code,{children:\"func.apply(thisArg, args)\"})}),`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.code,{children:\"func.call(thisArg, ...args)\"})}),`\n`]}),`\n`,(0,n.jsx)(d,{children:s}),`\n`,(0,n.jsx)(e.h2,{children:\"Techniques\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Using \",(0,n.jsx)(e.code,{children:\"setTimeout\"}),\".\"]}),`\n`,(0,n.jsx)(e.li,{children:\"Closures.\"}),`\n`,(0,n.jsxs)(e.li,{children:[\"How \",(0,n.jsx)(e.code,{children:\"this\"}),\" works.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Invoking functions via \",(0,n.jsx)(e.code,{children:\"Function.prototype.apply()\"}),\"/\",(0,n.jsx)(e.code,{children:\"Function.prototype.call()\"}),\".\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"Resources\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://css-tricks.com/debouncing-throttling-explained-examples/\",children:\"Debouncing and Throttling Explained Through Examples\"})}),`\n`]})]})}function x(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(u,t)})):u(t)}var j=x;return y(F);})();\n;return Component;",
  "tests": "import throttle from './throttle';\n\ndescribe('throttle', () => {\n  test('can be initialized', () => {\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    const increment = throttle(() => {}, 50);\n\n    expect(increment).toBeTruthy();\n  });\n\n  test('invokes callback immediately', () => {\n    let i = 0;\n    const increment = throttle(() => {\n      i++;\n    }, 50);\n\n    expect(i).toBe(0);\n    increment();\n    expect(i).toBe(1);\n  });\n\n  test('throttles immediate invocations', () => {\n    let i = 0;\n    const increment = throttle(() => {\n      i++;\n    }, 50);\n\n    expect(i).toBe(0);\n    increment();\n    expect(i).toBe(1);\n    increment();\n    expect(i).toBe(1);\n  });\n\n  test('throttles delayed invocations', (done) => {\n    let i = 0;\n    const increment = throttle(() => {\n      i++;\n    }, 100);\n\n    expect(i).toBe(0);\n    increment();\n    expect(i).toBe(1);\n\n    setTimeout(() => {\n      increment();\n      expect(i).toBe(1);\n    }, 25);\n\n    setTimeout(() => {\n      increment();\n      expect(i).toBe(1);\n      done();\n    }, 50);\n  });\n\n  test('uses arguments', () => {\n    let i = 21;\n    const increment = throttle((a, b) => {\n      i += a * b;\n    }, 50);\n\n    expect(i).toBe(21);\n    increment(3, 7);\n    expect(i).toBe(42);\n  });\n\n  test('can be called again after first throttling window', (done) => {\n    let i = 0;\n    const increment = throttle(() => {\n      i++;\n    }, 100);\n\n    expect(i).toBe(0);\n    increment();\n    expect(i).toBe(1);\n\n    // Should not fire yet.\n    setTimeout(() => {\n      expect(i).toBe(1);\n      increment();\n      expect(i).toBe(1);\n    }, 50);\n\n    setTimeout(() => {\n      expect(i).toBe(1);\n      increment();\n      expect(i).toBe(2);\n    }, 150);\n\n    setTimeout(() => {\n      expect(i).toBe(2);\n      increment();\n      expect(i).toBe(2);\n      done();\n    }, 200);\n  });\n\n  test('callbacks can access `this`', (done) => {\n    const increment = throttle(function (delta) {\n      this.val += delta;\n    }, 50);\n\n    const obj = {\n      val: 2,\n      increment,\n    };\n\n    expect(obj.val).toBe(2);\n    obj.increment(3);\n    expect(obj.val).toBe(5);\n\n    setTimeout(() => {\n      obj.increment(10);\n      expect(obj.val).toBe(15);\n      done();\n    }, 100);\n  });\n});"
}