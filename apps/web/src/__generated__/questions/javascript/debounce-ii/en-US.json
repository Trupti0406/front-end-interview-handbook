{
  "description": "var Component=(()=>{var h=Object.create;var i=Object.defineProperty;var u=Object.getOwnPropertyDescriptor;var m=Object.getOwnPropertyNames;var b=Object.getPrototypeOf,f=Object.prototype.hasOwnProperty;var p=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),g=(t,e)=>{for(var c in e)i(t,c,{get:e[c],enumerable:!0})},d=(t,e,c,a)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let o of m(e))!f.call(t,o)&&o!==c&&i(t,o,{get:()=>e[o],enumerable:!(a=u(e,o))||a.enumerable});return t};var v=(t,e,c)=>(c=t!=null?h(b(t)):{},d(e||!t||!t.__esModule?i(c,\"default\",{value:t,enumerable:!0}):c,t)),w=t=>d(i({},\"__esModule\",{value:!0}),t);var s=p((D,l)=>{l.exports=_jsx_runtime});var j={};g(j,{default:()=>I,frontmatter:()=>y});var n=v(s()),y={title:\"Debounce II\",excerpt:\"Implement a debounce function that comes with a cancel method to cancel delayed invocations and a flush method to immediately invoke them\"};function r(t){let e=Object.assign({p:\"p\",strong:\"strong\",a:\"a\",code:\"code\",h2:\"h2\",pre:\"pre\",ul:\"ul\",li:\"li\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.strong,{children:\"Note:\"}),\" This is an advanced version of \",(0,n.jsx)(e.a,{href:\"/questions/javascript/debounce\",children:\"Debounce\"}),\", you should complete that first before attempting this question.\"]}),`\n`,(0,n.jsx)(e.p,{children:'Debouncing is a technique used to control how many times we allow a function to be executed over time. When a JavaScript function is debounced with a wait time of X milliseconds, it must wait until after X milliseconds have elapsed since the debounced function was called. You almost certainly have encountered debouncing in your daily lives before \\u2014 when entering an elevator. Only after X duration of not pressing the \"Door open\" button (the debounced function not being called) will the elevator door actually close (the callback function is executed).'}),`\n`,(0,n.jsxs)(e.p,{children:[\"Implement a \",(0,n.jsx)(e.code,{children:\"debounce\"}),\" function which accepts a callback function and a \",(0,n.jsx)(e.code,{children:\"wait\"}),\" duration. Calling \",(0,n.jsx)(e.code,{children:\"debounce()\"}),\" returns a function which has debounces invocations of the callback function following the behavior described above.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Additionally, the \",(0,n.jsx)(e.code,{children:\"debounce\"}),\" function comes with a \",(0,n.jsx)(e.code,{children:\"cancel\"}),\" method to cancel delayed invocations and a \",(0,n.jsx)(e.code,{children:\"flush\"}),\" method to immediately invoke them.\"]}),`\n`,(0,n.jsx)(e.h2,{children:\"Examples\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`let i = 0;\nfunction increment() {\n  i++;\n}\nconst debouncedIncrement = debounce(increment, 100);\n\n// t = 0: Call debouncedIncrement().\ndebouncedIncrement(); // i = 0\n\n// t = 50: Cancel the delayed increment.\ndebouncedIncrement.cancel();\n\n// t = 100: increment() was not invoked and i is still 0.\n`})}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`let i = 0;\nfunction increment() {\n  i++;\n}\nconst debouncedIncrement = debounce(increment, 100);\n\n// t = 0: Call debouncedIncrement().\ndebouncedIncrement(); // i = 0\n\n// t = 50: i is still 0 because 100ms have not passed.\ndebouncedIncrement.flush(); // i = 0\n\n// t = 51: i is now 1 because flush causes the callback to be\n// immediately invoked.\n\n// t = 100: i is already 1. The callback has been called before\n// and won't be called again.\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.strong,{children:\"Note:\"}),\" Due to the use of delays in the tests for this question, tests can take a while to complete execution.\"]}),`\n`,(0,n.jsx)(e.h2,{children:\"Reading\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://lodash.com/docs/4.17.15#debounce\",children:\"Debounce on Lodash Documentation\"})}),`\n`]})]})}function x(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(r,t)})):r(t)}var I=x;return w(j);})();\n;return Component;",
  "format": "javascript",
  "metadata": {
    "author": null,
    "companies": [
      "flipkart",
      "google",
      "lyft",
      "walmart",
      "yelp"
    ],
    "created": 1670630400,
    "difficulty": "medium",
    "duration": 20,
    "excerpt": "Implement a debounce function that comes with a cancel method to cancel delayed invocations and a flush method to immediately invoke them",
    "featured": false,
    "format": "javascript",
    "frameworkDefault": null,
    "frameworks": [],
    "href": "/questions/javascript/debounce-ii",
    "importance": "high",
    "languages": [
      "js"
    ],
    "nextQuestions": [
      "throttle"
    ],
    "premium": true,
    "published": true,
    "ranking": 100,
    "similarQuestions": [
      "debounce",
      "throttle"
    ],
    "slug": "debounce-ii",
    "title": "Debounce II"
  },
  "skeleton": {
    "js": "/**\n * @callback func\n * @param {number} wait\n * @return {Function}\n */\nexport default function debounce(func, wait) {\n  throw 'Not implemented!';\n}",
    "ts": null
  },
  "solution": "var Component=(()=>{var f=Object.create;var o=Object.defineProperty;var m=Object.getOwnPropertyDescriptor;var p=Object.getOwnPropertyNames;var g=Object.getPrototypeOf,b=Object.prototype.hasOwnProperty;var v=(i,e)=>()=>(e||i((e={exports:{}}).exports,e),e.exports),w=(i,e)=>{for(var t in e)o(i,t,{get:e[t],enumerable:!0})},d=(i,e,t,l)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let c of p(e))!b.call(i,c)&&c!==t&&o(i,c,{get:()=>e[c],enumerable:!(l=m(e,c))||l.enumerable});return i};var k=(i,e,t)=>(t=i!=null?f(g(i)):{},d(e||!i||!i.__esModule?o(t,\"default\",{value:i,enumerable:!0}):t,i)),T=i=>d(o({},\"__esModule\",{value:!0}),i);var h=v((C,r)=>{r.exports=_jsx_runtime});var D={};w(D,{default:()=>I});var n=k(h());var a=MDXCodeBlock;var s=`/**\n * @callback func\n * @param {number} wait\n * @return {Function}\n */\nexport default function debounce(func, wait = 0) {\n  let timeoutId = null;\n  let context = undefined;\n  let argsToInvoke = undefined;\n\n  function clearTimer() {\n    clearTimeout(timeoutId);\n    timeoutId = null;\n  }\n\n  function invoke() {\n    // Don't invoke if there's no pending callback.\n    if (timeoutId == null) {\n      return;\n    }\n\n    clearTimer();\n    func.apply(context, argsToInvoke);\n  }\n\n  function fn(...args) {\n    clearTimer();\n    argsToInvoke = args;\n    context = this;\n    timeoutId = setTimeout(function () {\n      invoke();\n    }, wait);\n  }\n\n  fn.cancel = clearTimer;\n  fn.flush = invoke;\n  return fn;\n}\n`;function u(i){let e=Object.assign({p:\"p\",strong:\"strong\",a:\"a\",h2:\"h2\",code:\"code\",table:\"table\",thead:\"thead\",tr:\"tr\",th:\"th\",tbody:\"tbody\",td:\"td\",ol:\"ol\",li:\"li\",h3:\"h3\",ul:\"ul\"},i.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.strong,{children:\"Note:\"}),\" This is an advanced version of \",(0,n.jsx)(e.a,{href:\"/questions/javascript/debounce\",children:\"Debounce\"}),\", you should complete that first before attempting this question.\"]}),`\n`,(0,n.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"Observe that the function is more complicated now that we have to implement two additional methods, \",(0,n.jsx)(e.code,{children:\"cancel\"}),\" and \",(0,n.jsx)(e.code,{children:\"flush\"}),\". There's also duplicate functionality here:\"]}),`\n`,(0,n.jsxs)(e.table,{children:[(0,n.jsx)(e.thead,{children:(0,n.jsxs)(e.tr,{children:[(0,n.jsx)(e.th,{children:\"Flow\"}),(0,n.jsx)(e.th,{children:\"Cancel existing timer\"}),(0,n.jsx)(e.th,{children:\"Invoke original function\"})]})}),(0,n.jsxs)(e.tbody,{children:[(0,n.jsxs)(e.tr,{children:[(0,n.jsxs)(e.td,{children:[\"Debounced function called before \",(0,n.jsx)(e.code,{children:\"wait\"}),\" is up\"]}),(0,n.jsx)(e.td,{children:\"\\u2705\"}),(0,n.jsx)(e.td,{children:\"\\u2705\"})]}),(0,n.jsxs)(e.tr,{children:[(0,n.jsx)(e.td,{children:(0,n.jsx)(e.code,{children:\"cancel()\"})}),(0,n.jsx)(e.td,{children:\"\\u2705\"}),(0,n.jsx)(e.td,{})]}),(0,n.jsxs)(e.tr,{children:[(0,n.jsx)(e.td,{children:(0,n.jsx)(e.code,{children:\"flush()\"})}),(0,n.jsx)(e.td,{children:\"\\u2705\"}),(0,n.jsx)(e.td,{children:\"\\u2705\"})]})]})]}),`\n`,(0,n.jsx)(e.p,{children:\"We can create two helper functions:\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"invoke\"}),\" to call the original function with the latest provided arguments.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"clearTimer\"}),\" to cancel an existing timer/timeout.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h3,{children:(0,n.jsx)(e.code,{children:\"invoke\"})}),`\n`,(0,n.jsxs)(e.p,{children:[\"Unlike in the first Debounce question, the callback can be prematurely invoked via \",(0,n.jsx)(e.code,{children:\"flush()\"}),\". Once a delayed callback is \",(0,n.jsx)(e.code,{children:\"flush()\"}),\"-ed, further \",(0,n.jsx)(e.code,{children:\"flush()\"}),\"es shouldn't do anything. So we need to keep track of whether there is an existing pending callback to be invoked and we can use \",(0,n.jsx)(e.code,{children:\"timeoutId\"}),\" to do that. If \",(0,n.jsx)(e.code,{children:\"timeoutId\"}),\" is \",(0,n.jsx)(e.code,{children:\"null\"}),\", there's no pending callback. If it's a number (value returned from \",(0,n.jsx)(e.code,{children:\"setTimeout\"}),\"), then there's a pending callback.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Hence we should check if \",(0,n.jsx)(e.code,{children:\"timeoutId == null\"}),\" before we proceed with the invocations. We should also clear any existing timers.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Since \",(0,n.jsx)(e.code,{children:\"invoke\"}),\" can be called from two places (within the \",(0,n.jsx)(e.code,{children:\"setTimeout\"}),\" after a delay and manually through \",(0,n.jsx)(e.code,{children:\"flush\"}),\"), we need to save a reference to the arguments the original function needs (\",(0,n.jsx)(e.code,{children:\"this\"}),\" and the arguments) by creating two new function-level variables \",(0,n.jsx)(e.code,{children:\"context\"}),\" and \",(0,n.jsx)(e.code,{children:\"argsToInvoke\"}),\". They are written to when the debounced function is being called and when \",(0,n.jsx)(e.code,{children:\"invoke\"}),\" is being called, its values will then be used and the original function is called using \",(0,n.jsx)(e.code,{children:\"func.apply\"}),\"/\",(0,n.jsx)(e.code,{children:\"func.call\"}),\".\"]}),`\n`,(0,n.jsx)(e.h3,{children:(0,n.jsx)(e.code,{children:\"clearTimer\"})}),`\n`,(0,n.jsxs)(e.p,{children:[\"The implementation of \",(0,n.jsx)(e.code,{children:\"clearTimer\"}),\" is simple, we can do \",(0,n.jsx)(e.code,{children:\"setTimeout(timeoutId)\"}),\" and set \",(0,n.jsx)(e.code,{children:\"timeoutId\"}),\" to be \",(0,n.jsx)(e.code,{children:\"null\"}),\".\"]}),`\n`,(0,n.jsx)(a,{children:s}),`\n`,(0,n.jsx)(e.h2,{children:\"Edge Cases\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"The main pitfall in this question is invoking the callback function with the correct \",(0,n.jsx)(e.code,{children:\"this\"}),\" and the arguments. Since the callback function will be invoked by other objects, the value of \",(0,n.jsx)(e.code,{children:\"this\"}),\" will be lost. We retain a reference to \",(0,n.jsx)(e.code,{children:\"this\"}),\" outside the \",(0,n.jsx)(e.code,{children:\"setTimeout\"}),\" (by saving it in a function-level variable called \",(0,n.jsx)(e.code,{children:\"context\"}),\") and pass it into \",(0,n.jsx)(e.code,{children:\"func.apply()\"}),\"/\",(0,n.jsx)(e.code,{children:\"func.call()\"}),\" as the first argument. The same is done for the arguments the function expects.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"We should not implement \",(0,n.jsx)(e.code,{children:\"fn\"}),\" using an arrow function because the value of \",(0,n.jsx)(e.code,{children:\"this\"}),\" within arrow functions has lexical scope, i.e., it is bound to the context in which the function is created, not to the environment in which the function is called. For the other functions, it doesn't matter if we use function declarations or arrow functions.\"]}),`\n`,(0,n.jsx)(e.h2,{children:\"Techniques\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Using \",(0,n.jsx)(e.code,{children:\"setTimeout\"}),\".\"]}),`\n`,(0,n.jsx)(e.li,{children:\"Closures.\"}),`\n`,(0,n.jsxs)(e.li,{children:[\"How \",(0,n.jsx)(e.code,{children:\"this\"}),\" works.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Invoking functions via \",(0,n.jsx)(e.code,{children:\"Function.prototype.apply()\"}),\"/\",(0,n.jsx)(e.code,{children:\"Function.prototype.call()\"}),\".\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"Notes\"}),`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.code,{children:\"clearTimeout()\"}),\" is a forgiving function and passing an invalid ID to \",(0,n.jsx)(e.code,{children:\"clearTimeout()\"}),\" silently does nothing; no exception is thrown. Hence we don't have to check for \",(0,n.jsx)(e.code,{children:\"timeoutID == null\"}),\" before using \",(0,n.jsx)(e.code,{children:\"clearTimeout()\"}),\".\"]}),`\n`,(0,n.jsx)(e.h2,{children:\"Resources\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://css-tricks.com/debouncing-throttling-explained-examples/\",children:\"Debouncing and Throttling Explained Through Examples\"})}),`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://medium.com/@griffinmichl/implementing-debounce-in-javascript-eab51a12311e\",children:\"Implementing Debounce in JavaScript\"})}),`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/API/clearTimeout\",children:\"clearTimeout() - Web APIs | MDN\"})}),`\n`]})]})}function y(i={}){let{wrapper:e}=i.components||{};return e?(0,n.jsx)(e,Object.assign({},i,{children:(0,n.jsx)(u,i)})):u(i)}var I=y;return T(D);})();\n;return Component;",
  "tests": "import debounce from './debounce-ii';\n\n/* eslint-disable no-undef */\ndescribe('debounce', () => {\n  test('can be initialized', () => {\n    const increment = debounce(() => 1, 50);\n\n    expect(increment).toBeTruthy();\n  });\n\n  describe('basic functionality', () => {\n    test('executes after duration', (done) => {\n      let i = 0;\n      const increment = debounce(() => {\n        i++;\n      }, 50);\n\n      expect(i).toBe(0);\n      increment();\n      expect(i).toBe(0);\n\n      setTimeout(() => {\n        expect(i).toBe(1);\n        done();\n      }, 100);\n    });\n\n    test('uses arguments', (done) => {\n      let i = 21;\n      const increment = debounce((a, b) => {\n        i += a * b;\n      }, 50);\n\n      expect(i).toBe(21);\n      increment(3, 7);\n      expect(i).toBe(21);\n\n      setTimeout(() => {\n        expect(i).toBe(42);\n        done();\n      }, 100);\n    });\n\n    test('execute once even after calling it multiple times', (done) => {\n      let i = 0;\n      const increment = debounce(() => {\n        i++;\n      }, 50);\n\n      expect(i).toBe(0);\n      increment();\n      increment();\n      increment();\n      increment();\n      expect(i).toBe(0);\n\n      // Should not fire yet.\n      setTimeout(() => {\n        expect(i).toBe(0);\n      }, 25);\n\n      setTimeout(() => {\n        expect(i).toBe(1);\n        done();\n      }, 75);\n    });\n\n    test('duration extended if called again during window', (done) => {\n      let i = 0;\n      const increment = debounce(() => {\n        i++;\n      }, 100);\n\n      expect(i).toBe(0);\n      increment();\n      increment();\n      expect(i).toBe(0);\n\n      // Should not fire yet.\n      setTimeout(() => {\n        expect(i).toBe(0);\n        increment();\n        expect(i).toBe(0);\n      }, 50);\n\n      setTimeout(() => {\n        // Still 0 because we fired again at t=50, increment will only happen at t=150\n        expect(i).toBe(0);\n      }, 125);\n\n      setTimeout(() => {\n        expect(i).toBe(1);\n        done();\n        // Add a longer delay because the browser timer is unreliable.\n      }, 1500);\n    });\n\n    test('callbacks can access `this`', (done) => {\n      const increment = debounce(function (delta) {\n        this.val += delta;\n      }, 50);\n\n      const obj = {\n        val: 2,\n        increment,\n      };\n\n      expect(obj.val).toBe(2);\n      obj.increment(3);\n      expect(obj.val).toBe(2);\n\n      setTimeout(() => {\n        expect(obj.val).toBe(5);\n        done();\n      }, 100);\n    });\n  });\n\n  describe('cancel', () => {\n    test('immediately cancel', (done) => {\n      let i = 0;\n      const increment = debounce(() => {\n        i++;\n      }, 100);\n\n      expect(i).toBe(0);\n      increment();\n      increment();\n      expect(i).toBe(0);\n      increment.cancel();\n\n      setTimeout(() => {\n        expect(i).toBe(0);\n        done();\n        // Add a longer delay because the browser timer is unreliable.\n      }, 1500);\n    });\n\n    test('cancel after a while', (done) => {\n      let i = 0;\n      const increment = debounce(() => {\n        i++;\n      }, 200);\n\n      expect(i).toBe(0);\n      increment();\n      expect(i).toBe(0);\n\n      setTimeout(() => {\n        expect(i).toBe(0);\n        increment.cancel();\n        expect(i).toBe(0);\n      }, 50);\n\n      setTimeout(() => {\n        expect(i).toBe(0);\n        done();\n        // Add a longer delay because the browser timer is unreliable.\n      }, 500);\n    });\n\n    test('cancel after callback has fired should not crash', (done) => {\n      let i = 0;\n      const increment = debounce(() => {\n        i++;\n      }, 100);\n\n      expect(i).toBe(0);\n      increment();\n      increment();\n      expect(i).toBe(0);\n\n      setTimeout(() => {\n        expect(i).toBe(1);\n        increment.cancel();\n        expect(i).toBe(1);\n        done();\n        // Add a longer delay because the browser timer is unreliable.\n      }, 500);\n    });\n  });\n\n  describe('flush', () => {\n    test('immediately flush', (done) => {\n      let i = 0;\n      const increment = debounce(() => {\n        i++;\n      }, 100);\n\n      expect(i).toBe(0);\n      increment();\n      increment.flush();\n      expect(i).toBe(1);\n\n      setTimeout(() => {\n        expect(i).toBe(1);\n        done();\n        // Add a longer delay because the browser timer is unreliable.\n      }, 500);\n    });\n\n    test('flush after a while', (done) => {\n      let i = 0;\n      const increment = debounce(() => {\n        i++;\n      }, 200);\n\n      expect(i).toBe(0);\n      increment();\n      expect(i).toBe(0);\n\n      setTimeout(() => {\n        expect(i).toBe(0);\n        increment.flush();\n        expect(i).toBe(1);\n      }, 50);\n\n      setTimeout(() => {\n        expect(i).toBe(1);\n        done();\n        // Add a longer delay because the browser timer is unreliable.\n      }, 500);\n    });\n\n    test('flush after callback has fired should not execute', (done) => {\n      let i = 0;\n      const increment = debounce(() => {\n        i++;\n      }, 200);\n\n      expect(i).toBe(0);\n      increment();\n      expect(i).toBe(0);\n\n      setTimeout(() => {\n        expect(i).toBe(1);\n      }, 300);\n\n      setTimeout(() => {\n        expect(i).toBe(1);\n        increment.flush();\n        expect(i).toBe(1);\n        done();\n        // Add a longer delay because the browser timer is unreliable.\n      }, 500);\n    });\n\n    describe('flush should not be invoked without any delayed callbacks', (done) => {\n      test('invoked after delay', () => {\n        let i = 0;\n        const increment = debounce(() => {\n          i++;\n        }, 100);\n\n        expect(i).toBe(0);\n        increment();\n        expect(i).toBe(0);\n\n        setTimeout(() => {\n          expect(i).toBe(1);\n          increment.flush();\n          expect(i).toBe(0);\n          done();\n          // Add a longer delay because the browser timer is unreliable.\n        }, 500);\n      });\n\n      test('already flushed', () => {\n        let i = 0;\n        const increment = debounce(() => {\n          i++;\n        }, 100);\n\n        expect(i).toBe(0);\n        increment.flush();\n        expect(i).toBe(0);\n\n        setTimeout(() => {\n          increment.flush();\n          expect(i).toBe(0);\n          done();\n          // Add a longer delay because the browser timer is unreliable.\n        }, 500);\n      });\n\n      test('already cancelled', (done) => {\n        let i = 0;\n        const increment = debounce(() => {\n          i++;\n        }, 500);\n\n        expect(i).toBe(0);\n        increment();\n        increment.cancel();\n        expect(i).toBe(0);\n\n        setTimeout(() => {\n          increment.flush();\n          expect(i).toBe(0);\n          done();\n        }, 200);\n      });\n    });\n  });\n});"
}