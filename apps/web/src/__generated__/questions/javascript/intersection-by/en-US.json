{
  "description": "var Component=(()=>{var d=Object.create;var i=Object.defineProperty;var u=Object.getOwnPropertyDescriptor;var p=Object.getOwnPropertyNames;var m=Object.getPrototypeOf,y=Object.prototype.hasOwnProperty;var f=(r,e)=>()=>(e||r((e={exports:{}}).exports,e),e.exports),g=(r,e)=>{for(var t in e)i(r,t,{get:e[t],enumerable:!0})},c=(r,e,t,l)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let a of p(e))!y.call(r,a)&&a!==t&&i(r,a,{get:()=>e[a],enumerable:!(l=u(e,a))||l.enumerable});return r};var v=(r,e,t)=>(t=r!=null?d(m(r)):{},c(e||!r||!r.__esModule?i(t,\"default\",{value:r,enumerable:!0}):t,r)),b=r=>c(i({},\"__esModule\",{value:!0}),r);var s=f((I,o)=>{o.exports=_jsx_runtime});var B={};g(B,{default:()=>w,frontmatter:()=>x});var n=v(s()),x={title:\"Intersection By\",excerpt:\"Implement a function that returns an array of unique values that are included in all given arrays based on a provided iteratee function.\"};function h(r){let e=Object.assign({p:\"p\",code:\"code\",pre:\"pre\",h2:\"h2\",ol:\"ol\",li:\"li\",em:\"em\",ul:\"ul\",a:\"a\"},r.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(e.p,{children:[\"The \",(0,n.jsx)(e.code,{children:\"intersectionBy\"}),\" function takes an \",(0,n.jsx)(e.code,{children:\"iteratee\"}),\" function and multiple arrays as arguments. It creates an array of unique values that are included in all given arrays based on the result of applying the iteratee function to each value.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"The iteratee function is invoked with one argument: \",(0,n.jsx)(e.code,{children:\"value\"}),\", where value is the current value being iterated.\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`intersectionBy(iteratee, ...arrays);\n`})}),`\n`,(0,n.jsx)(e.h2,{children:\"Arguments\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"iteratee\"}),\" \",(0,n.jsx)(e.em,{children:\"(Function)\"}),\": The iteratee invoked per element.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"arrays\"}),\" \",(0,n.jsx)(e.em,{children:\"(Array)\"}),\": The arrays to inspect.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"Returns\"}),`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.em,{children:\"(Array)\"}),\": Returns the new array of intersecting values.\"]}),`\n`,(0,n.jsx)(e.h2,{children:\"Examples\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`// Get the intersection based on the floor value of each number\nconst result = intersectionBy(Math.floor, [1.2, 2.4], [2.5, 3.6]); // => [2]\n\n// Get the intersection based on the lowercase value of each string\nconst result2 = intersectionBy(\n  (str) => str.toLowerCase(),\n  ['apple', 'banana', 'orange'],\n  ['Apple', 'Banana', 'Orange'],\n);\n// => ['apple']\n`})}),`\n`,(0,n.jsx)(e.h2,{children:\"Notes\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"In Lodash, \",(0,n.jsx)(e.code,{children:\"iteratee\"}),\" is optional and is the last parameter, but in this question it is a required parameter for simplicity.\"]}),`\n`,(0,n.jsx)(e.li,{children:\"The order of elements in the resulting array is determined by the order in which they appear in the first array.\"}),`\n`,(0,n.jsx)(e.li,{children:\"If no arrays are provided, the function will return an empty array.\"}),`\n`,(0,n.jsx)(e.li,{children:\"If any of the arrays are empty, the function will return an empty array.\"}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"Resources\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:(0,n.jsxs)(e.a,{href:\"https://lodash.com/docs/#intersectionBy\",children:[\"Lodash \",(0,n.jsx)(e.code,{children:\"_.intersectionBy\"})]})}),`\n`]})]})}function j(r={}){let{wrapper:e}=r.components||{};return e?(0,n.jsx)(e,Object.assign({},r,{children:(0,n.jsx)(h,r)})):h(r)}var w=j;return b(B);})();\n;return Component;",
  "format": "javascript",
  "metadata": {
    "author": null,
    "companies": [],
    "created": 1687651200,
    "difficulty": "medium",
    "duration": 15,
    "excerpt": "Implement a function that returns an array of unique values that are included in all given arrays based on a provided iteratee function.",
    "featured": false,
    "format": "javascript",
    "frameworkDefault": null,
    "frameworks": [],
    "href": "/questions/javascript/intersection-by",
    "importance": "low",
    "languages": [
      "js",
      "ts"
    ],
    "nextQuestions": [],
    "premium": true,
    "published": true,
    "ranking": 100,
    "similarQuestions": [
      "intersection",
      "intersection-with"
    ],
    "slug": "intersection-by",
    "subtitle": null,
    "title": "Intersection By",
    "topics": []
  },
  "skeleton": {
    "js": "/**\n * Computes the intersection of arrays, returning a new array containing unique values present in all given arrays\n * based on the result of applying an iteratee function to each value.\n *\n * @param {Function} iteratee - The iteratee function to apply to each value.\n * @param {Array[]} arrays - The arrays to perform the intersection on.\n * @returns {Array} - A new array containing the unique values present in all given arrays.\n */\nexport default function intersectionBy(iteratee, ...arrays) {\n  throw 'Not implemented!';\n}",
    "ts": "export default function intersectionBy<T, R>(\n  iteratee: (value: T) => R,\n  ...arrays: T[][]\n): R[] {\n  throw 'Not implemented!';\n}"
  },
  "solution": "var Component=(()=>{var d=Object.create;var i=Object.defineProperty;var y=Object.getOwnPropertyDescriptor;var m=Object.getOwnPropertyNames;var f=Object.getPrototypeOf,v=Object.prototype.hasOwnProperty;var g=(r,e)=>()=>(e||r((e={exports:{}}).exports,e),e.exports),x=(r,e)=>{for(var a in e)i(r,a,{get:e[a],enumerable:!0})},o=(r,e,a,s)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let n of m(e))!v.call(r,n)&&n!==a&&i(r,n,{get:()=>e[n],enumerable:!(s=y(e,n))||s.enumerable});return r};var A=(r,e,a)=>(a=r!=null?d(f(r)):{},o(e||!r||!r.__esModule?i(a,\"default\",{value:r,enumerable:!0}):a,r)),_=r=>o(i({},\"__esModule\",{value:!0}),r);var c=g((D,l)=>{l.exports=_jsx_runtime});var M={};x(M,{default:()=>C});var t=A(c());var u=MDXCodeBlock;var p=`/**\n * Computes the intersection of arrays, returning a new array containing unique values present in all given arrays\n * based on the result of applying an iteratee function to each value.\n *\n * @param {Function} iteratee [iteratee=_.identity] - The iteratee function to apply to each value.\n * @param {Array[]} arrays - The arrays to perform the intersection on.\n * @returns {Array} - A new array containing the unique values present in all given arrays.\n */\nexport default function intersectionBy(iteratee, ...arrays) {\n  if (arrays.length === 0) {\n    return [];\n  }\n\n  const mappedArrays = arrays.map((array) => array.map(iteratee));\n  const intersectedValues = mappedArrays[0].filter((value) => {\n    return mappedArrays.every((mappedArray) => mappedArray.includes(value));\n  });\n\n  return intersectedValues.map((value) => {\n    const index = mappedArrays[0].indexOf(value);\n    return arrays[0][index];\n  });\n}\n`;function h(r){let e=Object.assign({h2:\"h2\",p:\"p\",ul:\"ul\",li:\"li\",a:\"a\",code:\"code\"},r.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,t.jsx)(u,{children:p}),`\n`,(0,t.jsx)(e.p,{children:\"The solution first maps each array using the iteratee function to transform the values. Then, it filters the values from the first mapped array that are present in all the other mapped arrays. Finally, it maps the intersected values back to the original values from the first array.\"}),`\n`,(0,t.jsx)(e.h2,{children:\"Resources\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:(0,t.jsxs)(e.a,{href:\"https://lodash.com/docs/#intersectionBy\",children:[\"Lodash \",(0,t.jsx)(e.code,{children:\"_.intersectionBy\"})]})}),`\n`]})]})}function B(r={}){let{wrapper:e}=r.components||{};return e?(0,t.jsx)(e,Object.assign({},r,{children:(0,t.jsx)(h,r)})):h(r)}var C=B;return _(M);})();\n;return Component;",
  "tests": "import intersectionBy from './intersection-by';\n\ndescribe('intersectionBy', () => {\n  test('should handle empty arrays', () => {\n    const arr1 = [];\n    const arr2 = [1, 2, 3];\n    const arr3 = [];\n    const iteratee = String;\n\n    expect(intersectionBy(iteratee, arr1, arr2, arr3)).toEqual([]);\n  });\n\n  test('should return the intersection of arrays based on iteratee function', () => {\n    const arr1 = [2.1, 1.2];\n    const arr2 = [2.3, 3.4];\n    const arr3 = [4.5, 2.6];\n    const iteratee = Math.floor;\n\n    expect(intersectionBy(iteratee, arr1, arr2, arr3)).toEqual([2.1]);\n  });\n\n  test('should handle arrays with no intersection', () => {\n    const arr1 = [1, 2, 3];\n    const arr2 = [4, 5, 6];\n    const arr3 = [7, 8, 9];\n    const iteratee = String;\n\n    expect(intersectionBy(iteratee, arr1, arr2, arr3)).toEqual([]);\n  });\n\n  test('should handle arrays with multiple intersections', () => {\n    const arr1 = [1.2, 2.3, 3.4];\n    const arr2 = [2.1, 1.2, 4.5];\n    const arr3 = [1.2, 4.5, 2.3, 3.4];\n    const iteratee = Math.floor;\n\n    expect(intersectionBy(iteratee, arr1, arr2, arr3)).toEqual([1.2, 2.3]);\n  });\n\n  test('should handle arrays with non-primitive values', () => {\n    const obj1 = { id: 1 };\n    const obj2 = { id: 2 };\n    const obj3 = { id: 3 };\n    const arr1 = [obj1, obj2];\n    const arr2 = [obj2, obj3];\n    const iteratee = (obj) => obj.id;\n\n    expect(intersectionBy(iteratee, arr1, arr2)).toEqual([obj2]);\n  });\n\n  it('should handle arrays with different iteratee values', () => {\n    const arr1 = ['apple', 'banana', 'pear'];\n    const arr2 = ['orange', 'kiwi', 'banana'];\n    const arr3 = ['grape', 'pear', 'watermelon'];\n    const iteratee = (value) => value.length;\n\n    expect(intersectionBy(iteratee, arr1, arr2, arr3)).toEqual(['pear']);\n  });\n});"
}