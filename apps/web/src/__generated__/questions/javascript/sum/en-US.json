{
  "description": "var Component=(()=>{var i=Object.create;var s=Object.defineProperty;var h=Object.getOwnPropertyDescriptor;var d=Object.getOwnPropertyNames;var p=Object.getPrototypeOf,g=Object.prototype.hasOwnProperty;var f=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),x=(n,e)=>{for(var a in e)s(n,a,{get:e[a],enumerable:!0})},o=(n,e,a,c)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let r of d(e))!g.call(n,r)&&r!==a&&s(n,r,{get:()=>e[r],enumerable:!(c=h(e,r))||c.enumerable});return n};var b=(n,e,a)=>(a=n!=null?i(p(n)):{},o(e||!n||!n.__esModule?s(a,\"default\",{value:n,enumerable:!0}):a,n)),j=n=>o(s({},\"__esModule\",{value:!0}),n);var m=f((D,l)=>{l.exports=_jsx_runtime});var C={};x(C,{default:()=>y,frontmatter:()=>w});var t=b(m()),w={title:\"Sum\",excerpt:\"Implement a function that sums numbers by accepting a number and allows for repeated calling with more numbers until it is not called with any number\"};function u(n){let e=Object.assign({p:\"p\",code:\"code\",h2:\"h2\",pre:\"pre\"},n.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(e.p,{children:[\"Implement a \",(0,t.jsx)(e.code,{children:\"sum\"}),\" function that accepts a number and allows for repeated calling with more numbers. Calling the function without an argument will sum up all the arguments thus far and return the total.\"]}),`\n`,(0,t.jsx)(e.h2,{children:\"Examples\"}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-js\",children:`sum(1)(); // 1\nsum(1)(2)(); // 3\nsum(1)(2)(-3)(); // 0\n`})})]})}function _(n={}){let{wrapper:e}=n.components||{};return e?(0,t.jsx)(e,Object.assign({},n,{children:(0,t.jsx)(u,n)})):u(n)}var y=_;return j(C);})();\n;return Component;",
  "format": "javascript",
  "metadata": {
    "author": "yangshun",
    "companies": [
      "amazon"
    ],
    "created": 1655251200,
    "difficulty": "easy",
    "duration": 15,
    "excerpt": "Implement a function that sums numbers by accepting a number and allows for repeated calling with more numbers until it is not called with any number",
    "featured": false,
    "format": "javascript",
    "frameworkDefault": null,
    "frameworks": [],
    "href": "/questions/javascript/sum",
    "importance": "low",
    "languages": [
      "js",
      "ts"
    ],
    "nextQuestions": [],
    "premium": true,
    "published": true,
    "ranking": 100,
    "similarQuestions": [
      "curry",
      "curry-ii"
    ],
    "slug": "sum",
    "title": "Sum"
  },
  "skeleton": {
    "js": "/**\n * @param {number} number\n * @return {Function}\n */\nexport default function sum(number) {\n  throw 'Not implemented!';\n}",
    "ts": "type SumResult = (value: undefined | number) => number | SumResult;\n\nexport default function sum(value: number | undefined): SumResult {\n  throw 'Not implemented!';\n}"
  },
  "solution": "var Component=(()=>{var m=Object.create;var o=Object.defineProperty;var b=Object.getOwnPropertyDescriptor;var w=Object.getOwnPropertyNames;var g=Object.getPrototypeOf,p=Object.prototype.hasOwnProperty;var x=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),v=(t,e)=>{for(var r in e)o(t,r,{get:e[r],enumerable:!0})},u=(t,e,r,c)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let i of w(e))!p.call(t,i)&&i!==r&&o(t,i,{get:()=>e[i],enumerable:!(c=b(e,i))||c.enumerable});return t};var j=(t,e,r)=>(r=t!=null?m(g(t)):{},u(e||!t||!t.__esModule?o(r,\"default\",{value:t,enumerable:!0}):r,t)),T=t=>u(o({},\"__esModule\",{value:!0}),t);var a=x((W,l)=>{l.exports=_jsx_runtime});var B={};v(B,{default:()=>A});var n=j(a());var s=MDXCodeBlock;var d=`/**\n * @param {number} number\n * @return {Function}\n */\nexport default function sum(numberA) {\n  return function (numberB) {\n    return numberB === undefined ? numberA : sum(numberA + numberB);\n  };\n}\n`;var h=`const sum = (a) => (b) => b !== undefined ? sum(a + b) : a;\nexport default sum;\n`;function f(t){let e=Object.assign({p:\"p\",h2:\"h2\",ul:\"ul\",li:\"li\",code:\"code\",h3:\"h3\",pre:\"pre\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.p,{children:\"This question evaluates your understanding of closures and first-class functions - functions in JavaScript are variables that can be returned and passed into other functions as arguments.\"}),`\n`,(0,n.jsx)(e.h2,{children:\"Clarification Questions\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"What if we call \",(0,n.jsx)(e.code,{children:\"sum()\"}),\" at the start without any arguments?\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"We won't test this case. But we recommend throwing an \",(0,n.jsx)(e.code,{children:\"Error\"}),\".\"]}),`\n`]}),`\n`]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"The \",(0,n.jsx)(e.code,{children:\"sum\"}),\" function returns functions until it is called without any arguments, then it will return the total sum so far. Since we need to retain a running sum of the values added so far, we will need a variable to do that. How do we achieve that without classes? We can use closures.\"]}),`\n`,(0,n.jsx)(e.p,{children:\"A closure is the combination of a function bundled together with references to its lexical environment (surrounding state). We can make use of closures to keep a reference to the running total.\"}),`\n`,(0,n.jsx)(e.p,{children:\"We declare an inner function that will be returned for subsequent calls to the function. That function will determine if there's a value being passed in. If there is, we add to the running total and return itself so that subsequent calls can be made, otherwise we return the running total.\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"We can check for the presence of an argument by using \",(0,n.jsx)(e.code,{children:\"argument === undefined\"}),\". Note that we shouldn't be using \",(0,n.jsx)(e.code,{children:\"==\"}),\" here because \",(0,n.jsx)(e.code,{children:\"null == undefined\"}),\" is \",(0,n.jsx)(e.code,{children:\"true\"}),\".\"]}),`\n`,(0,n.jsx)(s,{children:d}),`\n`,(0,n.jsx)(e.h3,{children:\"One-liner using Arrow Functions\"}),`\n`,(0,n.jsx)(e.p,{children:\"Using arrow functions, this function can be written in a single line.\"}),`\n`,(0,n.jsx)(s,{children:h}),`\n`,(0,n.jsx)(e.h2,{children:\"Edge Cases\"}),`\n`,(0,n.jsx)(e.p,{children:\"Intermediate results should be able to be used again for separate evaluations.\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`const addTwo = sum(2);\naddTwo(3)(); // 5\naddTwo(4)(); // 6\naddTwo(3)(4)(); // 9\n`})}),`\n`,(0,n.jsx)(e.h2,{children:\"Techniques\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Closures\"}),`\n`,(0,n.jsx)(e.li,{children:\"First-class functions\"}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"null\"}),\" vs \",(0,n.jsx)(e.code,{children:\"undefined\"})]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"Notes\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Do not use \",(0,n.jsx)(e.code,{children:\"==\"}),\" to check for presence of an argument because \",(0,n.jsx)(e.code,{children:\"null == undefined\"}),\" is \",(0,n.jsx)(e.code,{children:\"true\"}),\".\"]}),`\n`]})]})}function k(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(f,t)})):f(t)}var A=k;return T(B);})();\n;return Component;",
  "tests": "import sum from './sum';\n\ndescribe('sum', () => {\n  test('one number', () => {\n    expect(sum(1)()).toBe(1);\n    expect(sum(-1)()).toBe(-1);\n  });\n\n  test('two numbers', () => {\n    expect(sum(1)(2)()).toBe(3);\n    expect(sum(89)(11)()).toBe(100);\n    expect(sum(-1)(-2)()).toBe(-3);\n  });\n\n  test('zero works', () => {\n    expect(sum(0)(0)(0)()).toBe(0);\n    expect(sum(1)(2)(0)()).toBe(3);\n    expect(sum(1)(0)(89)(10)()).toBe(100);\n    expect(sum(-1)(0)(-2)()).toBe(-3);\n  });\n\n  test('negative numbers', () => {\n    expect(sum(-1)(-2)()).toBe(-3);\n    expect(sum(-89)(-2)()).toBe(-91);\n    expect(sum(-42)(42)()).toBe(0);\n  });\n\n  test('returns function if not terminated', () => {\n    expect(sum(1)).toBeInstanceOf(Function);\n    expect(sum(1)(2)).toBeInstanceOf(Function);\n    expect(sum(1)(2)(3)).toBeInstanceOf(Function);\n  });\n\n  test('can be reused', () => {\n    const addTwo = sum(2);\n    expect(addTwo(3)()).toBe(5);\n    expect(addTwo(4)()).toBe(6);\n    expect(addTwo(3)(4)()).toBe(9);\n  });\n});"
}