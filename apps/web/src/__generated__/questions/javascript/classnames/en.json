{
  "description": "var Component=(()=>{var d=Object.create;var o=Object.defineProperty;var m=Object.getOwnPropertyDescriptor;var h=Object.getOwnPropertyNames;var f=Object.getPrototypeOf,b=Object.prototype.hasOwnProperty;var p=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),g=(n,e)=>{for(var s in e)o(n,s,{get:e[s],enumerable:!0})},c=(n,e,s,l)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let r of h(e))!b.call(n,r)&&r!==s&&o(n,r,{get:()=>e[r],enumerable:!(l=m(e,r))||l.enumerable});return n};var x=(n,e,s)=>(s=n!=null?d(f(n)):{},c(e||!n||!n.__esModule?o(s,\"default\",{value:n,enumerable:!0}):s,n)),N=n=>c(o({},\"__esModule\",{value:!0}),n);var i=p((q,t)=>{t.exports=_jsx_runtime});var v={};g(v,{default:()=>_,frontmatter:()=>j});var a=x(i()),j={title:\"Classnames\",excerpt:\"Implement a function which conditionally joins CSS class names together\"};function u(n){let e=Object.assign({p:\"p\",a:\"a\",code:\"code\",h2:\"h2\",pre:\"pre\"},n.components);return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.a,{href:\"https://github.com/JedWatson/classnames\",children:(0,a.jsx)(e.code,{children:\"classnames\"})}),\" is a commonly used utility in modern front end applications to conditionally join CSS class names together. If you've written React or Vue applications, you likely have used a library like this.\"]}),`\n`,(0,a.jsxs)(e.p,{children:[\"Implement the \",(0,a.jsx)(e.code,{children:\"classnames\"}),\" function.\"]}),`\n`,(0,a.jsx)(e.h2,{children:\"Examples\"}),`\n`,(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:\"language-js\",children:`classNames('foo', 'bar'); // 'foo bar'\nclassNames('foo', { bar: true }); // 'foo bar'\nclassNames({ 'foo-bar': true }); // 'foo-bar'\nclassNames({ 'foo-bar': false }); // ''\nclassNames({ foo: true }, { bar: true }); // 'foo bar'\nclassNames({ foo: true, bar: true }); // 'foo bar'\nclassNames({ foo: true, bar: false, qux: true }); // 'foo qux'\n`})}),`\n`,(0,a.jsx)(e.p,{children:\"Arrays will be recursively flattened as per the rules above.\"}),`\n`,(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:\"language-js\",children:`classNames('a', ['b', { c: true, d: false }]); // 'a b c'\n`})}),`\n`,(0,a.jsx)(e.p,{children:\"Values can be mixed.\"}),`\n`,(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:\"language-js\",children:`classNames(\n  'foo',\n  {\n    bar: true,\n    duck: false,\n  },\n  'baz',\n  { quux: true },\n); // 'foo bar baz quux'\n`})}),`\n`,(0,a.jsx)(e.p,{children:\"Falsey values are ignored.\"}),`\n`,(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:\"language-js\",children:`classNames(null, false, 'bar', undefined, 0, 1, { baz: null }, ''); // 'bar 1'\n`})})]})}function y(n={}){let{wrapper:e}=n.components||{};return e?(0,a.jsx)(e,Object.assign({},n,{children:(0,a.jsx)(u,n)})):u(n)}var _=y;return N(v);})();\n;return Component;",
  "format": "javascript",
  "metadata": {
    "author": null,
    "companies": [
      "facebook"
    ],
    "created": 1651449600,
    "difficulty": "medium",
    "duration": 20,
    "excerpt": "Implement a function which conditionally joins CSS class names together",
    "featured": false,
    "format": "javascript",
    "frameworkDefault": null,
    "frameworks": [],
    "href": "/questions/javascript/classnames",
    "importance": "mid",
    "languages": [
      "css",
      "js"
    ],
    "nextQuestions": [],
    "premium": true,
    "published": true,
    "ranking": 100,
    "similarQuestions": [],
    "slug": "classnames",
    "title": "Classnames"
  },
  "skeleton": "/**\n * @param {...(string|Object|Array<string|Object>)} args\n * @return {string}\n */\nexport default function classNames(...args) {\n  throw 'Not implemented!';\n}",
  "solution": "var Component=(()=>{var f=Object.create;var a=Object.defineProperty;var g=Object.getOwnPropertyDescriptor;var y=Object.getOwnPropertyNames;var m=Object.getPrototypeOf,b=Object.prototype.hasOwnProperty;var v=(r,e)=>()=>(e||r((e={exports:{}}).exports,e),e.exports),w=(r,e)=>{for(var s in e)a(r,s,{get:e[s],enumerable:!0})},c=(r,e,s,t)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let i of y(e))!b.call(r,i)&&i!==s&&a(r,i,{get:()=>e[i],enumerable:!(t=g(e,i))||t.enumerable});return r};var j=(r,e,s)=>(s=r!=null?f(m(r)):{},c(e||!r||!r.__esModule?a(s,\"default\",{value:r,enumerable:!0}):s,r)),k=r=>c(a({},\"__esModule\",{value:!0}),r);var h=v((N,o)=>{o.exports=_jsx_runtime});var S={};w(S,{default:()=>O});var n=j(h());var l=MDXCodeBlock;var d=`/**\n * @param {...(string|Object|Array<string|Object>)} args\n * @return {string}\n */\nexport default function classNames(...args) {\n  const classes = [];\n\n  args.forEach((arg) => {\n    // Ignore falsey values.\n    if (!arg) {\n      return;\n    }\n\n    const argType = typeof arg;\n\n    // Handle string and numbers.\n    if (argType === 'string' || argType === 'number') {\n      classes.push(arg);\n      return;\n    }\n\n    // Handle arrays.\n    if (Array.isArray(arg)) {\n      classes.push(classNames(...arg));\n      return;\n    }\n\n    // Handle objects.\n    if (argType === 'object') {\n      for (const key in arg) {\n        if (Object.hasOwn(arg, key) && arg[key]) {\n          classes.push(key);\n        }\n      }\n\n      return;\n    }\n  });\n\n  return classes.join(' ');\n}\n`;var u=`var hasOwn = {}.hasOwnProperty;\n\nexport default function classNames() {\n  var classes = [];\n\n  for (var i = 0; i < arguments.length; i++) {\n    var arg = arguments[i];\n    if (!arg) continue;\n\n    var argType = typeof arg;\n\n    if (argType === 'string' || argType === 'number') {\n      classes.push(arg);\n    } else if (Array.isArray(arg)) {\n      if (arg.length) {\n        var inner = classNames.apply(null, arg);\n        if (inner) {\n          classes.push(inner);\n        }\n      }\n    } else if (argType === 'object') {\n      if (arg.toString === Object.prototype.toString) {\n        for (var key in arg) {\n          if (hasOwn.call(arg, key) && arg[key]) {\n            classes.push(key);\n          }\n        }\n      } else {\n        classes.push(arg.toString());\n      }\n    }\n  }\n\n  return classes.join(' ');\n}\n`;function p(r){let e=Object.assign({h2:\"h2\",p:\"p\",ol:\"ol\",li:\"li\",code:\"code\",ul:\"ul\",strong:\"strong\",a:\"a\"},r.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,n.jsx)(e.p,{children:\"The tricky part of this solution is in the recursive nature of the function. Hence we can separate out the solution into two parts:\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Handling of each data type\"}),`\n`,(0,n.jsx)(e.li,{children:\"Recursing for array type\"}),`\n`]}),`\n`,(0,n.jsxs)(e.p,{children:[\"We will need a data structure, \",(0,n.jsx)(e.code,{children:\"classes\"}),\" to collect all the classes for the lifetime of the function that the recursive calls have access to. This can either be defined as a variable in the top level of the function, or the variable can be passed as an argument into the recursive calls. In our solution we use an \",(0,n.jsx)(e.code,{children:\"Array\"}),\", but you could use a \",(0,n.jsx)(e.code,{children:\"Set\"}),\".\"]}),`\n`,(0,n.jsx)(e.p,{children:\"Here's how we will handle each data type:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Falsey values\"}),\": Ignore\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"String\"}),\": Add it to the \",(0,n.jsx)(e.code,{children:\"classes\"}),\" collection\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Number\"}),\": Add it to the \",(0,n.jsx)(e.code,{children:\"classes\"}),\" collection\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Array\"}),\": Invoke the \",(0,n.jsx)(e.code,{children:\"classNames\"}),\" function recursively\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Object\"}),\": Loop through the key/value pairs and add the keys with truthy values into the \",(0,n.jsx)(e.code,{children:\"classes\"}),\" collection\"]}),`\n`]}),`\n`,(0,n.jsx)(l,{children:d}),`\n`,(0,n.jsx)(e.h2,{children:\"Follow Up: De-duplicating classes\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"The provided solution doesn't handle de-duplicating classes, which would be a nice optimization and in some cases affect the output, for example, if \",(0,n.jsx)(e.code,{children:\"{ foo: true }\"}),\" and \",(0,n.jsx)(e.code,{children:\"{ foo: false }\"}),\" are present at the same time and \",(0,n.jsx)(e.code,{children:\"false\"}),\" appears later in the arguments.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"This can be handled by using \",(0,n.jsx)(e.code,{children:\"Set\"}),\" to collect the classes from the start, or de-duplicating the final array of classes by turning into a \",(0,n.jsx)(e.code,{children:\"Set\"}),\". De-duplicating classes is usually out of the scope of interviews but is a possible follow-up question.\"]}),`\n`,(0,n.jsx)(e.h2,{children:\"Techniques\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Familiar with JavaScript value types and how to check for them\"}),`\n`,(0,n.jsx)(e.li,{children:\"Recursion\"}),`\n`,(0,n.jsxs)(e.li,{children:[\"Converting from \",(0,n.jsx)(e.code,{children:\"Array\"}),\"s to \",(0,n.jsx)(e.code,{children:\"Set\"}),\"s and vice versa (for the unique classes follow-up)\"]}),`\n`,(0,n.jsx)(e.li,{children:\"Handling of variadic arguments\"}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"Notes\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"typeof []\"}),\" gives \",(0,n.jsx)(e.code,{children:\"'object'\"}),\", so you need to handle arrays before objects.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"You likely don't have to handle these scenario, but you should mention them:\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Possibility of stack overflow. This applies to any recursive solution.\"}),`\n`,(0,n.jsx)(e.li,{children:\"Possibility of circular references for arrays and objects. This applies to any input which has arbitrary depth.\"}),`\n`]}),`\n`]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"Library implementation\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"For reference, this is how the \",(0,n.jsx)(e.code,{children:\"classnames\"}),\" library is implemented.\"]}),`\n`,(0,n.jsx)(l,{children:u}),`\n`,(0,n.jsx)(e.h2,{children:\"Resources\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:(0,n.jsxs)(e.a,{href:\"https://github.com/JedWatson/classnames\",children:[(0,n.jsx)(e.code,{children:\"classnames\"}),\" library on GitHub\"]})}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsxs)(e.a,{href:\"https://github.com/lukeed/clsx\",children:[(0,n.jsx)(e.code,{children:\"clsx\"}),\" library on GitHub\"]}),\" - A newer version which serves as a faster and smaller drop-in replacement for \",(0,n.jsx)(e.code,{children:\"classnames\"}),\".\"]}),`\n`]})]})}function A(r={}){let{wrapper:e}=r.components||{};return e?(0,n.jsx)(e,Object.assign({},r,{children:(0,n.jsx)(p,r)})):p(r)}var O=A;return k(S);})();\n;return Component;",
  "tests": "import classNames from './classnames';\n\n/* eslint-disable no-undef */\ndescribe('classNames', () => {\n  test('empty values', () => {\n    expect(classNames([])).toEqual('');\n  });\n\n  test('single value', () => {\n    expect(classNames('foo')).toEqual('foo');\n  });\n\n  test('two values', () => {\n    expect(classNames('foo', 'bar')).toEqual('foo bar');\n  });\n\n  test('array values', () => {\n    expect(classNames(['foo', 'bar', 'baz'])).toEqual('foo bar baz');\n  });\n\n  test('object values', () => {\n    expect(classNames({ 'foo-bar': true })).toEqual('foo-bar');\n    expect(classNames({ 'foo-bar': false })).toEqual('');\n    expect(classNames({ foo: true }, { bar: true })).toEqual('foo bar');\n    expect(classNames({ foo: true, bar: false, qux: true })).toEqual('foo qux');\n  });\n\n  test('mixed values', () => {\n    expect(\n      classNames(\n        'foo',\n        {\n          bar: true,\n          duck: false,\n        },\n        'baz',\n        { quux: true },\n      ),\n    ).toEqual('foo bar baz quux');\n    expect(\n      classNames('boo', true && 'loo', false && 'booz', {\n        foo: true,\n        bar: false,\n        baz: 1,\n      }),\n    ).toEqual('boo loo foo baz');\n  });\n\n  test('ignores falsey values', () => {\n    expect(\n      classNames(null, false, 'bar', undefined, 0, 1, { baz: null }, ''),\n    ).toEqual('bar 1');\n  });\n\n  test('recursively flattens arrays', () => {\n    expect(classNames('a', ['b', { c: true, d: false }])).toEqual('a b c');\n    expect(classNames('a', ['b', ['c', ['d']]])).toEqual('a b c d');\n  });\n});"
}