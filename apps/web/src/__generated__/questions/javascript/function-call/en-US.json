{
  "description": "var Component=(()=>{var h=Object.create;var c=Object.defineProperty;var u=Object.getOwnPropertyDescriptor;var m=Object.getOwnPropertyNames;var s=Object.getPrototypeOf,g=Object.prototype.hasOwnProperty;var y=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),v=(n,e)=>{for(var o in e)c(n,o,{get:e[o],enumerable:!0})},r=(n,e,o,i)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let l of m(e))!g.call(n,l)&&l!==o&&c(n,l,{get:()=>e[l],enumerable:!(i=u(e,l))||i.enumerable});return n};var f=(n,e,o)=>(o=n!=null?h(s(n)):{},r(e||!n||!n.__esModule?c(o,\"default\",{value:n,enumerable:!0}):o,n)),j=n=>r(c({},\"__esModule\",{value:!0}),n);var d=y((C,a)=>{a.exports=_jsx_runtime});var _={};v(_,{default:()=>b,frontmatter:()=>x});var t=f(d()),x={title:\"Function.prototype.call\",excerpt:\"Implement the Function.prototype.call() function that calls the function with a given `this` value and provided arguments\"};function p(n){let e=Object.assign({blockquote:\"blockquote\",p:\"p\",code:\"code\",em:\"em\",a:\"a\",h2:\"h2\",pre:\"pre\"},n.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(e.blockquote,{children:[`\n`,(0,t.jsxs)(e.p,{children:[\"The \",(0,t.jsx)(e.code,{children:\"Function.prototype.call()\"}),\" method calls the function with a given \",(0,t.jsx)(e.code,{children:\"this\"}),\" value and arguments provided individually.\"]}),`\n`]}),`\n`,(0,t.jsx)(e.p,{children:(0,t.jsxs)(e.em,{children:[\"Source: \",(0,t.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_objects/Function/call\",children:\"Function.prototype.call() - JavaScript | MDN\"})]})}),`\n`,(0,t.jsxs)(e.p,{children:[\"Implement your own \",(0,t.jsx)(e.code,{children:\"Function.prototype.call\"}),\" without calling the native \",(0,t.jsx)(e.code,{children:\"call\"}),\" method. To avoid overwriting the actual \",(0,t.jsx)(e.code,{children:\"Function.prototype.call\"}),\", implement the function as \",(0,t.jsx)(e.code,{children:\"Function.prototype.myCall\"}),\".\"]}),`\n`,(0,t.jsx)(e.h2,{children:\"Examples\"}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-js\",children:`function multiplyAge(multiplier = 1) {\n  return this.age * multiplier;\n}\n\nconst mary = {\n  age: 21,\n};\n\nconst john = {\n  age: 42,\n};\n\nmultiplyAge.myCall(mary); // 21\nmultiplyAge.myCall(john, 2); // 84\n`})})]})}function F(n={}){let{wrapper:e}=n.components||{};return e?(0,t.jsx)(e,Object.assign({},n,{children:(0,t.jsx)(p,n)})):p(n)}var b=F;return j(_);})();\n;return Component;",
  "format": "javascript",
  "metadata": {
    "author": null,
    "companies": [],
    "created": 1690329600,
    "difficulty": "easy",
    "duration": 10,
    "excerpt": "Implement the Function.prototype.call() function that calls the function with a given `this` value and provided arguments",
    "featured": false,
    "format": "javascript",
    "frameworkDefault": null,
    "frameworks": [],
    "href": "/questions/javascript/function-call",
    "importance": "mid",
    "languages": [
      "js",
      "ts"
    ],
    "nextQuestions": [],
    "premium": true,
    "published": true,
    "ranking": 100,
    "similarQuestions": [
      "function-bind",
      "function-apply"
    ],
    "slug": "function-call",
    "subtitle": null,
    "title": "Function.prototype.call",
    "topics": []
  },
  "skeleton": {
    "js": "/**\n * @param {any} thisArg\n * @param {...*} args\n * @return {any}\n */\nFunction.prototype.myCall = function (thisArg, ...args) {\n  throw 'Not implemented!';\n};",
    "ts": "interface Function {\n  myCall(thisArg: any, ...args: any[]): any;\n}\n\nFunction.prototype.myCall = function (thisArg, ...args) {\n  throw 'Not implemented!';\n};"
  },
  "solution": "var Component=(()=>{var g=Object.create;var a=Object.defineProperty;var f=Object.getOwnPropertyDescriptor;var b=Object.getOwnPropertyNames;var w=Object.getPrototypeOf,A=Object.prototype.hasOwnProperty;var x=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),F=(t,e)=>{for(var i in e)a(t,i,{get:e[i],enumerable:!0})},l=(t,e,i,c)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let r of b(e))!A.call(t,r)&&r!==i&&a(t,r,{get:()=>e[r],enumerable:!(c=f(e,r))||c.enumerable});return t};var j=(t,e,i)=>(i=t!=null?g(w(t)):{},l(e||!t||!t.__esModule?a(i,\"default\",{value:t,enumerable:!0}):i,t)),v=t=>l(a({},\"__esModule\",{value:!0}),t);var s=x((X,d)=>{d.exports=_jsx_runtime});var D={};F(D,{default:()=>M});var n=j(s());var o=MDXCodeBlock;var h=`/**\n * @param {any} thisArg\n * @param {...*} args\n * @return {any}\n */\nFunction.prototype.myCall = function (thisArg, ...args) {\n  return this.bind(thisArg)(...args);\n};\n`;var p=`/**\n * @param {any} thisArg\n * @param {...*} args\n * @return {any}\n */\nFunction.prototype.myCall = function (thisArg, ...args) {\n  return this.bind(thisArg, ...args)();\n};\n`;var u=`/**\n * @param {any} thisArg\n * @param {...*} args\n * @return {any}\n */\nFunction.prototype.myCall = function (thisArg, ...args) {\n  return this.apply(thisArg, [...args]);\n};\n`;var y=`/**\n * @param {any} thisArg\n * @param {...*} args\n * @return {any}\n */\nFunction.prototype.myCall = function (thisArg, ...args) {\n  const sym = Symbol();\n  const wrapperObj = Object(thisArg);\n  Object.defineProperty(wrapperObj, sym, {\n    enumerable: false,\n    value: this,\n  });\n\n  return wrapperObj[sym](...args);\n};\n`;function m(t){let e=Object.assign({p:\"p\",code:\"code\",h2:\"h2\",h3:\"h3\",pre:\"pre\",ul:\"ul\",li:\"li\",em:\"em\",a:\"a\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(e.p,{children:[\"The \",(0,n.jsx)(e.code,{children:\"Function.prototype.call()\"}),\" function is a built-in method in JavaScript that allows you to call a function with a specified this value and a set of arguments, passed individually (not as an array like \",(0,n.jsx)(e.code,{children:\"Function.prototype.apply\"}),\"). It allows you to explicitly define the context (\",(0,n.jsx)(e.code,{children:\"this\"}),\" value) in which the function will be executed.\"]}),`\n`,(0,n.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,n.jsxs)(e.h3,{children:[\"Solution 1: Using \",(0,n.jsx)(e.code,{children:\"bind\"})]}),`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.code,{children:\"bind\"}),\", \",(0,n.jsx)(e.code,{children:\"apply\"}),\", and \",(0,n.jsx)(e.code,{children:\"call\"}),\" can be viewed as sibling functions. They're highly similar in terms of function signature and usage. Within \",(0,n.jsx)(e.code,{children:\"Function.prototype\"}),\" methods, \",(0,n.jsx)(e.code,{children:\"this\"}),\" refers to the \",(0,n.jsx)(e.code,{children:\"Function\"}),\" object itself. If the \",(0,n.jsx)(e.code,{children:\"this\"}),\" context is not used at all, the following will work:\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`Function.prototype.myCall = function (thisArg, ...args) {\n  return this(...args);\n};\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"However, \",(0,n.jsx)(e.code,{children:\"thisArg\"}),\" is still used widely in modern code, so we need another way to do this. \",(0,n.jsx)(e.code,{children:\"Function.prototype.bind\"}),\" creates a new function with a specified \",(0,n.jsx)(e.code,{children:\"this\"}),\" value and initial arguments, without executing the original function immediately. It allows you to permanently bind a specific context (\",(0,n.jsx)(e.code,{children:\"this\"}),\" value) to the function and partially apply arguments if needed. This is exactly what we need to bridge the gap in the solution above.\"]}),`\n`,(0,n.jsx)(o,{children:h}),`\n`,(0,n.jsxs)(e.p,{children:[\"Or you can also pass the \",(0,n.jsx)(e.code,{children:\"args\"}),\" into \",(0,n.jsx)(e.code,{children:\"bind()\"}),\" before executing it.\"]}),`\n`,(0,n.jsx)(o,{children:p}),`\n`,(0,n.jsxs)(e.h3,{children:[\"Solution 2: Using \",(0,n.jsx)(e.code,{children:\"apply\"})]}),`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.code,{children:\"Function.prototype.call\"}),\" and \",(0,n.jsx)(e.code,{children:\"Function.prototype.apply\"}),\" are very similar. Here's an easy way to remember each function's signature:\"]}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"Function.prototype.call\"}),\" takes in a \",(0,n.jsx)(e.em,{children:\"c\"}),\"omma-separated list of arguments.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"Function.prototype.apply\"}),\" takes in an \",(0,n.jsx)(e.em,{children:\"a\"}),\"aray of arguments.\"]}),`\n`]}),`\n`,(0,n.jsx)(o,{children:u}),`\n`,(0,n.jsxs)(e.h3,{children:[\"Solution 3: Using \",(0,n.jsx)(e.code,{children:\"Symbol\"})]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Another approach is to create a \",(0,n.jsx)(e.code,{children:\"Symbol\"}),\" and add it as a property to a newly-created \",(0,n.jsx)(e.code,{children:\"Object\"}),\" with \",(0,n.jsx)(e.code,{children:\"thisArg\"}),\" bound to it. This is very similar to one of the solutions to the \",(0,n.jsx)(e.a,{href:\"/questions/javascript/function-bind\",children:(0,n.jsx)(e.code,{children:\"Function.prototype.bind\"})}),\" question.\"]}),`\n`,(0,n.jsx)(o,{children:y})]})}function k(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(m,t)})):m(t)}var M=k;return v(D);})();\n;return Component;",
  "tests": "import './function-call';\n\ndescribe('Function.prototype.myCall', () => {\n  const person = {\n    name: 'John',\n  };\n  function getName() {\n    return this.name;\n  }\n  function sum(...args) {\n    return args.reduce((acc, num) => acc + num, 0);\n  }\n  function greeting(prefix, message) {\n    return `${prefix} ${this.name}, ${message}`;\n  }\n\n  test('Function.prototype.myCall is a function', () => {\n    expect(typeof Function.prototype.myCall).toBe('function');\n  });\n\n  test('`this` is bound', () => {\n    expect(getName.myCall(person)).toStrictEqual('John');\n  });\n\n  describe('without `this`', () => {\n    test('single parameter', () => {\n      expect(sum.myCall(null, 1)).toBe(1);\n    });\n\n    test('two parameters', () => {\n      expect(sum.myCall(null, 1, 2)).toBe(3);\n    });\n\n    test('three parameters', () => {\n      expect(sum.myCall(null, 1, 2, 3)).toBe(6);\n    });\n  });\n\n  test('`this` and parameters', () => {\n    expect(greeting.myCall(person, 'Hello', 'how are you?')).toStrictEqual(\n      'Hello John, how are you?',\n    );\n  });\n});"
}