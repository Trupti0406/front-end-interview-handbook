{
  "description": "var Component=(()=>{var d=Object.create;var r=Object.defineProperty;var g=Object.getOwnPropertyDescriptor;var u=Object.getOwnPropertyNames;var p=Object.getPrototypeOf,S=Object.prototype.hasOwnProperty;var h=(e,n)=>()=>(n||e((n={exports:{}}).exports,n),n.exports),y=(e,n)=>{for(var i in n)r(e,i,{get:n[i],enumerable:!0})},s=(e,n,i,a)=>{if(n&&typeof n==\"object\"||typeof n==\"function\")for(let o of u(n))!S.call(e,o)&&o!==i&&r(e,o,{get:()=>n[o],enumerable:!(a=g(n,o))||a.enumerable});return e};var j=(e,n,i)=>(i=e!=null?d(p(e)):{},s(n||!e||!e.__esModule?r(i,\"default\",{value:e,enumerable:!0}):i,e)),m=e=>s(r({},\"__esModule\",{value:!0}),e);var c=h((_,f)=>{f.exports=_jsx_runtime});var J={};y(J,{default:()=>v,frontmatter:()=>b});var t=j(c()),b={title:\"JSON.stringify\",excerpt:\"Implement a function that converts a JavaScript value into a JSON string\"};function l(e){let n=Object.assign({p:\"p\",code:\"code\",a:\"a\",h2:\"h2\",pre:\"pre\"},e.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.p,{children:[\"Implement your own \",(0,t.jsx)(n.code,{children:\"JSON.stringify()\"}),\" function that converts a JavaScript value into a JSON string. You may ignore the \",(0,t.jsx)(n.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#parameters\",children:\"second and the third\"}),\" optional parameters in the original API.\"]}),`\n`,(0,t.jsxs)(n.p,{children:[\"The function should behave exactly like \",(0,t.jsx)(n.code,{children:\"JSON.stringify()\"}),\" for any data types.\"]}),`\n`,(0,t.jsx)(n.h2,{children:\"Examples\"}),`\n`,(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:\"language-js\",children:`jsonStringify(); // undefined\njsonStringify(undefined); // undefined\njsonStringify(null); // 'null'\njsonStringify(true); // 'true'\njsonStringify(false); // 'false'\njsonStringify(1); // '1'\njsonStringify('foo'); // '\"foo\"'\njsonStringify('\"foo\"') === '\"\\\\\\\\\"foo\\\\\\\\\"\"'; // Double quotes present in the original input are escaped using backslashes\njsonStringify(Symbol('foo')); // undefined\njsonStringify(() => {}); // undefined\njsonStringify({ foo: 'bar' }); // '{\"foo\":\"bar\"}'\njsonStringify(['foo', 'bar']); // '[\"foo\",\"bar\"]'\njsonStringify(/foo/); // '{}'\njsonStringify(new Map()); // '{}'\njsonStringify(new Set()); //'{}'\n`})})]})}function x(e={}){let{wrapper:n}=e.components||{};return n?(0,t.jsx)(n,Object.assign({},e,{children:(0,t.jsx)(l,e)})):l(e)}var v=x;return m(J);})();\n;return Component;",
  "format": "javascript",
  "metadata": {
    "author": "zhenghao",
    "companies": [
      "snap"
    ],
    "created": 1653177600,
    "difficulty": "hard",
    "duration": 45,
    "excerpt": "Implement a function that converts a JavaScript value into a JSON string",
    "featured": true,
    "format": "javascript",
    "frameworkDefault": null,
    "frameworks": [],
    "href": "/questions/javascript/json-stringify",
    "importance": "low",
    "languages": [
      "js",
      "ts"
    ],
    "nextQuestions": [],
    "premium": true,
    "published": true,
    "ranking": 100,
    "similarQuestions": [
      "html-serializer"
    ],
    "slug": "json-stringify",
    "title": "JSON.stringify"
  },
  "skeleton": {
    "js": "/**\n * @param {*} value\n * @return {string}\n */\nexport default function jsonStringify(value) {\n  throw 'Not implemented!';\n}",
    "ts": "export default function jsonStringify(value: any): string {\n  throw 'Not implemented!';\n}"
  },
  "solution": "var Component=(()=>{var f=Object.create;var o=Object.defineProperty;var p=Object.getOwnPropertyDescriptor;var y=Object.getOwnPropertyNames;var g=Object.getPrototypeOf,m=Object.prototype.hasOwnProperty;var b=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),w=(t,e)=>{for(var i in e)o(t,i,{get:e[i],enumerable:!0})},c=(t,e,i,a)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let r of y(e))!m.call(t,r)&&r!==i&&o(t,r,{get:()=>e[r],enumerable:!(a=p(e,r))||a.enumerable});return t};var S=(t,e,i)=>(i=t!=null?f(g(t)):{},c(e||!t||!t.__esModule?o(i,\"default\",{value:t,enumerable:!0}):i,t)),j=t=>c(o({},\"__esModule\",{value:!0}),t);var d=b((x,s)=>{s.exports=_jsx_runtime});var J={};w(J,{default:()=>O});var n=S(d());var l=MDXCodeBlock;var u=`const isCyclic = (input) => {\n  const seen = new Set();\n\n  const dfsHelper = (obj) => {\n    if (typeof obj !== 'object' || obj === null) {\n      return false;\n    }\n\n    seen.add(obj);\n    return Object.values(obj).some(\n      (value) => seen.has(value) || dfsHelper(value),\n    );\n  };\n\n  return dfsHelper(input);\n};\n\n/**\n * @param {*} value\n * @return {string}\n */\nexport default function jsonStringify(data) {\n  const quotes = '\"';\n  const QUOTE_ESCAPE = /\"/g;\n\n  if (isCyclic(data)) {\n    throw new TypeError('Converting circular structure to JSON');\n  }\n\n  if (typeof data === 'bigint') {\n    throw new TypeError('Do not know how to serialize a BigInt');\n  }\n\n  if (data === null) {\n    // Handle null first because the type of null is 'object'.\n    return 'null';\n  }\n\n  const type = typeof data;\n\n  if (type === 'number') {\n    if (Number.isNaN(data) || !Number.isFinite(data)) {\n      // For NaN and Infinity we return 'null'.\n      return 'null';\n    }\n    return String(data);\n  }\n\n  if (type === 'boolean') {\n    return String(data);\n  }\n\n  if (type === 'function' || type === 'undefined' || type === 'symbol') {\n    return undefined; // Not the string 'undefined'.\n  }\n\n  if (type === 'string') {\n    return quotes + data.replace(QUOTE_ESCAPE, '\\\\\\\\\"') + quotes;\n  }\n\n  // At this point \\`data\\` is either an array, a plain object,\n  // or other unsupported object types such as \\`Map\\` and \\`Set\\`.\n  if (typeof data.toJSON === 'function') {\n    // If data has user-provided \\`toJSON\\` method, we use that instead.\n    return jsonStringify(data.toJSON());\n  }\n\n  if (data instanceof Array) {\n    // Array.prototype.toString will be invoked implicitly during string concatenation.\n    return '[' + data.map((item) => jsonStringify(item)) + ']';\n  }\n\n  // \\`data\\` is a plain object.\n  const entries = Object.entries(data)\n    .map(([key, value]) => {\n      const shouldIgnoreEntry =\n        typeof key === 'symbol' ||\n        value === undefined ||\n        typeof value === 'function' ||\n        typeof value === 'symbol';\n\n      if (shouldIgnoreEntry) {\n        return;\n      }\n\n      return quotes + key + quotes + ':' + jsonStringify(value);\n    })\n    .filter((value) => value !== undefined);\n\n  // Again, Object.prototype.toString will be invoked implicitly during string concatenation\n  return '{' + entries + '}';\n}\n`;function h(t){let e=Object.assign({p:\"p\",code:\"code\",h2:\"h2\",pre:\"pre\",ul:\"ul\",li:\"li\",a:\"a\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(e.p,{children:[\"This is a hard problem, not necessarily because the logic or the algorithm is hard to understand (although there are certain complexities), but more because you have to be very familiar with the \",(0,n.jsx)(e.code,{children:\"JSON.stringify\"}),\" API and know all the intricacies when data types that are not supported by JSON are passed to the function, e.g. functions, \",(0,n.jsx)(e.code,{children:\"regex\"}),\", and \",(0,n.jsx)(e.code,{children:\"Date\"}),\" object.\"]}),`\n`,(0,n.jsx)(e.h2,{children:\"Handling Data Types\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"When passed directly with unsupported type \",(0,n.jsx)(e.code,{children:\"undefined\"}),\", \",(0,n.jsx)(e.code,{children:\"Symbol\"}),\", and \",(0,n.jsx)(e.code,{children:\"Function\"}),\", JSON.stringify outputs \",(0,n.jsx)(e.code,{children:\"undefined\"}),\" (not the string \",(0,n.jsx)(e.code,{children:\"'undefined'\"}),\"):\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`JSON.stringify(undefined); // undefined\nJSON.stringify(Symbol('foo')); // undefined\nJSON.stringify(() => {}); // undefined\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"For other built-in object types (except for \",(0,n.jsx)(e.code,{children:\"Function\"}),\" and \",(0,n.jsx)(e.code,{children:\"Date\"}),\") such as \",(0,n.jsx)(e.code,{children:\"Map\"}),\", \",(0,n.jsx)(e.code,{children:\"Set\"}),\", \",(0,n.jsx)(e.code,{children:\"WeakMap\"}),\", \",(0,n.jsx)(e.code,{children:\"WeakSet\"}),\", \",(0,n.jsx)(e.code,{children:\"Regex\"}),\", etc., \",(0,n.jsx)(e.code,{children:\"JSON.stringify\"}),\" will return a string of an empty object literal, i.e. \",(0,n.jsx)(e.code,{children:\"{}\"}),\":\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`JSON.stringify(/foo/); // '{}'\nJSON.stringify(new Map()); // '{}'\nJSON.stringify(new Set()); //'{}'\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.code,{children:\"NaN\"}),\" and \",(0,n.jsx)(e.code,{children:\"Infinity\"}),\" are converted into \",(0,n.jsx)(e.code,{children:\"null\"}),\", and \",(0,n.jsx)(e.code,{children:\"Date\"}),\" objects are encoded into ISO strings by \",(0,n.jsx)(e.code,{children:\"JSON.stringify\"}),\" because of \",(0,n.jsx)(e.code,{children:\"Date.prototype.toJSON\"}),\". And yes, we will have to take care of a custom \",(0,n.jsx)(e.code,{children:\"toJSON\"}),\" method present in the input value.\"]}),`\n`,(0,n.jsx)(e.h2,{children:\"Cyclic References\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"Finally, \",(0,n.jsx)(e.code,{children:\"JSON.stringify\"}),\" can detect a cyclic object i.e. objects with circular references and bail out from the stringification by throwing an error. We will have to account for that as well.\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`const foo = {};\nfoo.a = foo;\n\nJSON.stringify(foo); // \\u274C Uncaught TypeError: Converting circular structure to JSON\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"To detect circular references in an object, we can use a \",(0,n.jsx)(e.code,{children:\"Set\"}),\" to keep track of property values we have visited while traversing the object. As soon as we find a value that exists in the set already, we know the object has circular references.\"]}),`\n`,(0,n.jsx)(e.p,{children:\"Here is how we would write it:\"}),`\n`,(0,n.jsx)(l,{children:u}),`\n`,(0,n.jsx)(e.h2,{children:\"Notes\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"There are still uncovered edge cases with the current implementation. Check out \",(0,n.jsx)(e.a,{href:\"https://262.ecma-international.org/5.1/#sec-15.12.3\",children:\"the spec\"}),\" if you are interested in learning more about it.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"One possible follow-up question could be to make it faster. Our current implementation involves frequent runtime type checks due to the dynamic typing nature of the JavaScript language. One way we can make our own implementation of \",(0,n.jsx)(e.code,{children:\"JSON.stringify\"}),\" faster is to have the user provide a schema of the object (e.g. using \",(0,n.jsx)(e.a,{href:\"https://json-schema.org/\",children:\"JSON Schema\"}),\") so we know the object structure before serialization. This can save us a ton of guesswork. In fact, many \",(0,n.jsx)(e.code,{children:\"JSON.stringify\"}),\"-alternative libraries are implemented this way to make serialization faster. One example would be \",(0,n.jsx)(e.a,{href:\"https://github.com/fastify/fast-json-stringify\",children:\"fast-json-stringify\"}),\".\"]}),`\n`]})]})}function N(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(h,t)})):h(t)}var O=N;return j(J);})();\n;return Component;",
  "tests": "import jsonStringify from './json-stringify';\n\n/* eslint-disable no-undef */\ndescribe('jsonStringify', () => {\n  test('single primitive value', () => {\n    expect(jsonStringify()).toEqual(undefined);\n    expect(jsonStringify(undefined)).toEqual(undefined);\n    expect(jsonStringify(null)).toEqual('null');\n    expect(jsonStringify(true)).toEqual('true');\n    expect(jsonStringify(false)).toEqual('false');\n    expect(jsonStringify(1)).toEqual('1');\n    expect(jsonStringify('foo')).toEqual('\"foo\"');\n    expect(jsonStringify('\"foo\"')).toEqual('\"\\\\\"foo\\\\\"\"');\n    expect(jsonStringify(Symbol('foo'))).toEqual(undefined);\n    expect(jsonStringify(() => {})).toEqual(undefined);\n    expect(jsonStringify(/foo/)).toEqual('{}');\n    expect(jsonStringify(new Map())).toEqual('{}');\n    expect(jsonStringify(new Set())).toEqual('{}');\n  });\n\n  test(\"NaN and Infinity returns 'null'\", () => {\n    expect(jsonStringify(NaN)).toEqual('null');\n    expect(jsonStringify(Infinity)).toEqual('null');\n  });\n\n  test('date objects returns iso strings', () => {\n    const date = new Date();\n    expect(jsonStringify(date)).toEqual(`\"${date.toISOString()}\"`);\n  });\n\n  test('objects with only JSON-supported values', () => {\n    expect(jsonStringify([1, 2, 3])).toEqual('[1,2,3]');\n    expect(\n      jsonStringify({\n        name: 'foo',\n        age: 18,\n        attr: ['coding', 123],\n      }),\n    ).toEqual('{\"name\":\"foo\",\"age\":18,\"attr\":[\"coding\",123]}');\n  });\n\n  test('objects with JSON-incompatible values', () => {\n    expect(jsonStringify([1, 2, 3])).toEqual('[1,2,3]');\n    expect(\n      jsonStringify({\n        name: 'foo',\n        age: 18,\n        attr: ['coding', 123],\n        uni: Symbol(2),\n        sayHi: function () {\n          console.log('hi');\n        },\n        info: {\n          sister: 'lily',\n          age: 16,\n          intro: {\n            money: undefined,\n            job: null,\n          },\n        },\n      }),\n    ).toEqual(\n      '{\"name\":\"foo\",\"age\":18,\"attr\":[\"coding\",123],\"info\":{\"sister\":\"lily\",\"age\":16,\"intro\":{\"job\":null}}}',\n    );\n  });\n\n  test('throws on BigInt values', () => {\n    expect(() => jsonStringify(BigInt(1234567890))).toThrow();\n  });\n\n  test('throws on cyclic objects', () => {\n    const foo = {};\n    foo.a = foo;\n\n    expect(() => jsonStringify(foo)).toThrow();\n  });\n});"
}