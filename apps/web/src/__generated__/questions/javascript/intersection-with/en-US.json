{
  "description": "var Component=(()=>{var d=Object.create;var a=Object.defineProperty;var m=Object.getOwnPropertyDescriptor;var u=Object.getOwnPropertyNames;var p=Object.getPrototypeOf,y=Object.prototype.hasOwnProperty;var f=(r,e)=>()=>(e||r((e={exports:{}}).exports,e),e.exports),g=(r,e)=>{for(var t in e)a(r,t,{get:e[t],enumerable:!0})},c=(r,e,t,o)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let i of u(e))!y.call(r,i)&&i!==t&&a(r,i,{get:()=>e[i],enumerable:!(o=m(e,i))||o.enumerable});return r};var x=(r,e,t)=>(t=r!=null?d(p(r)):{},c(e||!r||!r.__esModule?a(t,\"default\",{value:r,enumerable:!0}):t,r)),w=r=>c(a({},\"__esModule\",{value:!0}),r);var l=f((T,s)=>{s.exports=_jsx_runtime});var q={};g(q,{default:()=>_,frontmatter:()=>b});var n=x(l()),b={title:\"Intersection With\",excerpt:\"Computes the intersection of arrays using a custom comparator function to determine equality between elements.\"};function h(r){let e=Object.assign({p:\"p\",code:\"code\",pre:\"pre\",h2:\"h2\",ol:\"ol\",li:\"li\",em:\"em\",ul:\"ul\",a:\"a\"},r.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(e.p,{children:[\"The \",(0,n.jsx)(e.code,{children:\"intersectionWith\"}),\" function takes a custom \",(0,n.jsx)(e.code,{children:\"comparator\"}),\" function and multiple arrays as arguments. It compares the elements of the arrays using the \",(0,n.jsx)(e.code,{children:\"comparator\"}),\" function to determine equality. The function returns a new array containing the elements that are present in all given arrays.\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-ts\",children:`intersectionWith(comparator, ...arrays);\n`})}),`\n`,(0,n.jsx)(e.h2,{children:\"Arguments\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"comparator\"}),\" \",(0,n.jsx)(e.em,{children:\"(Function)\"}),\": The comparator function used to determine equality between elements. The function will be invoked with two arguments \",(0,n.jsx)(e.code,{children:\"(arrVal, othVal)\"}),\" representing the two elements being compared. It should return \",(0,n.jsx)(e.code,{children:\"true\"}),\" if the elements are considered equal, and \",(0,n.jsx)(e.code,{children:\"false\"}),\" otherwise.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"arrays\"}),\" \",(0,n.jsx)(e.em,{children:\"(...Array)\"}),\": The arrays to inspect.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"Returns\"}),`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.em,{children:\"(Array)\"}),\": Returns the array after intersection of arrays.\"]}),`\n`,(0,n.jsx)(e.h2,{children:\"Example\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`const arr1 = [\n  { x: 1, y: 2 },\n  { x: 2, y: 3 },\n];\nconst arr2 = [\n  { y: 2, x: 1 },\n  { x: 3, y: 4 },\n];\n\nconst result = intersectionWith(\n  (a, b) => a.x === b.x && a.y === b.y,\n  arr1,\n  arr2,\n); // => [{ x: 1, y: 2 }]\n`})}),`\n`,(0,n.jsx)(e.h2,{children:\"Notes\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"In Lodash, \",(0,n.jsx)(e.code,{children:\"comparator\"}),\" is optional and is the last parameter, but in this question it is a required parameter for simplicity.\"]}),`\n`,(0,n.jsx)(e.li,{children:\"The order of elements in the resulting array is determined by the order in which they appear in the first array.\"}),`\n`,(0,n.jsx)(e.li,{children:\"If no arrays are provided, the function will return an empty array.\"}),`\n`,(0,n.jsx)(e.li,{children:\"If any of the arrays are empty, the function will return an empty array.\"}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"Resources\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:(0,n.jsxs)(e.a,{href:\"https://lodash.com/docs/#intersectionWith\",children:[\"Lodash \",(0,n.jsx)(e.code,{children:\"_.intersectionWith\"})]})}),`\n`]})]})}function j(r={}){let{wrapper:e}=r.components||{};return e?(0,n.jsx)(e,Object.assign({},r,{children:(0,n.jsx)(h,r)})):h(r)}var _=j;return w(q);})();\n;return Component;",
  "format": "javascript",
  "metadata": {
    "author": null,
    "companies": [],
    "created": 1687651200,
    "difficulty": "medium",
    "duration": 15,
    "excerpt": "Computes the intersection of arrays using a custom comparator function to determine equality between elements.",
    "featured": false,
    "format": "javascript",
    "frameworkDefault": null,
    "frameworks": [],
    "href": "/questions/javascript/intersection-with",
    "importance": "low",
    "languages": [
      "js",
      "ts"
    ],
    "nextQuestions": [],
    "premium": true,
    "published": true,
    "ranking": 100,
    "similarQuestions": [
      "intersection",
      "intersection-with"
    ],
    "slug": "intersection-with",
    "title": "Intersection With"
  },
  "skeleton": {
    "js": "/**\n * Computes the intersection of arrays using a custom comparator function to determine equality between elements.\n *\n * @param {Function} comparator - The comparator function used to determine equality between elements.\n * @param {...Array} arrays - The arrays to perform the intersection on.\n * @returns {Array} - A new array containing the elements that are present in all given arrays.\n */\nexport default function intersectionWith(comparator, ...arrays) {\n  throw 'Not implemented!';\n}",
    "ts": "export default function intersectionWith<T>(\n  comparator: (a: T, b: T) => boolean,\n  ...arrays: T[][]\n): T[] {\n  throw 'Not implemented!';\n}"
  },
  "solution": "var Component=(()=>{var d=Object.create;var o=Object.defineProperty;var f=Object.getOwnPropertyDescriptor;var p=Object.getOwnPropertyNames;var y=Object.getPrototypeOf,g=Object.prototype.hasOwnProperty;var x=(r,e)=>()=>(e||r((e={exports:{}}).exports,e),e.exports),v=(r,e)=>{for(var n in e)o(r,n,{get:e[n],enumerable:!0})},s=(r,e,n,i)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let a of p(e))!g.call(r,a)&&a!==n&&o(r,a,{get:()=>e[a],enumerable:!(i=f(e,a))||i.enumerable});return r};var _=(r,e,n)=>(n=r!=null?d(y(r)):{},s(e||!r||!r.__esModule?o(n,\"default\",{value:r,enumerable:!0}):n,r)),j=r=>s(o({},\"__esModule\",{value:!0}),r);var l=x((D,c)=>{c.exports=_jsx_runtime});var M={};v(M,{default:()=>C});var t=_(l());var h=MDXCodeBlock;var u=`/**\n * Computes the intersection of arrays using a custom comparator function to determine equality between elements.\n *\n * @param {Function} comparator - The comparator function used to determine equality between elements.\n * @param {...Array} arrays - The arrays to perform the intersection on.\n * @returns {Array} - A new array containing the elements that are present in all given arrays.\n */\nexport default function intersectionWith(comparator, ...arrays) {\n  if (!arrays.length) {\n    return [];\n  }\n\n  const firstArray = arrays[0];\n\n  // Perform intersection\n  return firstArray.filter((value) =>\n    arrays\n      .slice(1)\n      .every((arr) => arr.some((otherValue) => comparator(value, otherValue))),\n  );\n}\n`;function m(r){let e=Object.assign({h2:\"h2\",p:\"p\",ul:\"ul\",li:\"li\",a:\"a\",code:\"code\"},r.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,t.jsx)(h,{children:u}),`\n`,(0,t.jsx)(e.p,{children:\"The solution first maps each array using the iteratee function to transform the values. Then, it filters the values from the first mapped array that are present in all the other mapped arrays. Finally, it maps the intersected values back to the original values from the first array.\"}),`\n`,(0,t.jsx)(e.h2,{children:\"Resources\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:(0,t.jsxs)(e.a,{href:\"https://lodash.com/docs/#intersectionWith\",children:[\"Lodash \",(0,t.jsx)(e.code,{children:\"_.intersectionWith\"})]})}),`\n`]})]})}function A(r={}){let{wrapper:e}=r.components||{};return e?(0,t.jsx)(e,Object.assign({},r,{children:(0,t.jsx)(m,r)})):m(r)}var C=A;return j(M);})();\n;return Component;",
  "tests": "import intersectionWith from './intersection-with';\n\ndescribe('intersectionWith', () => {\n  test('should return an empty array when no arrays are provided', () => {\n    const actual = intersectionWith((x, y) => true);\n    expect(actual).toEqual([]);\n  });\n\n  test('should return an empty array when any of the arrays are empty', () => {\n    const actual = intersectionWith((x, y) => true, [], [1, 2, 3], [4, 5, 6]);\n    expect(actual).toEqual([]);\n  });\n\n  test('should return an empty array when there are no common elements', () => {\n    const actual = intersectionWith(\n      (x, y) => x === y,\n      [1, 2, 3],\n      [4, 5, 6],\n      [7, 8, 9],\n    );\n    expect(actual).toEqual([]);\n  });\n\n  test('should return the intersection of two arrays', () => {\n    const arr1 = [\n      { x: 1, y: 2 },\n      { x: 2, y: 3 },\n      { x: 3, y: 4 },\n    ];\n    const arr2 = [\n      { x: 2, y: 3 },\n      { x: 4, y: 5 },\n      { x: 5, y: 6 },\n    ];\n\n    const comparator = (a, b) => a.x === b.x && a.y === b.y;\n\n    const actual = intersectionWith(comparator, arr1, arr2);\n    const expected = [{ x: 2, y: 3 }];\n\n    expect(actual).toEqual(expected);\n  });\n\n  test('should return the intersection of multiple arrays using a comparator', () => {\n    const arr1 = [\n      { x: 1, y: 2 },\n      { x: 2, y: 3 },\n      { x: 3, y: 4 },\n    ];\n    const arr2 = [\n      { x: 2, y: 3 },\n      { x: 4, y: 5 },\n      { x: 5, y: 6 },\n    ];\n    const arr3 = [\n      { x: 2, y: 3 },\n      { x: 3, y: 4 },\n      { x: 5, y: 6 },\n      { x: 6, y: 7 },\n    ];\n\n    const comparator = (a, b) => a.x === b.x && a.y === b.y;\n\n    const actual = intersectionWith(comparator, arr1, arr2, arr3);\n    const expected = [{ x: 2, y: 3 }];\n\n    expect(actual).toEqual(expected);\n  });\n\n  test('should return the intersection of arrays with different lengths', () => {\n    const arr1 = [1, 2, 3];\n    const arr2 = [2, 3, 4, 5];\n    const arr3 = [3, 4, 5, 6, 7];\n\n    const actual = intersectionWith((x, y) => x == y, arr1, arr2, arr3);\n    const expected = [3];\n\n    expect(actual).toEqual(expected);\n  });\n\n  test('should return the intersection of arrays with single elements', () => {\n    const arr1 = [{ x: 1, y: 2 }];\n    const arr2 = [{ x: 2, y: 3 }];\n    const arr3 = [{ x: 3, y: 4 }];\n\n    const comparator = (a, b) => a.x === b.x && a.y === b.y;\n    const actual = intersectionWith(comparator, arr1, arr2, arr3);\n    expect(actual).toEqual([]);\n  });\n});"
}