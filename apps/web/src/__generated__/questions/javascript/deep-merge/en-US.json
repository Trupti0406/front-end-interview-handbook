{
  "description": "var Component=(()=>{var h=Object.create;var c=Object.defineProperty;var b=Object.getOwnPropertyDescriptor;var m=Object.getOwnPropertyNames;var u=Object.getPrototypeOf,p=Object.prototype.hasOwnProperty;var j=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),g=(t,e)=>{for(var r in e)c(t,r,{get:e[r],enumerable:!0})},l=(t,e,r,s)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let o of m(e))!p.call(t,o)&&o!==r&&c(t,o,{get:()=>e[o],enumerable:!(s=b(e,o))||s.enumerable});return t};var f=(t,e,r)=>(r=t!=null?h(u(t)):{},l(e||!t||!t.__esModule?c(r,\"default\",{value:t,enumerable:!0}):r,t)),x=t=>l(c({},\"__esModule\",{value:!0}),t);var a=j((v,i)=>{i.exports=_jsx_runtime});var y={};g(y,{default:()=>_,frontmatter:()=>M});var n=f(a()),M={title:\"Deep Merge\",excerpt:\"Implement a function that merges two objects together\"};function d(t){let e=Object.assign({p:\"p\",code:\"code\",ul:\"ul\",li:\"li\",h2:\"h2\",pre:\"pre\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(e.p,{children:[\"Implement a function \",(0,n.jsx)(e.code,{children:\"deepMerge(objA, objB)\"}),\" to takes in two objects and returns a new object after deep merging them:\"]}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"The resulting object should contain a union of the keys/values of both objects.\"}),`\n`,(0,n.jsxs)(e.li,{children:[\"If the same key is present on both objects, the merged value will be from \",(0,n.jsx)(e.code,{children:\"objB\"}),\", unless:\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Both values are arrays: the elements from \",(0,n.jsx)(e.code,{children:\"objB\"}),\" will be appended behind \",(0,n.jsx)(e.code,{children:\"objA\"}),\"'s.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Both values are objects: merge the objects as per the same rules for \",(0,n.jsx)(e.code,{children:\"deepMerge\"}),\".\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsx)(e.li,{children:\"Arrays and objects within the merged object should be new instances.\"}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:\"The input objects should not be modified.\"}),`\n`,(0,n.jsx)(e.h2,{children:\"Examples\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`deepMerge({ a: 1 }, { b: 2 }); // { a: 1, b: 2 }\ndeepMerge({ a: 1 }, { a: 2 }); // { a: 2 }\ndeepMerge({ a: 1, b: [2] }, { b: [3, 4] }); // { a: 1, b: [2, 3, 4] }\n`})})]})}function w(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(d,t)})):d(t)}var _=w;return x(y);})();\n;return Component;",
  "format": "javascript",
  "metadata": {
    "author": null,
    "companies": [],
    "created": 1690848000,
    "difficulty": "medium",
    "duration": 30,
    "excerpt": "Implement a function that merges two objects together",
    "featured": false,
    "format": "javascript",
    "frameworkDefault": null,
    "frameworks": [],
    "href": "/questions/javascript/deep-merge",
    "importance": "low",
    "languages": [
      "js",
      "ts"
    ],
    "nextQuestions": [],
    "premium": true,
    "published": true,
    "ranking": 100,
    "similarQuestions": [
      "deep-clone"
    ],
    "slug": "deep-merge",
    "subtitle": null,
    "title": "Deep Merge",
    "topics": []
  },
  "skeleton": {
    "js": "/**\n * @param {Object} objA\n * @param {Object} objB\n * @returns Object\n */\nexport default function deepMerge(objA, objB) {\n  throw 'Not implemented';\n}",
    "ts": "export default function deepMerge(objA: Object, objB: Object): Object {\n  throw 'Not implemented';\n}"
  },
  "solution": "var Component=(()=>{var u=Object.create;var i=Object.defineProperty;var j=Object.getOwnPropertyDescriptor;var p=Object.getOwnPropertyNames;var y=Object.getPrototypeOf,f=Object.prototype.hasOwnProperty;var v=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),m=(n,e)=>{for(var o in e)i(n,o,{get:e[o],enumerable:!0})},a=(n,e,o,c)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let r of p(e))!f.call(n,r)&&r!==o&&i(n,r,{get:()=>e[r],enumerable:!(c=j(e,r))||c.enumerable});return n};var g=(n,e,o)=>(o=n!=null?u(y(n)):{},a(e||!n||!n.__esModule?i(o,\"default\",{value:n,enumerable:!0}):o,n)),w=n=>a(i({},\"__esModule\",{value:!0}),n);var s=v((M,l)=>{l.exports=_jsx_runtime});var A={};m(A,{default:()=>k});var t=g(s());var h=MDXCodeBlock;var d=`/**\n * @param {Object} objA\n * @param {Object} objB\n * @returns Object\n */\nexport default function deepMerge(objA, objB) {\n  // Both values are arrays.\n  if (Array.isArray(objA) && Array.isArray(objB)) {\n    return [...objA, ...objB];\n  }\n\n  // Both values are objects.\n  if (isPlainObject(objA) && isPlainObject(objB)) {\n    const newObj = { ...objA };\n    for (const key in objB) {\n      if (Object.prototype.hasOwnProperty.call(objA, key)) {\n        newObj[key] = deepMerge(objA[key], objB[key]);\n      } else {\n        newObj[key] = objB[key];\n      }\n    }\n    return newObj;\n  }\n\n  // Return the second value as it will \"win\" in case of an overlap.\n  return objB;\n}\n\nfunction isPlainObject(value) {\n  if (value == null) {\n    return false;\n  }\n\n  const prototype = Object.getPrototypeOf(value);\n  return prototype === null || prototype === Object.prototype;\n}\n`;function b(n){let e=Object.assign({h2:\"h2\",ul:\"ul\",li:\"li\",p:\"p\",ol:\"ol\",code:\"code\"},n.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.h2,{children:\"Clarification Questions\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"Can non-primitives values in the merged object reference the original objects?\",`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:\"Yes, as long as the original objects are not modified.\"}),`\n`]}),`\n`]}),`\n`]}),`\n`,(0,t.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,t.jsx)(e.p,{children:\"Since the input objects can be deeply nested structures, a recursive solution can be used to traversing both values at the same time. The idea is to recursively visit all object values and combine the contents depending on the type of values at the same position in the objects.\"}),`\n`,(0,t.jsx)(e.p,{children:\"Based on the rules, we only need to combine overlapping values that are arrays or objects. Hence there are three cases we need to handle:\"}),`\n`,(0,t.jsxs)(e.ol,{children:[`\n`,(0,t.jsx)(e.li,{children:\"Both values are arrays: Combine the values by building a new array from the contents of both arrays.\"}),`\n`,(0,t.jsxs)(e.li,{children:[\"Both values are objects: Create a clone of \",(0,t.jsx)(e.code,{children:\"objA\"}),\", then iterate through keys in \",(0,t.jsx)(e.code,{children:\"objB\"}),\", calling \",(0,t.jsx)(e.code,{children:\"deepMerge\"}),\" on the values for the keys that exist in both objects. The returned value is the value that should exist within the merged object. We need to do strict checks for whether an object is a plain JavaScript object as there could be object-like values within the input like \",(0,t.jsx)(e.code,{children:\"null\"}),\", \",(0,t.jsx)(e.code,{children:\"Date\"}),\", \",(0,t.jsx)(e.code,{children:\"RegExp\"}),\" where \",(0,t.jsx)(e.code,{children:\"typeof value\"}),\" will return \",(0,t.jsx)(e.code,{children:\"'object'\"}),\" for these values.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Values are neither both arrays or both objects: Return \",(0,t.jsx)(e.code,{children:\"objB\"}),\" since it comes later and should overwrite the value at the same position within \",(0,t.jsx)(e.code,{children:\"objA\"}),\".\"]}),`\n`]}),`\n`,(0,t.jsx)(h,{children:d}),`\n`,(0,t.jsxs)(e.p,{children:[\"Note that the merged object can contain references to values in the original objects. This happens in the case where arrays contains objects and these objects aren't directly processed with \",(0,t.jsx)(e.code,{children:\"deepMerge\"}),\". If a full copy of the objects is desired, you can deep clone both objects first before merging or deep clone the resulting object.\"]}),`\n`,(0,t.jsx)(e.h2,{children:\"Edge Cases\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"Non-plain JavaScript object values like \",(0,t.jsx)(e.code,{children:\"null\"}),\", \",(0,t.jsx)(e.code,{children:\"Date\"}),\", \",(0,t.jsx)(e.code,{children:\"Symbol\"}),\" should be treated as non-objects.\"]}),`\n`]})]})}function O(n={}){let{wrapper:e}=n.components||{};return e?(0,t.jsx)(e,Object.assign({},n,{children:(0,t.jsx)(b,n)})):b(n)}var k=O;return w(A);})();\n;return Component;",
  "tests": "import deepMerge from './deep-merge';\n\ndescribe('deepMerge', () => {\n  test('empty', () => {\n    expect(deepMerge({}, {})).toEqual({});\n  });\n\n  test('single key', () => {\n    expect(deepMerge({ foo: 2 }, {})).toEqual({ foo: 2 });\n    expect(deepMerge({}, { foo: 2 })).toEqual({ foo: 2 });\n  });\n\n  test('multiple keys', () => {\n    expect(deepMerge({ foo: 2, bar: 3 }, { qux: 4 })).toEqual({\n      foo: 2,\n      bar: 3,\n      qux: 4,\n    });\n    expect(deepMerge({ foo: 2 }, { bar: 3, qux: 4 })).toEqual({\n      foo: 2,\n      bar: 3,\n      qux: 4,\n    });\n  });\n\n  test('overlapping keys', () => {\n    expect(deepMerge({ foo: 2, bar: 3 }, { bar: 4 })).toEqual({\n      foo: 2,\n      bar: 4,\n    });\n    expect(deepMerge({ bar: 3 }, { foo: 2, bar: 4 })).toEqual({\n      foo: 2,\n      bar: 4,\n    });\n  });\n\n  test('null values', () => {\n    expect(deepMerge({ foo: {} }, { foo: null })).toEqual({ foo: null });\n    expect(deepMerge({ foo: null }, { foo: {} })).toEqual({ foo: {} });\n    expect(deepMerge({ foo: null }, { bar: {} })).toEqual({\n      foo: null,\n      bar: {},\n    });\n  });\n\n  test('nested objects', () => {\n    expect(\n      deepMerge(\n        { foo: 3, bar: { baz: 5, qux: 6, boo: 5 } },\n        { foo: 30, blah: 0, bar: { baz: 10, qux: 20 } },\n      ),\n    ).toEqual({\n      foo: 30,\n      blah: 0,\n      bar: {\n        baz: 10,\n        qux: 20,\n        boo: 5,\n      },\n    });\n    expect(\n      deepMerge(\n        { foo: 3, bar: { baz: 5, qux: 6 } },\n        { foo: 30, blah: 0, bar: { baz: 10, qux: 20, boo: 5 } },\n      ),\n    ).toEqual({\n      foo: 30,\n      blah: 0,\n      bar: {\n        baz: 10,\n        qux: 20,\n        boo: 5,\n      },\n    });\n  });\n\n  describe('arrays', () => {\n    test('array values', () => {\n      expect(deepMerge({ foo: 3, bar: null }, { bar: [1, 2, 3] })).toEqual({\n        foo: 3,\n        bar: [1, 2, 3],\n      });\n      expect(deepMerge({ foo: 3, bar: { 1: 2 } }, { bar: [1, 2, 3] })).toEqual({\n        foo: 3,\n        bar: [1, 2, 3],\n      });\n      expect(deepMerge({ foo: 3, qux: null }, { bar: [1, 2, 3] })).toEqual({\n        foo: 3,\n        bar: [1, 2, 3],\n        qux: null,\n      });\n    });\n\n    test('merge arrays', () => {\n      expect(deepMerge({ foo: 3, bar: [7, 5] }, { bar: [1, 2, 3] })).toEqual({\n        foo: 3,\n        bar: [7, 5, 1, 2, 3],\n      });\n      expect(\n        deepMerge({ foo: 3, bar: [7, 5] }, { bar: [{}, null, []] }),\n      ).toEqual({\n        foo: 3,\n        bar: [7, 5, {}, null, []],\n      });\n    });\n\n    test('within nested objects', () => {\n      expect(\n        deepMerge(\n          { foo: 3, bar: { baz: [5, 4], qux: 6, boo: 5 } },\n          { foo: 30, blah: 0, bar: { baz: [10], qux: 20 } },\n        ),\n      ).toEqual({\n        foo: 30,\n        blah: 0,\n        bar: {\n          baz: [5, 4, 10],\n          qux: 20,\n          boo: 5,\n        },\n      });\n      expect(\n        deepMerge(\n          { foo: 3, bar: { baz: 5, qux: [6, 7] } },\n          { foo: 30, blah: 0, bar: { baz: 10, qux: 20, boo: 5 } },\n        ),\n      ).toEqual({\n        foo: 30,\n        blah: 0,\n        bar: {\n          baz: 10,\n          qux: 20,\n          boo: 5,\n        },\n      });\n      expect(\n        deepMerge(\n          { foo: 3, bar: { baz: 5, qux: 20 } },\n          { foo: 30, blah: 0, bar: { baz: 10, qux: [6, 7], boo: 5 } },\n        ),\n      ).toEqual({\n        foo: 30,\n        blah: 0,\n        bar: {\n          baz: 10,\n          qux: [6, 7],\n          boo: 5,\n        },\n      });\n    });\n  });\n\n  describe('does not mutate the input', () => {\n    test('primitives', () => {\n      const objA = { a: 3, foo: 2, qux: 6 };\n      const objB = { bar: 6, b: 4, qux: 8 };\n      expect(deepMerge(objA, objB)).toEqual({\n        a: 3,\n        foo: 2,\n        bar: 6,\n        b: 4,\n        qux: 8,\n      });\n      expect(objA).toEqual({ a: 3, foo: 2, qux: 6 });\n      expect(objB).toEqual({ bar: 6, b: 4, qux: 8 });\n    });\n\n    test('arrays', () => {\n      const objA = { a: 3, c: [1, 2] };\n      const objB = { b: 4, c: [3, 4] };\n      expect(deepMerge(objA, objB)).toEqual({\n        a: 3,\n        b: 4,\n        c: [1, 2, 3, 4],\n      });\n      expect(objA).toEqual({ a: 3, c: [1, 2] });\n      expect(objB).toEqual({ b: 4, c: [3, 4] });\n    });\n  });\n});"
}