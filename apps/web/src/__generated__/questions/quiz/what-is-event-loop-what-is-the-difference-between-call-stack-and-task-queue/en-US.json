{
  "description": null,
  "format": "quiz",
  "metadata": {
    "author": null,
    "companies": [
      "amazon",
      "salesforce"
    ],
    "created": 1630800000,
    "difficulty": "hard",
    "duration": 5,
    "excerpt": null,
    "featured": false,
    "format": "quiz",
    "frameworkDefault": null,
    "frameworks": [],
    "href": "/questions/quiz/what-is-event-loop-what-is-the-difference-between-call-stack-and-task-queue",
    "importance": "high",
    "languages": [],
    "nextQuestions": [],
    "premium": false,
    "published": true,
    "ranking": 100,
    "similarQuestions": [],
    "slug": "what-is-event-loop-what-is-the-difference-between-call-stack-and-task-queue",
    "subtitle": "What is the difference between call stack and task queue?",
    "title": "What is event loop?",
    "topics": [
      "javascript"
    ]
  },
  "solution": "var Component=(()=>{var d=Object.create;var i=Object.defineProperty;var u=Object.getOwnPropertyDescriptor;var p=Object.getOwnPropertyNames;var m=Object.getPrototypeOf,k=Object.prototype.hasOwnProperty;var f=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),g=(n,e)=>{for(var o in e)i(n,o,{get:e[o],enumerable:!0})},s=(n,e,o,r)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let a of p(e))!k.call(n,a)&&a!==o&&i(n,a,{get:()=>e[a],enumerable:!(r=u(e,a))||r.enumerable});return n};var v=(n,e,o)=>(o=n!=null?d(m(n)):{},s(e||!n||!n.__esModule?i(o,\"default\",{value:n,enumerable:!0}):o,n)),y=n=>s(i({},\"__esModule\",{value:!0}),n);var l=f((S,c)=>{c.exports=_jsx_runtime});var T={};g(T,{default:()=>x,frontmatter:()=>b});var t=v(l()),b={title:\"What is event loop?\",subtitle:\"What is the difference between call stack and task queue?\"};function h(n){let e=Object.assign({h2:\"h2\",p:\"p\",a:\"a\",hr:\"hr\",img:\"img\",h3:\"h3\",code:\"code\",h4:\"h4\",ul:\"ul\",li:\"li\",ol:\"ol\",strong:\"strong\",pre:\"pre\"},n.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.h2,{children:\"TL;DR\"}),`\n`,(0,t.jsx)(e.p,{children:\"The event loop is a single-threaded loop that monitors the call stack and checks if there is any work to be done in the task queue. If the call stack is empty and there are callback functions in the task queue, a function is dequeued and pushed onto the call stack to be executed.\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"If you haven't already checked out Philip Robert's \",(0,t.jsx)(e.a,{href:\"https://2014.jsconf.eu/speakers/philip-roberts-what-the-heck-is-the-event-loop-anyway.html\",children:\"talk on the Event Loop\"}),\", you should. It is one of the most viewed videos on JavaScript.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"For a visual demonstration of the event loop, accounting for different types of tasks, check out Jake Archibald's talk titled \",(0,t.jsx)(e.a,{href:\"https://www.youtube.com/watch?v=cCOL7MC4Pl0\",children:'\"In The Loop\"'}),\".\"]}),`\n`,(0,t.jsx)(e.hr,{}),`\n`,(0,t.jsx)(e.h2,{children:\"Event loop in JavaScript\"}),`\n`,(0,t.jsx)(e.p,{children:\"The event loop is the heart of JavaScript's asynchronous operation. It's is a mechanism in JavaScript that handles the execution of code, allowing for asynchronous operations and ensuring that the single-threaded nature of JavaScript does not block the execution of the program.\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"To understand it better we need to understand about all the parts of the system. Here is an excellent illustration by \",(0,t.jsx)(e.a,{href:\"https://x.com/lydiahallie\",children:\"Lydia Hallie\"})]}),`\n`,(0,t.jsx)(e.p,{children:(0,t.jsx)(e.img,{src:\"https://github.com/yangshun/front-end-interview-handbook/blob/main/assets/javascript-runtime.png\",alt:\"event loop and call stack\"})}),`\n`,(0,t.jsx)(e.h3,{children:\"Call stack\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"Call stack keeps track of the functions being executed in a program. When a function is called, it is added to the top of the call stack. When the function completes, it is removed from the call stack. This allows the program to keep track of where it is in the execution of a function and return to the correct location when the function completes. As the name suggests it is a \",(0,t.jsx)(e.code,{children:\"Stack\"}),\" data structure which follows \",(0,t.jsx)(e.code,{children:\"last in first out\"})]}),`\n`,(0,t.jsx)(e.h3,{children:\"Task queue\"}),`\n`,(0,t.jsx)(e.p,{children:\"The task queue, also known as the macro task queue or event queue, is a queue that holds tasks that need to be executed. These tasks are typically asynchronous operations, such as setTimeout, setInterval, and event handlers.\"}),`\n`,(0,t.jsx)(e.h3,{children:\"Macro tasks\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"Macro tasks are tasks that are added to the task queue and executed one by one in the order they were added. Point to note here is that these macro tasks will be executed after \",(0,t.jsx)(e.code,{children:\"micro tasks\"})]}),`\n`,(0,t.jsx)(e.h4,{children:\"Macro task examples\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:\"setTimeout\"}),`\n`,(0,t.jsx)(e.li,{children:\"setInterval\"}),`\n`,(0,t.jsx)(e.li,{children:\"I/O events\"}),`\n`,(0,t.jsx)(e.li,{children:\"UI rendering (in browsers)\"}),`\n`]}),`\n`,(0,t.jsx)(e.h3,{children:\"Micro tasks\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"Micro tasks are tasks that have a higher priority than macro tasks and are executed immediately after the currently executing script is completed and before the next macro task is executed. Micro tasks are usually used for more immediate, lightweight operations that should be executed as soon as possible after the current operation completes. There is a dedicated \",(0,t.jsx)(e.code,{children:\"micro task queue\"}),\" for micro tasks.\"]}),`\n`,(0,t.jsx)(e.h4,{children:\"Micro task examples\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:\"Promises (with then, catch, and finally)\"}),`\n`,(0,t.jsx)(e.li,{children:\"MutationObserver callbacks\"}),`\n`]}),`\n`,(0,t.jsx)(e.h2,{children:\"How everything work together\"}),`\n`,(0,t.jsxs)(e.ol,{children:[`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"Execution Starts\"}),\": JavaScript starts executing the code in the global context.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"Call Stack\"}),\": As functions are called, they are pushed onto the call stack.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"Async Operations\"}),\": When an asynchronous operation is encountered (e.g., setTimeout, a promise), the corresponding callback is sent to the appropriate task queue.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"Event Loop\"}),\": The event loop continuously checks if the call stack is empty.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"Micro Tasks First\"}),\": If the call stack is empty, the event loop first processes all the micro tasks.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"Macro Tasks\"}),\": Once all micro tasks are processed, the event loop will then take the first macro task from the task queue and push it onto the call stack for execution.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"Repeat\"}),\": This process repeats, ensuring a smooth and controlled execution of asynchronous operations.\"]}),`\n`]}),`\n`,(0,t.jsx)(e.h2,{children:\"Example\"}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-js\",children:`console.log('Start');\n\nsetTimeout(() => {\n  console.log('Timeout 1');\n}, 0);\n\nPromise.resolve().then(() => {\n  console.log('Promise 1');\n});\n\nsetTimeout(() => {\n  console.log('Timeout 2');\n}, 0);\n\nconsole.log('End');\n`})}),`\n`,(0,t.jsx)(e.h3,{children:\"Execution order\"}),`\n`,(0,t.jsxs)(e.ol,{children:[`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:\"Start\"}),\" and \",(0,t.jsx)(e.code,{children:\"End\"}),\" are logged first because they are part of the initial script.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:\"Promise 1\"}),\" is logged next because promises are micro tasks and micro tasks are executed immediately after the current script.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:\"Timeout 1\"}),\" and \",(0,t.jsx)(e.code,{children:\"Timeout 2\"}),\" are logged last because they are macro tasks and are processed after the micro tasks.\"]}),`\n`]}),`\n`,(0,t.jsx)(e.h2,{children:\"Further reading and resources\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Event_loop\",children:\"The event loop - MDN\"})}),`\n`,(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:\"https://javascript.info/event-loop\",children:\"Event loop: microtasks and macrotasks\"})}),`\n`,(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:\"https://www.youtube.com/watch?v=eiC58R16hb8\",children:\"JavaScript Visualized - Event Loop, Web APIs, (Micro)task Queue by Lydia Hallie\"})}),`\n`,(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:\"https://2014.jsconf.eu/speakers/philip-roberts-what-the-heck-is-the-event-loop-anyway.html\",children:\"Philip Robert's talk on the Event Loop\"})}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.a,{href:\"https://www.youtube.com/watch?v=cCOL7MC4Pl0\",children:\"In The Loop by Jake Archibald\"}),\".\"]}),`\n`,(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:\"https://dev.to/lydiahallie/javascript-visualized-event-loop-3dif\",children:\"JavaScript Visualized: Event Loop\"})}),`\n`]})]})}function w(n={}){let{wrapper:e}=n.components||{};return e?(0,t.jsx)(e,Object.assign({},n,{children:(0,t.jsx)(h,n)})):h(n)}var x=w;return y(T);})();\n;return Component;"
}