{
  "description": null,
  "format": "quiz",
  "metadata": {
    "author": null,
    "companies": [],
    "created": 1630800000,
    "difficulty": "medium",
    "duration": 5,
    "excerpt": null,
    "featured": false,
    "format": "quiz",
    "frameworkDefault": null,
    "frameworks": [],
    "href": "/questions/quiz/explain-hoisting",
    "importance": "high",
    "languages": [],
    "nextQuestions": [],
    "premium": false,
    "published": true,
    "ranking": 100,
    "similarQuestions": [],
    "slug": "explain-hoisting",
    "subtitle": null,
    "title": "Explain \"hoisting\"",
    "topics": [
      "javascript"
    ]
  },
  "solution": "var Component=(()=>{var h=Object.create;var a=Object.defineProperty;var f=Object.getOwnPropertyDescriptor;var u=Object.getOwnPropertyNames;var p=Object.getPrototypeOf,g=Object.prototype.hasOwnProperty;var m=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),b=(n,e)=>{for(var i in e)a(n,i,{get:e[i],enumerable:!0})},c=(n,e,i,r)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let t of u(e))!g.call(n,t)&&t!==i&&a(n,t,{get:()=>e[t],enumerable:!(r=f(e,t))||r.enumerable});return n};var v=(n,e,i)=>(i=n!=null?h(p(n)):{},c(e||!n||!n.__esModule?a(i,\"default\",{value:n,enumerable:!0}):i,n)),x=n=>c(a({},\"__esModule\",{value:!0}),n);var s=m((_,l)=>{l.exports=_jsx_runtime});var j={};b(j,{default:()=>O,frontmatter:()=>w});var o=v(s()),w={title:'Explain \"hoisting\"'};function d(n){let e=Object.assign({p:\"p\",code:\"code\",pre:\"pre\"},n.components);return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(e.p,{children:[\"Hoisting is a term used to explain the behavior of variable declarations in your code. Variables declared or initialized with the \",(0,o.jsx)(e.code,{children:\"var\"}),' keyword will have their declaration \"moved\" up to the top of their module/function-level scope, which we refer to as hoisting. However, only the declaration is hoisted, the assignment (if there is one), will stay where it is.']}),`\n`,(0,o.jsx)(e.p,{children:\"Note that the declaration is not actually moved - the JavaScript engine parses the declarations during compilation and becomes aware of declarations and their scopes. It is just easier to understand this behavior by visualizing the declarations as being hoisted to the top of their scope. Let's explain with a few examples.\"}),`\n`,(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:\"language-js\",children:`console.log(foo); // undefined\nvar foo = 1;\nconsole.log(foo); // 1\n`})}),`\n`,(0,o.jsx)(e.p,{children:\"Function declarations have the body hoisted while the function expressions (written in the form of variable declarations) only has the variable declaration hoisted.\"}),`\n`,(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:\"language-js\",children:`// Function Declaration\nconsole.log(foo); // [Function: foo]\nfoo(); // 'FOOOOO'\nfunction foo() {\n  console.log('FOOOOO');\n}\nconsole.log(foo); // [Function: foo]\n\n// Function Expression\nconsole.log(bar); // undefined\nbar(); // Uncaught TypeError: bar is not a function\nvar bar = function () {\n  console.log('BARRRR');\n};\nconsole.log(bar); // [Function: bar]\n`})}),`\n`,(0,o.jsxs)(e.p,{children:[\"Variables declared via \",(0,o.jsx)(e.code,{children:\"let\"}),\" and \",(0,o.jsx)(e.code,{children:\"const\"}),\" are hoisted as well. However, unlike \",(0,o.jsx)(e.code,{children:\"var\"}),\" and \",(0,o.jsx)(e.code,{children:\"function\"}),\", they are not initialized and accessing them before the declaration will result in a \",(0,o.jsx)(e.code,{children:\"ReferenceError\"}),' exception. The variable is in a \"temporal dead zone\" from the start of the block until the declaration is processed.']}),`\n`,(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:\"language-js\",children:`x; // undefined\ny; // Reference error: y is not defined\n\nvar x = 'local';\nlet y = 'local';\n`})})]})}function y(n={}){let{wrapper:e}=n.components||{};return e?(0,o.jsx)(e,Object.assign({},n,{children:(0,o.jsx)(d,n)})):d(n)}var O=y;return x(j);})();\n;return Component;"
}