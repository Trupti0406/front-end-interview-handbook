{
  "description": null,
  "format": "quiz",
  "metadata": {
    "author": null,
    "companies": [],
    "created": 1630800000,
    "difficulty": "easy",
    "duration": 5,
    "excerpt": null,
    "featured": false,
    "format": "quiz",
    "frameworkDefault": null,
    "frameworks": [],
    "href": "/questions/quiz/what-is-the-event-loop-and-how-does-it-relate-to-asynchronous-javascript",
    "importance": "low",
    "languages": [],
    "nextQuestions": [],
    "premium": false,
    "published": true,
    "ranking": 999,
    "similarQuestions": [],
    "slug": "what-is-the-event-loop-and-how-does-it-relate-to-asynchronous-javascript",
    "subtitle": null,
    "title": "What is the event loop and how does it relate to asynchronous JavaScript?",
    "topics": [
      "javascript"
    ],
    "gitHubEditUrl": "https://github.com/yangshun/top-javascript-interview-questions/blob/main/questions/what-is-the-event-loop-and-how-does-it-relate-to-asynchronous-javascript/en-US.mdx"
  },
  "solution": "var Component=(()=>{var d=Object.create;var a=Object.defineProperty;var u=Object.getOwnPropertyDescriptor;var p=Object.getOwnPropertyNames;var m=Object.getPrototypeOf,g=Object.prototype.hasOwnProperty;var k=(o,e)=>()=>(e||o((e={exports:{}}).exports,e),e.exports),v=(o,e)=>{for(var t in e)a(o,t,{get:e[t],enumerable:!0})},i=(o,e,t,c)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let l of p(e))!g.call(o,l)&&l!==t&&a(o,l,{get:()=>e[l],enumerable:!(c=u(e,l))||c.enumerable});return o};var f=(o,e,t)=>(t=o!=null?d(m(o)):{},i(e||!o||!o.__esModule?a(t,\"default\",{value:o,enumerable:!0}):t,o)),y=o=>i(a({},\"__esModule\",{value:!0}),o);var r=k((P,s)=>{s.exports=_jsx_runtime});var x={};v(x,{default:()=>T,frontmatter:()=>b});var n=f(r()),b={title:\"What is the event loop and how does it relate to asynchronous JavaScript?\"};function h(o){let e=Object.assign({h2:\"h2\",p:\"p\",code:\"code\",hr:\"hr\",h3:\"h3\",ol:\"ol\",li:\"li\",strong:\"strong\",ul:\"ul\",pre:\"pre\",a:\"a\"},o.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.h2,{children:\"TL;DR\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"The event loop is a fundamental concept in JavaScript that allows for non-blocking asynchronous operations. It continuously checks the call stack to see if there's any function that needs to run. If the call stack is empty, it will look at the task queue to see if there are any pending tasks to execute. This mechanism enables JavaScript to handle asynchronous operations like \",(0,n.jsx)(e.code,{children:\"setTimeout\"}),\", \",(0,n.jsx)(e.code,{children:\"Promises\"}),\", and \",(0,n.jsx)(e.code,{children:\"async/await\"}),\" without blocking the main thread.\"]}),`\n`,(0,n.jsx)(e.hr,{}),`\n`,(0,n.jsx)(e.h2,{children:\"What is the event loop and how does it relate to asynchronous JavaScript?\"}),`\n`,(0,n.jsx)(e.h3,{children:\"Understanding the event loop\"}),`\n`,(0,n.jsx)(e.p,{children:\"The event loop is a core part of JavaScript's runtime environment, responsible for handling asynchronous operations. JavaScript is single-threaded, meaning it can execute one piece of code at a time. The event loop allows JavaScript to perform non-blocking operations by managing the execution of multiple tasks.\"}),`\n`,(0,n.jsx)(e.h3,{children:\"How the event loop works\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Call stack\"}),\": This is where the JavaScript engine keeps track of function calls. When a function is called, it is added to the call stack. When the function returns, it is removed from the call stack.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Web APIs\"}),\": These are browser-provided APIs like \",(0,n.jsx)(e.code,{children:\"setTimeout\"}),\", \",(0,n.jsx)(e.code,{children:\"fetch\"}),\", and DOM events. When an asynchronous operation is called, it is handled by these Web APIs.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Task queue (or callback queue)\"}),\": This is where the results of asynchronous operations are queued. Once the Web API completes an operation, it places the callback function in the task queue.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Event loop\"}),\": The event loop continuously checks the call stack and the task queue. If the call stack is empty, it will take the first task from the task queue and push it onto the call stack for execution.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h3,{children:\"Asynchronous operations in JavaScript\"}),`\n`,(0,n.jsx)(e.p,{children:\"JavaScript uses the event loop to handle various asynchronous operations:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsxs)(e.strong,{children:[(0,n.jsx)(e.code,{children:\"setTimeout\"}),\" and \",(0,n.jsx)(e.code,{children:\"setInterval\"})]}),\": These functions allow you to schedule code to run after a specified delay.\",`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`setTimeout(() => {\n  console.log('This runs after 1 second');\n}, 1000);\n`})}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Promises\"}),\": Promises represent a value that may be available now, or in the future, or never. They allow you to handle asynchronous operations more gracefully.\",`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`new Promise((resolve, reject) => {\n  setTimeout(() => {\n    resolve('Promise resolved');\n  }, 1000);\n}).then((message) => {\n  console.log(message);\n});\n`})}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:(0,n.jsx)(e.code,{children:\"async/await\"})}),\": These keywords provide a way to work with Promises more comfortably, making asynchronous code look synchronous.\",`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`async function fetchData() {\n  const response = await fetch('https://api.example.com/data');\n  const data = await response.json();\n  console.log(data);\n}\nfetchData();\n`})}),`\n`]}),`\n`]}),`\n`,(0,n.jsx)(e.h3,{children:\"Event loop in action\"}),`\n`,(0,n.jsx)(e.p,{children:\"Consider the following example to see the event loop in action:\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`console.log('Start');\n\nsetTimeout(() => {\n  console.log('Timeout callback');\n}, 0);\n\nPromise.resolve().then(() => {\n  console.log('Promise callback');\n});\n\nconsole.log('End');\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"The output will be:\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{children:`Start\nEnd\nPromise callback\nTimeout callback\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"Here's what happens:\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"console.log('Start')\"}),\" is executed and added to the call stack.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"setTimeout\"}),\" is called, and its callback is sent to the Web API.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"Promise.resolve().then\"}),\" is called, and its callback is added to the microtask queue.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"console.log('End')\"}),\" is executed and added to the call stack.\"]}),`\n`,(0,n.jsx)(e.li,{children:\"The call stack is now empty, so the event loop checks the microtask queue and executes the Promise callback.\"}),`\n`,(0,n.jsxs)(e.li,{children:[\"Finally, the event loop checks the task queue and executes the \",(0,n.jsx)(e.code,{children:\"setTimeout\"}),\" callback.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"Further reading\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop\",children:\"MDN Web Docs: Concurrency model and the event loop\"})}),`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://javascript.info/event-loop\",children:\"JavaScript.info: Event loop\"})}),`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/\",children:\"Node.js: Understanding the event loop\"})}),`\n`]})]})}function w(o={}){let{wrapper:e}=o.components||{};return e?(0,n.jsx)(e,Object.assign({},o,{children:(0,n.jsx)(h,o)})):h(o)}var T=w;return y(x);})();\n;return Component;"
}