{
  "description": null,
  "format": "quiz",
  "metadata": {
    "author": null,
    "companies": [],
    "created": 1630800000,
    "difficulty": "medium",
    "duration": 5,
    "excerpt": null,
    "featured": false,
    "format": "quiz",
    "frameworkDefault": null,
    "frameworks": [],
    "href": "/questions/quiz/difference-between-function-person-var-person-person-and-var-person-new-person",
    "importance": "mid",
    "languages": [],
    "nextQuestions": [],
    "premium": false,
    "published": true,
    "ranking": 100,
    "similarQuestions": [],
    "slug": "difference-between-function-person-var-person-person-and-var-person-new-person",
    "subtitle": null,
    "title": "Difference between: `function Person(){}`, `var person = Person()`, and `var person = new Person()`?",
    "topics": [
      "javascript"
    ]
  },
  "solution": "var Component=(()=>{var l=Object.create;var s=Object.defineProperty;var u=Object.getOwnPropertyDescriptor;var p=Object.getOwnPropertyNames;var f=Object.getPrototypeOf,m=Object.prototype.hasOwnProperty;var g=(e,n)=>()=>(n||e((n={exports:{}}).exports,n),n.exports),P=(e,n)=>{for(var t in n)s(e,t,{get:n[t],enumerable:!0})},a=(e,n,t,c)=>{if(n&&typeof n==\"object\"||typeof n==\"function\")for(let r of p(n))!m.call(e,r)&&r!==t&&s(e,r,{get:()=>n[r],enumerable:!(c=u(n,r))||c.enumerable});return e};var v=(e,n,t)=>(t=e!=null?l(f(e)):{},a(n||!e||!e.__esModule?s(t,\"default\",{value:e,enumerable:!0}):t,e)),j=e=>a(s({},\"__esModule\",{value:!0}),e);var d=g((_,i)=>{i.exports=_jsx_runtime});var x={};P(x,{default:()=>w,frontmatter:()=>b});var o=v(d()),b={title:\"Difference between: `function Person(){}`, `var person = Person()`, and `var person = new Person()`?\"};function h(e){let n=Object.assign({p:\"p\",code:\"code\",pre:\"pre\"},e.components);return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(n.p,{children:[\"This question is pretty vague. Our best guess at its intention is that it is asking about constructors in JavaScript. Technically speaking, \",(0,o.jsx)(n.code,{children:\"function Person(){}\"}),\" is just a normal function declaration. The convention is to use PascalCase for functions that are intended to be used as constructors.\"]}),`\n`,(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:\"var person = Person()\"}),\" invokes the \",(0,o.jsx)(n.code,{children:\"Person\"}),\" as a function, and not as a constructor. Invoking as such is a common mistake if the function is intended to be used as a constructor. Typically, the constructor does not return anything, hence invoking the constructor like a normal function will return \",(0,o.jsx)(n.code,{children:\"undefined\"}),\" and that gets assigned to the variable intended as the instance.\"]}),`\n`,(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:\"var person = new Person()\"}),\" creates an instance of the \",(0,o.jsx)(n.code,{children:\"Person\"}),\" object using the \",(0,o.jsx)(n.code,{children:\"new\"}),\" operator, which inherits from \",(0,o.jsx)(n.code,{children:\"Person.prototype\"}),\". An alternative would be to use \",(0,o.jsx)(n.code,{children:\"Object.create\"}),\", such as: \",(0,o.jsx)(n.code,{children:\"Object.create(Person.prototype)\"}),\".\"]}),`\n`,(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:\"language-js\",children:`function Person(name) {\n  this.name = name;\n}\n\nvar person = Person('John');\nconsole.log(person); // undefined\nconsole.log(person.name); // Uncaught TypeError: Cannot read property 'name' of undefined\n\nvar person = new Person('John');\nconsole.log(person); // Person { name: \"John\" }\nconsole.log(person.name); // \"john\"\n`})})]})}function y(e={}){let{wrapper:n}=e.components||{};return n?(0,o.jsx)(n,Object.assign({},e,{children:(0,o.jsx)(h,e)})):h(e)}var w=y;return j(x);})();\n;return Component;"
}