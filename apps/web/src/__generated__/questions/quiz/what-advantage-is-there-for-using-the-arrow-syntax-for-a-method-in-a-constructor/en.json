{
  "description": null,
  "format": "quiz",
  "metadata": {
    "author": null,
    "companies": [],
    "created": 1630800000,
    "difficulty": "medium",
    "duration": 5,
    "excerpt": null,
    "featured": false,
    "format": "quiz",
    "frameworkDefault": null,
    "frameworks": [],
    "href": "/questions/quiz/what-advantage-is-there-for-using-the-arrow-syntax-for-a-method-in-a-constructor",
    "importance": "mid",
    "languages": [],
    "nextQuestions": [],
    "premium": false,
    "published": true,
    "ranking": 100,
    "similarQuestions": [],
    "slug": "what-advantage-is-there-for-using-the-arrow-syntax-for-a-method-in-a-constructor",
    "title": "What advantage is there for using the arrow syntax for a method in a constructor?",
    "subtitle": null,
    "topics": [
      "javascript"
    ]
  },
  "solution": "var Component=(()=>{var l=Object.create;var s=Object.defineProperty;var m=Object.getOwnPropertyDescriptor;var u=Object.getOwnPropertyNames;var f=Object.getPrototypeOf,w=Object.prototype.hasOwnProperty;var y=(e,n)=>()=>(n||e((n={exports:{}}).exports,n),n.exports),p=(e,n)=>{for(var t in n)s(e,t,{get:n[t],enumerable:!0})},r=(e,n,t,i)=>{if(n&&typeof n==\"object\"||typeof n==\"function\")for(let o of u(n))!w.call(e,o)&&o!==t&&s(e,o,{get:()=>n[o],enumerable:!(i=m(n,o))||i.enumerable});return e};var v=(e,n,t)=>(t=e!=null?l(f(e)):{},r(n||!e||!e.__esModule?s(t,\"default\",{value:e,enumerable:!0}):t,e)),b=e=>r(s({},\"__esModule\",{value:!0}),e);var h=y((F,c)=>{c.exports=_jsx_runtime});var x={};p(x,{default:()=>N,frontmatter:()=>g});var a=v(h()),g={title:\"What advantage is there for using the arrow syntax for a method in a constructor?\"};function d(e){let n=Object.assign({p:\"p\",code:\"code\",pre:\"pre\",a:\"a\",h2:\"h2\",ul:\"ul\",li:\"li\"},e.components);return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(n.p,{children:[\"The main advantage of using an arrow function as a method inside a constructor is that the value of \",(0,a.jsx)(n.code,{children:\"this\"}),\" gets set at the time of the function creation and can't change after that. So, when the constructor is used to create a new object, \",(0,a.jsx)(n.code,{children:\"this\"}),\" will always refer to that object. For example, let's say we have a \",(0,a.jsx)(n.code,{children:\"Person\"}),\" constructor that takes a first name as an argument has two methods to \",(0,a.jsx)(n.code,{children:\"console.log\"}),\" that name, one as a regular function and one as an arrow function:\"]}),`\n`,(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:\"language-js\",children:`const Person = function (firstName) {\n  this.firstName = firstName;\n  this.sayName1 = function () {\n    console.log(this.firstName);\n  };\n  this.sayName2 = () => {\n    console.log(this.firstName);\n  };\n};\n\nconst john = new Person('John');\nconst dave = new Person('Dave');\n\njohn.sayName1(); // John\njohn.sayName2(); // John\n\n// The regular function can have its 'this' value changed, but the arrow function cannot\njohn.sayName1.call(dave); // Dave (because \"this\" is now the dave object)\njohn.sayName2.call(dave); // John\n\njohn.sayName1.apply(dave); // Dave (because 'this' is now the dave object)\njohn.sayName2.apply(dave); // John\n\njohn.sayName1.bind(dave)(); // Dave (because 'this' is now the dave object)\njohn.sayName2.bind(dave)(); // John\n\nvar sayNameFromWindow1 = john.sayName1;\nsayNameFromWindow1(); // undefined (because 'this' is now the window object)\n\nvar sayNameFromWindow2 = john.sayName2;\nsayNameFromWindow2(); // John\n`})}),`\n`,(0,a.jsxs)(n.p,{children:[\"The main takeaway here is that \",(0,a.jsx)(n.code,{children:\"this\"}),\" can be changed for a normal function, but the context always stays the same for an arrow function. So even if you are passing around your arrow function to different parts of your application, you wouldn't have to worry about the context changing.\"]}),`\n`,(0,a.jsxs)(n.p,{children:[\"This can be particularly helpful in React class components. If you define a class method for something such as a click handler using a normal function, and then you pass that click handler down into a child component as a prop, you will need to also bind \",(0,a.jsx)(n.code,{children:\"this\"}),' in the constructor of the parent component. If you instead use an arrow function, there is no need to also bind \"this\", as the method will automatically get its \"this\" value from its enclosing lexical context. (See this article for an excellent demonstration and sample code: ',(0,a.jsx)(n.a,{href:\"https://medium.com/@machnicki/handle-events-in-react-with-arrow-functions-ede88184bbb\",children:\"https://medium.com/@machnicki/handle-events-in-react-with-arrow-functions-ede88184bbb\"}),\")\"]}),`\n`,(0,a.jsx)(n.h2,{children:\"References\"}),`\n`,(0,a.jsxs)(n.ul,{children:[`\n`,(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:\"https://www.frontendinterviewhandbook.com/javascript-questions\",children:\"Front End Interview Handbook\"})}),`\n`]})]})}function j(e={}){let{wrapper:n}=e.components||{};return n?(0,a.jsx)(n,Object.assign({},e,{children:(0,a.jsx)(d,e)})):d(e)}var N=j;return b(x);})();\n;return Component;"
}