{
  "description": null,
  "format": "quiz",
  "metadata": {
    "author": null,
    "companies": [],
    "created": 1630800000,
    "difficulty": "medium",
    "duration": 5,
    "excerpt": null,
    "featured": false,
    "format": "quiz",
    "frameworkDefault": null,
    "frameworks": [],
    "href": "/questions/quiz/explain-how-prototypal-inheritance-works",
    "importance": "high",
    "languages": [],
    "nextQuestions": [],
    "premium": false,
    "published": true,
    "ranking": 1,
    "similarQuestions": [],
    "slug": "explain-how-prototypal-inheritance-works",
    "title": "Explain how prototypal inheritance works",
    "subtitle": null,
    "topics": [
      "javascript"
    ]
  },
  "solution": "var Component=(()=>{var s=Object.create;var c=Object.defineProperty;var p=Object.getOwnPropertyDescriptor;var m=Object.getOwnPropertyNames;var u=Object.getPrototypeOf,f=Object.prototype.hasOwnProperty;var _=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),j=(t,e)=>{for(var o in e)c(t,o,{get:e[o],enumerable:!0})},a=(t,e,o,i)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let r of m(e))!f.call(t,r)&&r!==o&&c(t,r,{get:()=>e[r],enumerable:!(i=p(e,r))||i.enumerable});return t};var g=(t,e,o)=>(o=t!=null?s(u(t)):{},a(e||!t||!t.__esModule?c(o,\"default\",{value:t,enumerable:!0}):o,t)),y=t=>a(c({},\"__esModule\",{value:!0}),t);var h=_((O,l)=>{l.exports=_jsx_runtime});var x={};j(x,{default:()=>w,frontmatter:()=>b});var n=g(h()),b={title:\"Explain how prototypal inheritance works\"};function d(t){let e=Object.assign({p:\"p\",code:\"code\",a:\"a\",h2:\"h2\",pre:\"pre\",ul:\"ul\",li:\"li\",em:\"em\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(e.p,{children:[\"This is an extremely common JavaScript interview question. All JavaScript objects have a \",(0,n.jsx)(e.code,{children:\"__proto__\"}),\" property with the exception of objects created with \",(0,n.jsx)(e.code,{children:\"Object.create(null)\"}),`, that is a reference to another object, which is called the object's \"prototype\". When a property is accessed on an object and if the property is not found on that object, the JavaScript engine looks at the object's `,(0,n.jsx)(e.code,{children:\"__proto__\"}),\", and the \",(0,n.jsx)(e.code,{children:\"__proto__\"}),\"'s \",(0,n.jsx)(e.code,{children:\"__proto__\"}),\" and so on, until it finds the property defined on one of the \",(0,n.jsx)(e.code,{children:\"__proto__\"}),\"s or until it reaches the end of the prototype chain. This behavior simulates classical inheritance, but it is really more of \",(0,n.jsx)(e.a,{href:\"https://davidwalsh.name/javascript-objects\",children:\"delegation than inheritance\"}),\".\"]}),`\n`,(0,n.jsx)(e.h2,{children:\"Example of Prototypal Inheritance\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`function Parent() {\n  this.name = 'Parent';\n}\n\nParent.prototype.greet = function () {\n  console.log('Hello from ' + this.name);\n};\n\nconst child = Object.create(Parent.prototype);\n\n// Call parent constructor with child\nParent.call(child);\n\nchild.cry = function () {\n  console.log('waaaaaahhhh!');\n};\n\nchild.cry();\n// waaaaaahhhh!\n\nchild.greet();\n// hello from Parent\n\nchild.constructor;\n// \\u0192 Parent() {\n//   this.name = 'Parent';\n// }\n\nchild.constructor.name;\n// 'Parent'\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"Things to note are:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\".greet\"}),\" is not defined on the \",(0,n.jsx)(e.em,{children:\"child\"}),\", so the engine goes up the prototype chain and finds \",(0,n.jsx)(e.code,{children:\".greet\"}),\" off the inherited from \",(0,n.jsx)(e.em,{children:\"Parent\"}),\".\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"We need to call \",(0,n.jsx)(e.code,{children:\"Object.create\"}),\" in one of following ways for the prototype methods to be inherited:\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Object.create(Parent.prototype);\"}),`\n`,(0,n.jsx)(e.li,{children:\"Object.create(new Parent(null));\"}),`\n`,(0,n.jsx)(e.li,{children:\"Object.create(objLiteral);\"}),`\n`,(0,n.jsxs)(e.li,{children:[\"Currently, \",(0,n.jsx)(e.code,{children:\"child.constructor\"}),\" is pointing to the \",(0,n.jsx)(e.code,{children:\"Parent\"}),\":\"]}),`\n`]}),`\n`]}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:\"If we'd like to correct this, one option would be to do:\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`function Parent() {\n  this.name = 'Parent';\n}\n\nParent.prototype.greet = function () {\n  console.log('Hello from ' + this.name);\n};\n\nfunction Child() {\n  Parent.call(this);\n  this.name = 'Child';\n}\n\nChild.prototype = Object.create(Parent.prototype);\nChild.prototype.constructor = Child;\n\nconst child = new Child();\n\nchild.greet();\n// hello from Child\n\nchild.constructor.name;\n// 'Child'\n`})})]})}function P(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(d,t)})):d(t)}var w=P;return y(x);})();\n;return Component;"
}