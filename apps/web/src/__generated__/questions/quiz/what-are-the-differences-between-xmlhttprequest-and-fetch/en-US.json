{
  "description": null,
  "format": "quiz",
  "metadata": {
    "author": null,
    "companies": [],
    "created": 1630800000,
    "difficulty": "hard",
    "duration": 5,
    "excerpt": null,
    "featured": false,
    "format": "quiz",
    "frameworkDefault": null,
    "frameworks": [],
    "href": "/questions/quiz/what-are-the-differences-between-xmlhttprequest-and-fetch",
    "importance": "mid",
    "languages": [],
    "nextQuestions": [],
    "premium": false,
    "published": true,
    "ranking": 100,
    "similarQuestions": [],
    "slug": "what-are-the-differences-between-xmlhttprequest-and-fetch",
    "subtitle": null,
    "title": "What are the differences between `XMLHttpRequest` and `fetch`?",
    "topics": [
      "javascript",
      "network"
    ]
  },
  "solution": "var Component=(()=>{var a=Object.create;var c=Object.defineProperty;var p=Object.getOwnPropertyDescriptor;var u=Object.getOwnPropertyNames;var g=Object.getPrototypeOf,f=Object.prototype.hasOwnProperty;var m=(r,e)=>()=>(e||r((e={exports:{}}).exports,e),e.exports),b=(r,e)=>{for(var t in e)c(r,t,{get:e[t],enumerable:!0})},h=(r,e,t,s)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let o of u(e))!f.call(r,o)&&o!==t&&c(r,o,{get:()=>e[o],enumerable:!(s=p(e,o))||s.enumerable});return r};var R=(r,e,t)=>(t=r!=null?a(g(r)):{},h(e||!r||!r.__esModule?c(t,\"default\",{value:r,enumerable:!0}):t,r)),q=r=>h(c({},\"__esModule\",{value:!0}),r);var i=m((v,d)=>{d.exports=_jsx_runtime});var L={};b(L,{default:()=>H,frontmatter:()=>y});var n=R(i()),y={title:\"What are the differences between `XMLHttpRequest` and `fetch`?\"};function l(r){let e=Object.assign({p:\"p\",strong:\"strong\",code:\"code\",h3:\"h3\",ul:\"ul\",li:\"li\",hr:\"hr\",h2:\"h2\",h4:\"h4\",pre:\"pre\",a:\"a\"},r.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.p,{children:(0,n.jsx)(e.strong,{children:\"TL;DR\"})}),`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.code,{children:\"XMLHttpRequest\"}),\" (XHR) and \",(0,n.jsx)(e.code,{children:\"fetch\"}),\" API are both used for asynchronous HTTP requests in JavaScript. \",(0,n.jsx)(e.code,{children:\"fetch\"}),\" offers a cleaner syntax, promise-based approach, and more modern feature set compared to XHR.\"]}),`\n`,(0,n.jsx)(e.h3,{children:\"Differences\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"XMLHttpRequest\"}),\" uses event listeners, while \",(0,n.jsx)(e.code,{children:\"fetch\"}),\" utilizes promise chaining.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"fetch\"}),\" provides more flexibility in headers and request bodies.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"fetch\"}),\" support cleaner error handling with \",(0,n.jsx)(e.code,{children:\"catch()\"}),\".\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Handling caching with \",(0,n.jsx)(e.code,{children:\"XMLHttpRequest\"}),\" is difficult but caching is supported by \",(0,n.jsx)(e.code,{children:\"fetch\"}),\" by default in the second parameter of the init object.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"fetch\"}),\" requires an AbortController for cancellation, while for \",(0,n.jsx)(e.code,{children:\"XMLHttpRequest\"}),\", it provides \",(0,n.jsx)(e.code,{children:\"abort()\"}),\" property.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"XMLHttpRequest\"}),\" supports progress tracking, which \",(0,n.jsx)(e.code,{children:\"fetch\"}),\" lacks.\"]}),`\n`]}),`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.code,{children:\"fetch\"}),\" is preferred for its cleaner syntax and modern features.\"]}),`\n`,(0,n.jsx)(e.hr,{}),`\n`,(0,n.jsxs)(e.p,{children:[\"Both \",(0,n.jsx)(e.code,{children:\"XMLHttpRequest\"}),\" (XHR) and \",(0,n.jsx)(e.code,{children:\"fetch\"}),\" API are methods for making asynchronous HTTP requests in JavaScript. However, they differ significantly in syntax, promise handling, and feature set.\"]}),`\n`,(0,n.jsx)(e.h2,{children:\"Differences\"}),`\n`,(0,n.jsx)(e.h3,{children:\"Syntax and Usage\"}),`\n`,(0,n.jsx)(e.h4,{children:(0,n.jsx)(e.code,{children:\"XMLHttpRequest\"})}),`\n`,(0,n.jsx)(e.p,{children:\"It is Event-driven and requires attaching event listeners to handle response/error states. The basic syntax for creating an XMLHttpRequest object and sending a request is as follows:\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`const xhr = new XMLHttpRequest();\nxhr.open('GET', 'YOUR_API_URL', true);\nxhr.responseType = 'json';\nxhr.onload = function () {\n  if (xhr.status === 200) {\n    console.log(xhr.response);\n  }\n};\nxhr.send();\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.code,{children:\"xhr\"}),\" is an instance of the \",(0,n.jsx)(e.code,{children:\"XMLHttpRequest\"}),\" class. The \",(0,n.jsx)(e.code,{children:\"open\"}),\" method is used to specify the request method, URL, and whether the request should be asynchronous. The \",(0,n.jsx)(e.code,{children:\"onload\"}),\" event is used to handle the response, and the \",(0,n.jsx)(e.code,{children:\"send\"}),\" method is used to send the request.\"]}),`\n`,(0,n.jsx)(e.h4,{children:(0,n.jsx)(e.code,{children:\"fetch\"})}),`\n`,(0,n.jsxs)(e.p,{children:[\"It provides a more straightforward and intuitive way of making HTTP requests. It is a promise-based and returns a promise that resolves with the response or rejects with an error. The basic syntax for making a GET request using \",(0,n.jsx)(e.code,{children:\"fetch\"}),\" is as follows:\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`fetch('YOUR_API_URL')\n  .then((response) => response.text())\n  .then((data) => console.log(data));\n`})}),`\n`,(0,n.jsx)(e.h3,{children:\"Request headers\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"Both \",(0,n.jsx)(e.code,{children:\"XMLHttpRequest\"}),\" and \",(0,n.jsx)(e.code,{children:\"fetch\"}),\" support setting request headers. However, \",(0,n.jsx)(e.code,{children:\"fetch\"}),\" provides more flexibility in terms of setting headers, as it supports custom headers and allows for more complex header configurations.\"]}),`\n`,(0,n.jsx)(e.h4,{children:(0,n.jsx)(e.code,{children:\"XMLHttpRequest\"})}),`\n`,(0,n.jsxs)(e.p,{children:[\"It supports setting request headers using the \",(0,n.jsx)(e.code,{children:\"setRequestHeader\"}),\" method:\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`xhr.setRequestHeader('Content-Type', 'application/json');\nxhr.setRequestHeader('Authorization', 'Bearer YOUR_TOKEN');\n`})}),`\n`,(0,n.jsx)(e.h4,{children:(0,n.jsx)(e.code,{children:\"fetch\"})}),`\n`,(0,n.jsxs)(e.p,{children:[\"Headers are passed as an object in the second argument to \",(0,n.jsx)(e.code,{children:\"fetch\"}),\":\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`fetch('YOUR_API_URL', {\n  method: 'POST',\n  headers: {\n    'Content-Type': 'application/json',\n    Authorization: 'Bearer YOUR_TOKEN',\n  },\n  body: JSON.stringify({\n    name: 'John Doe',\n    age: 30,\n  }),\n});\n`})}),`\n`,(0,n.jsx)(e.h3,{children:\"Request body\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"Both \",(0,n.jsx)(e.code,{children:\"XMLHttpRequest\"}),\" and \",(0,n.jsx)(e.code,{children:\"fetch\"}),\" support sending request bodies. However, Fetch provides more flexibility in terms of sending request bodies, as it supports sending JSON data, form data, and more.\"]}),`\n`,(0,n.jsx)(e.h4,{children:(0,n.jsx)(e.code,{children:\"XMLHttpRequest\"})}),`\n`,(0,n.jsxs)(e.p,{children:[\"It supports sending request bodies using the \",(0,n.jsx)(e.code,{children:\"send\"}),\" method:\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`xhr.send(\n  JSON.stringify({\n    name: 'John Doe',\n    age: 30,\n  }),\n);\n`})}),`\n`,(0,n.jsx)(e.h4,{children:(0,n.jsx)(e.code,{children:\"fetch\"})}),`\n`,(0,n.jsx)(e.p,{children:\"It supports sending request bodies using the body property:\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`fetch('YOUR_API_URL', {\n  method: 'POST',\n  headers: {\n    'Content-Type': 'application/json',\n  },\n  body: JSON.stringify({\n    name: 'John Doe',\n    age: 30,\n  }),\n});\n`})}),`\n`,(0,n.jsx)(e.h3,{children:\"Response handling\"}),`\n`,(0,n.jsx)(e.h4,{children:(0,n.jsx)(e.code,{children:\"XMLHttpRequest\"})}),`\n`,(0,n.jsxs)(e.p,{children:[\"It provides a \",(0,n.jsx)(e.code,{children:\"responseType\"}),\" property to set the response format that we are expecting. \",(0,n.jsx)(e.code,{children:\"responseType\"}),' is \"text\" by default but it support types likes \"text\", \"arraybuffer\", \"blob\", \"document\" and \"json\".']}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`const xhr = new XMLHttpRequest();\nxhr.open('GET', 'YOUR_API_URL', true);\nxhr.responseType = 'json';\nxhr.onload = function () {\n  if (xhr.status === 200) {\n    console.log(xhr.response);\n  }\n};\nxhr.send();\n`})}),`\n`,(0,n.jsx)(e.h4,{children:(0,n.jsx)(e.code,{children:\"fetch\"})}),`\n`,(0,n.jsxs)(e.p,{children:[\"However, \",(0,n.jsx)(e.code,{children:\"fetch\"}),\" provides a unified response object with \",(0,n.jsx)(e.code,{children:\"then\"}),\" method for accessing data.\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`fetch('YOUR_API_URL')\n  .then((response) => response.json())\n  .then((data) => console.log(data));\n`})}),`\n`,(0,n.jsx)(e.h3,{children:\"Error handling\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"Both support error handling but \",(0,n.jsx)(e.code,{children:\"fetch\"}),\" provides more flexibility in terms of error handling, as it supports handling errors using the \",(0,n.jsx)(e.code,{children:\"catch\"}),\" method.\"]}),`\n`,(0,n.jsx)(e.h4,{children:(0,n.jsx)(e.code,{children:\"XMLHttpRequest\"})}),`\n`,(0,n.jsxs)(e.p,{children:[\"It supports error handling using the \",(0,n.jsx)(e.code,{children:\"onerror\"}),\" event:\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`xhr.onerror = function () {\n  console.log('Error occurred');\n};\n`})}),`\n`,(0,n.jsx)(e.h4,{children:(0,n.jsx)(e.code,{children:\"fetch\"})}),`\n`,(0,n.jsxs)(e.p,{children:[\"It supports error handling using the \",(0,n.jsx)(e.code,{children:\"catch \"}),\"method:\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`fetch('YOUR_API_URL')\n    .then(response => response.json())\n    .then(data => console.log(data))\n    .catch(error => console.log('Error occurred: ' + error));\n    \\`\\`\\`\n`})}),`\n`,(0,n.jsx)(e.h3,{children:\"Caching Control\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"Handling caching with \",(0,n.jsx)(e.code,{children:\"XMLHttpRequest\"}),\" is difficult, and you might need to add a random value to the query string in order to get around the browser cache. Caching is supported by \",(0,n.jsx)(e.code,{children:\"fetch\"}),\" by default in the second parameter of the init object:\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`const res = await fetch('YOUR_API_URL', {\n  method: 'GET',\n  cache: 'default',\n});\n`})}),`\n`,(0,n.jsx)(e.h3,{children:\"Cancellation\"}),`\n`,(0,n.jsx)(e.h4,{children:(0,n.jsx)(e.code,{children:\"XMLHttpRequest\"})}),`\n`,(0,n.jsxs)(e.p,{children:[\"An in-flight request can be cancelled by running the \",(0,n.jsx)(e.code,{children:\"XMLHttpRequest\"}),\" \",(0,n.jsx)(e.code,{children:\"abort()\"}),\" method. An \",(0,n.jsx)(e.code,{children:\"abort\"}),\" handler can be attached if necessary:\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`const xhr = new XMLHttpRequest();\nxhr.open('GET', 'YOUR_API_URL');\nxhr.send();\n// ...\nxhr.onabort = () => console.log('aborted');\nxhr.abort();\n`})}),`\n`,(0,n.jsx)(e.h4,{children:(0,n.jsx)(e.code,{children:\"fetch\"})}),`\n`,(0,n.jsxs)(e.p,{children:[\"You can abort a \",(0,n.jsx)(e.code,{children:\"fetch\"}),\" but it requires a \",(0,n.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/API/AbortController\",children:\"AbortController\"}),\" object. But soon, it going to support abort using \",(0,n.jsx)(e.code,{children:\"fetch\"}),\" directly according to this \",(0,n.jsx)(e.a,{href:\"https://hacks.mozilla.org/2015/03/this-api-is-so-fetching/\",children:\"post\"}),\".\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`const controller = new AbortController();\nconst signal = controller.signal;\n\nfetch('YOUR_API_URL', { signal })\n  .then((response) => response.json())\n  .then((data) => console.log(data))\n  .catch((error) => console.log('Error occurred: ' + error));\n\n// abort request\ncontroller.abort();\n`})}),`\n`,(0,n.jsx)(e.h3,{children:\"Progress support\"}),`\n`,(0,n.jsx)(e.h4,{children:(0,n.jsx)(e.code,{children:\"XMLHttpRequest\"})}),`\n`,(0,n.jsxs)(e.p,{children:[\"It supports tracking the progress of requests by attaching a handler to the \",(0,n.jsx)(e.code,{children:\"XMLHttpRequest\"}),\" object's progress event. This is especially useful when uploading large files such as videos to track the progress of the upload.\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`const xhr = new XMLHttpRequest();\n\n// progress event\nxhr.upload.onprogress = (p) => {\n  console.log(Math.round((p.loaded / p.total) * 100) + '%');\n};\n`})}),`\n`,(0,n.jsx)(e.h4,{children:(0,n.jsx)(e.code,{children:\"fetch\"})}),`\n`,(0,n.jsxs)(e.p,{children:[\"However, the \",(0,n.jsx)(e.code,{children:\"fetch\"}),\" API does not offer any way to track upload progress. But it is going to be available sooner or later according to this \",(0,n.jsx)(e.a,{href:\"https://hacks.mozilla.org/2015/03/this-api-is-so-fetching/\",children:\"post\"}),\".\"]}),`\n`,(0,n.jsxs)(e.h2,{children:[\"Choosing between \",(0,n.jsx)(e.code,{children:\"XMLHttpRequest\"}),\" and \",(0,n.jsx)(e.code,{children:\"fetch\"})]}),`\n`,(0,n.jsxs)(e.p,{children:[\"In most modern development scenarios, \",(0,n.jsx)(e.code,{children:\"fetch\"}),\" API is the preferred choice due to its cleaner syntax, promise-based approach, and improved handling of features like error handling, headers, and CORS.\"]}),`\n`,(0,n.jsx)(e.h2,{children:\"Further reading\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch\",children:\"Fetch API | MDN\"})}),`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest\",children:\"XMLHttpRequest | MDN\"})}),`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/API/Request/cache\",children:\"Request: cache property | MDN\"})}),`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://javascript.info/xmlhttprequest\",children:\"XMLHttpRequest | Javascript.info\"})}),`\n`]})]})}function x(r={}){let{wrapper:e}=r.components||{};return e?(0,n.jsx)(e,Object.assign({},r,{children:(0,n.jsx)(l,r)})):l(r)}var H=x;return q(L);})();\n;return Component;"
}