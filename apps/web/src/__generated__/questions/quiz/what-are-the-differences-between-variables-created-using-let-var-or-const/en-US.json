{
  "description": null,
  "format": "quiz",
  "metadata": {
    "author": null,
    "companies": [
      "microsoft"
    ],
    "created": 1630800000,
    "difficulty": "medium",
    "duration": 5,
    "excerpt": null,
    "featured": false,
    "format": "quiz",
    "frameworkDefault": null,
    "frameworks": [],
    "href": "/questions/quiz/what-are-the-differences-between-variables-created-using-let-var-or-const",
    "importance": "high",
    "languages": [],
    "nextQuestions": [],
    "premium": false,
    "published": true,
    "ranking": 1,
    "similarQuestions": [],
    "slug": "what-are-the-differences-between-variables-created-using-let-var-or-const",
    "title": "What are the differences between variables created using `let`, `var` or `const`?",
    "subtitle": null,
    "topics": [
      "javascript"
    ]
  },
  "solution": "var Component=(()=>{var b=Object.create;var c=Object.defineProperty;var h=Object.getOwnPropertyDescriptor;var f=Object.getOwnPropertyNames;var u=Object.getPrototypeOf,g=Object.prototype.hasOwnProperty;var x=(o,e)=>()=>(e||o((e={exports:{}}).exports,e),e.exports),z=(o,e)=>{for(var r in e)c(o,r,{get:e[r],enumerable:!0})},i=(o,e,r,l)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let a of f(e))!g.call(o,a)&&a!==r&&c(o,a,{get:()=>e[a],enumerable:!(l=h(e,a))||l.enumerable});return o};var p=(o,e,r)=>(r=o!=null?b(u(o)):{},i(e||!o||!o.__esModule?c(r,\"default\",{value:o,enumerable:!0}):r,o)),m=o=>i(c({},\"__esModule\",{value:!0}),o);var s=x((E,t)=>{t.exports=_jsx_runtime});var y={};z(y,{default:()=>j,frontmatter:()=>v});var n=p(s()),v={title:\"What are the differences between variables created using `let`, `var` or `const`?\"};function d(o){let e=Object.assign({p:\"p\",code:\"code\",em:\"em\",pre:\"pre\"},o.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(e.p,{children:[\"Variables declared using the \",(0,n.jsx)(e.code,{children:\"var\"}),\" keyword are scoped to the function in which they are created, or if created outside of any function, to the global object. \",(0,n.jsx)(e.code,{children:\"let\"}),\" and \",(0,n.jsx)(e.code,{children:\"const\"}),\" are \",(0,n.jsx)(e.em,{children:\"block scoped\"}),\", meaning they are only accessible within the nearest set of curly braces (function, if-else block, or for-loop).\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`function foo() {\n  // All variables are accessible within functions.\n  var bar = 'bar';\n  let baz = 'baz';\n  const qux = 'qux';\n\n  console.log(bar); // bar\n  console.log(baz); // baz\n  console.log(qux); // qux\n}\n\nconsole.log(bar); // ReferenceError: bar is not defined\nconsole.log(baz); // ReferenceError: baz is not defined\nconsole.log(qux); // ReferenceError: qux is not defined\n`})}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`if (true) {\n  var bar = 'bar';\n  let baz = 'baz';\n  const qux = 'qux';\n}\n\n// var declared variables are accessible anywhere in the function scope.\nconsole.log(bar); // bar\n// let and const defined variables are not accessible outside of the block they were defined in.\nconsole.log(baz); // ReferenceError: baz is not defined\nconsole.log(qux); // ReferenceError: qux is not defined\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.code,{children:\"var\"}),\" allows variables to be hoisted, meaning they can be referenced in code before they are declared. \",(0,n.jsx)(e.code,{children:\"let\"}),\" and \",(0,n.jsx)(e.code,{children:\"const\"}),\" will not allow this, instead throwing an error.\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`console.log(foo); // undefined\n\nvar foo = 'foo';\n\nconsole.log(baz); // ReferenceError: can't access lexical declaration 'baz' before initialization\n\nlet baz = 'baz';\n\nconsole.log(bar); // ReferenceError: can't access lexical declaration 'bar' before initialization\n\nconst bar = 'bar';\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"Redeclaring a variable with \",(0,n.jsx)(e.code,{children:\"var\"}),\" will not throw an error, but \",(0,n.jsx)(e.code,{children:\"let\"}),\" and \",(0,n.jsx)(e.code,{children:\"const\"}),\" will.\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`var foo = 'foo';\nvar foo = 'bar';\nconsole.log(foo); // \"bar\"\n\nlet baz = 'baz';\nlet baz = 'qux'; // Uncaught SyntaxError: Identifier 'baz' has already been declared\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.code,{children:\"let\"}),\" and \",(0,n.jsx)(e.code,{children:\"const\"}),\" differ in that \",(0,n.jsx)(e.code,{children:\"let\"}),\" allows reassigning the variable's value while \",(0,n.jsx)(e.code,{children:\"const\"}),\" does not.\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`// This is fine.\nlet foo = 'foo';\nfoo = 'bar';\n\n// This causes an exception.\nconst baz = 'baz';\nbaz = 'qux';\n`})})]})}function w(o={}){let{wrapper:e}=o.components||{};return e?(0,n.jsx)(e,Object.assign({},o,{children:(0,n.jsx)(d,o)})):d(o)}var j=w;return m(y);})();\n;return Component;"
}