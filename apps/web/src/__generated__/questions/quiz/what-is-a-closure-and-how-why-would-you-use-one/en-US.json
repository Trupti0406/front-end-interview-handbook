{
  "description": null,
  "format": "quiz",
  "metadata": {
    "author": null,
    "companies": [
      "amazon",
      "linkedin",
      "microsoft",
      "salesforce"
    ],
    "created": 1630800000,
    "difficulty": "medium",
    "duration": 5,
    "excerpt": null,
    "featured": false,
    "format": "quiz",
    "frameworkDefault": null,
    "frameworks": [],
    "href": "/questions/quiz/what-is-a-closure-and-how-why-would-you-use-one",
    "importance": "high",
    "languages": [],
    "nextQuestions": [],
    "premium": false,
    "published": true,
    "ranking": 100,
    "similarQuestions": [],
    "slug": "what-is-a-closure-and-how-why-would-you-use-one",
    "subtitle": null,
    "title": "What is a closure, and how/why would you use one?",
    "topics": [
      "javascript"
    ]
  },
  "solution": "var Component=(()=>{var d=Object.create;var i=Object.defineProperty;var u=Object.getOwnPropertyDescriptor;var p=Object.getOwnPropertyNames;var g=Object.getPrototypeOf,m=Object.prototype.hasOwnProperty;var w=(a,e)=>()=>(e||a((e={exports:{}}).exports,e),e.exports),f=(a,e)=>{for(var t in e)i(a,t,{get:e[t],enumerable:!0})},s=(a,e,t,c)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let r of p(e))!m.call(a,r)&&r!==t&&i(a,r,{get:()=>e[r],enumerable:!(c=u(e,r))||c.enumerable});return a};var b=(a,e,t)=>(t=a!=null?d(g(a)):{},s(e||!a||!a.__esModule?i(t,\"default\",{value:a,enumerable:!0}):t,a)),v=a=>s(i({},\"__esModule\",{value:!0}),a);var l=w((_,o)=>{o.exports=_jsx_runtime});var C={};f(C,{default:()=>j,frontmatter:()=>x});var n=b(l()),x={title:\"What is a closure, and how/why would you use one?\"};function h(a){let e=Object.assign({h2:\"h2\",p:\"p\",ol:\"ol\",li:\"li\",strong:\"strong\",code:\"code\",pre:\"pre\",h3:\"h3\",a:\"a\"},a.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.h2,{children:\"Understanding JavaScript closures\"}),`\n`,(0,n.jsx)(e.p,{children:\"In JavaScript, a closure is a function that captures the lexical scope in which it was declared, allowing it to access and manipulate variables from an outer scope even after that scope has been closed.\"}),`\n`,(0,n.jsx)(e.p,{children:\"Here\\u2019s how closures work:\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Lexical scoping\"}),\": JavaScript uses lexical scoping, meaning a function's access to variables is determined by its physical location within the source code.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Function creation\"}),\": When a function is created, it keeps a reference to its lexical scope. This scope contains all the local variables that were in-scope at the time the closure was created.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Maintaining state\"}),\": Closures are often used to maintain state in a secure way because the variables captured by the closure are not accessible outside the function.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"ES6 syntax and closures\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"With ES6, closures can be created using arrow functions, which provide a more concise syntax and lexically bind the \",(0,n.jsx)(e.code,{children:\"this\"}),\" value. Here\\u2019s an example:\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`const createCounter = () => {\n  let count = 0;\n  return () => {\n    count += 1;\n    return count;\n  };\n};\n\nconst counter = createCounter();\nconsole.log(counter()); // Outputs: 1\nconsole.log(counter()); // Outputs: 2\n`})}),`\n`,(0,n.jsx)(e.h3,{children:\"Why use closures?\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Data encapsulation\"}),\": Closures provide a way to create private variables and functions that can't be accessed from outside the closure. This is useful for hiding implementation details and maintaining state in an encapsulated way.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Functional programming\"}),\": Closures are fundamental in functional programming paradigms, where they are used to create functions that can be passed around and invoked later, retaining access to the scope in which they were created, e.g. \",(0,n.jsx)(e.a,{href:\"https://medium.com/javascript-scene/curry-or-partial-application-8150044c78b8#.l4b6l1i3x\",children:\"partial applications or currying\"}),\".\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Event handlers and callbacks\"}),\": In JavaScript, closures are often used in event handlers and callbacks to maintain state or access variables that were in scope when the handler or callback was defined.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Module patterns\"}),\": Closures enable the \",(0,n.jsx)(e.a,{href:\"https://www.patterns.dev/vanilla/module-pattern\",children:\"module pattern\"}),\" in JavaScript, allowing the creation of modules with private and public parts.\"]}),`\n`]})]})}function y(a={}){let{wrapper:e}=a.components||{};return e?(0,n.jsx)(e,Object.assign({},a,{children:(0,n.jsx)(h,a)})):h(a)}var j=y;return v(C);})();\n;return Component;"
}