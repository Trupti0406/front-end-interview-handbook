---
title: Object Oriented Software Pattern
description: AQuantifying the performance of your application can be difficult, but it’s an important part of understanding how well it’s serving users and understanding the concepts.
imageUrl: https://source.unsplash.com/random/960x360
tags:
  - javascript
  - performance
level: starter
createdAt: 2023-12-02
author: blog/author/yangshun.json
series: blog/series/front-end-at-scale.json
subseries: blog/subseries/meta-frontend.json
category: >-
  blog/category/industry-best-practices.json
---

We have a look at the 23 Gang of Four design patterns for object oriented software design. While a lot of blog posts describe them using examples around concepts like Animal, Car or Pizza, we explain each of them by a practical example. It is certainly not wrong to learn design patterns with the help of real world analogies and then be able to apply them to software design problems. But it might also help others to see how they are applied in specific software design problems.

## Creational Patterns

These type of pattern support the creation of objects. Because in certain situations there are more elegant ways than using the new operator.

## Abstract Factory

The Abstract Factory provides an interface for creating families of related or dependent objects without the need to specify their concrete classes. In the example below the ShapeFactory can be used to create objects based on the String shapeType. So, we do not need to specify the concrete class, but only need to pass the type string. This pattern uses inheritance to define the factories that create objects.

## Factory Method

The Factory Method defines an interface for object creation but let’s the subclass decide which object to create. Referring to the code below, a Encryptor object needs an encryption algorithm. Through getEncryptionAlgorithm() it is ensured that the Encryptor actually get’s an EncryptorAlgorithm. However, each Encryptor decides which EncryptionAlgorithm is really used.

## Builder

In classes that have a lot of fields you oftentimes end up with many constructors as you might need objects using different field combinations. The Builder pattern enables a more readable object creation and let’s you specify the fields that are actually needed. In the example below a DataFetcher object can be created by passing the fields that are needed in a specific case. This also makes the code more readable, while only one constructor is needed.

## Prototype

The prototype pattern helps if objects are expensive to create and new objects will be similar to existing objects. It uses the clone method to duplicate existing instances to be used as a prototype for new instances. In the example below defined access control objects are retrieved simply by using a key and a copy of the corresponding access control object is returned. This way, objects that are often needed are “created” more easily.

## Singleton

A Singleton ensures that only one instance of an object is created and that this instance is globally accessible. There are not many occasions where it is acceptable to use a Singleton as it introduces global state. Logging is one meaningful example for the Singleton as the information flow happens only in one direction and therefore global state is not a big issue (in a multithread context it becomes a bit more complicated though). The private constructor in the example below ensures that the object creation only happens through getInstance() which at the same time serves as the global accessor.
