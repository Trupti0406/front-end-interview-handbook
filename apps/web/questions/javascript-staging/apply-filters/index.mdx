---
slug: apply-filters
title: Apply Filters
languages: [js]
companies: []
premium: true
duration: 30
published: false
importance: low
difficulty: easy
---

```
const items = [
  {type: 'phone', name: 'iPhone', color: 'gold'},
  {type: 'laptop', name: 'Chromebook', color: 'gray'},
//  ...
];

const excludes = [
  {k: 'color', v: 'gold'},
  {k: 'color', v: 'silver'},
//  ...
];
```

We want to write a function called applyFilters(items, excludes) which returns a copy of items but removes any items that match a key-value pair in excludes (ex: we will remove all gold items, so the first item is removed).

- In most cases, candidates write a check like `if (filterMap[key] && filterMap[key][item[key]])`. This is problematic if item looks like `{type: 'phone', name: 'toString', ...}`. Suggest that an overly-clever JS developer is trying to break the system and change the example to have name: 'toString'. Ask if that causes any problems. If they switch to `filterMap[key].hasOwnProperty(item[key])`, you can ask what happens if a filter is `{k: 'name', v: 'hasOwnProperty'}` and see if they know to use `Object.prototype.hasOwnProperty` instead. (If they ask me, I clarify that I'm not worried about malicious keys, just malicious values â€“ since only the values are likely to be user-controlled.)

- quickly identifying the problem (average positive signal)
- changing to use `filterMap[key].hasOwnProperty(item[key])` (weak positive signal)
- alternatively, checking that `filterMap[key]item[key]]` is true or similar (weak positive signal)
- knowing to use `Object.prototype.hasOwnProperty` when prompted (weak positive signal)
- suggesting `Object.create(null)` or `Map`/`Set` instead (average positive signal)
