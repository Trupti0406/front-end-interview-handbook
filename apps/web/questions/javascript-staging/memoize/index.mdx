---
slug: memoize
title: Memoize
languages: [js]
companies: [facebook]
premium: false
duration: 20
published: false
importance: low
difficulty: medium
---

Build a function "memoize" that takes, as an argument, a function 'A' that takes a **single argument**, and returns a function that when called stores the result from calling function 'A' and returns it if the returned function is called again with the same argument.

This question should take 15-20 minutes but can potentially be extended for a full interview with the follow-ups below.

## Setup

Explain that when we re-render our UI, we noticed there was one function that does an expensive calculation but it always returns the same result for the same inputs. We realized the best way to handle this was with a generic memoization function.

**Definition**: Memoization is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again.

Explain that, for the time being, `memoize` only accepts functions that take one argument like `expensiveFunc` (below).

A concrete, simple example with a primitive value arg:

```js
function memoize(funcA) {
  // code goes here
}

function expensiveFunc(y) {
  // Pretend some expensive calculation happens here.
  return y * 10;
}

const expensiveFuncMemoized = memoize(expensiveFunc);

expensiveFuncMemoized(5); // 50 returned (expensiveFunc called)
expensiveFuncMemoized(5); // 50 returned (expensiveFunc not called)

expensiveFuncMemoized(7); // 70 returned (expensiveFunc called)
expensiveFuncMemoized(5); // 50 returned (expensiveFunc not called)
expensiveFuncMemoized(7); // 70 returned (expensiveFunc not called)
```

## Follow Up #1

If the candidate's solution already takes an arg of ANY type into account (e.g. objects, functions, etc...) then you can skip to the next follow up. But this will help them understand they need to not only support the primitive arg use-case.

```js
function memoize(funcA) {
// code goes here
}

function expensiveFunc(y: any): any {
// Pretend some expensive calculation happens here.
return some_value;
};

const expensiveFuncMemoized = memoize(expensiveFunc);

const foo = /*any*/;
const bar = /*any*/;
expensiveFuncMemoized(foo); // 'foo_hash' returned (expensiveFunc called)
expensiveFuncMemoized(foo); // 'foo_hash' returned (expensiveFunc not called)
expensiveFuncMemoized(bar); // 'bar_hash' returned (expensiveFunc called)
expensiveFuncMemoized(foo); // 'foo_hash' returned (expensiveFunc not called)
expensiveFuncMemoized(bar); // 'bar_hash' returned (expensiveFunc not called)
```

## Follow Up #2

Handle functions with a variadic number of arguments.

```
function timesAll(x, y, z) {
// Some expensive calculation here.
return x * y * z;
};

const timesAllMemoized = memoize(timesAll);

timesAllMemoized(1, 5, 10); // 50 returned (timesAll called and 50 is stored)
timesAllMemoized(5, 1, 10); // 50 returned (timesAll called and 50 is stored)
timesAllMemoized(1, 5, 10); // 50 returned (timesAll not called)
```

If the candidate gets stuck here, a hint would be that it's possible that a Map can store an array as the key and that you can iterate over the keys.

## Follow Up #3

Handle value equality instead of reference equality (or vice versa if the candidate already used value equality). Candidates don't need to build their own deepEquals or deepCopy but if they mention it say that they can reference either as a global method.

## Follow Up #4 Option A

Handle with a variadic number of arguments in O(M) time, where M is the number of arguments rather than in O(M \* N) time where N is the number of keys in the cache.

## Follow Up #4 Option B

Implement a memoize with an LRU (least recently used) cache for 10 sets of args.

## Practical Application

This problem covers a common computer science problem: working with and understanding caches. In a broader sense, developers should understand the benefits of caches in terms of reducing CPU cycles and program latency. This question also deals with the tradeoffs between memory utilization/cache optimization and referential/value equality in Javascript.

## Interview Signal

Matrix Signals (from the [Signals Matrix](https://l.facebook.com/l.php?u=https%3A%2F%2Ffb.quip.com%2FPeUUAIwfwLbl%23FBbACA9sCeI&h=AT30L1nwLt8MV2PZ4OXeWDhbKTwldpebVspwJm4SEh7Jnz1I58bp-CtTPjFBO8Wz68h_VvNbsj7CKDiMxO3WjTof2uCUsUWxSWsrXefpDa6ZxJrHmujSmhyZaVSxzaxc6hi_pr7pusIAsL45vzX1ITvh))

- Front-end Perf
- JS Language
- Data Structures / Algorithms
- Bang out code

### SPECIFIC SIGNALS

- [+] Positive
- [~+] Wek Positive
- [~] Neutral
- [~-] Weak Negative
- [-] Negative

**Memoize**

- [+] Created a working solution using a Map
- [~-] Created a working solution using an Object Literal or with Arrays.
- [~+] Recognized the need for a closure to store the arguments and results
- [~+] Regonized the issue with using an Object Literal for arguments that don't stringify well e.g. `new MyThing()`
- [~+] Recognized the issue with storing complex arguments in terms of memory usage if we're storing deep copies.

**Memoize** (with variadic number of arguments)

- [+] Knew how to capture and store all the arguments for a function using either a Map and iterating over the keys or a two-dimensional array.
- [~+] Knew the time complexity of storing and searching for cache results e.g. O(m\*n)

**Handle value equality instead of reference equality (or vice versa if the candidate already used value equality)**

- [+] Discussed the trade-offs and issues with reference vs value equality checking e.g.
- What if the underlying reference to the object is changed outside of this function?
- Outlined what a deep value equality checking would look like.
- [~+] Strong understanding of the difference between value and reference equality

**Handle functions with a variadic number of arguments in O(M)**

- [+] Implemented some version of a trie to store arguments and results. This is a very strong positive signal.

**LRU Cache**

- [+] Implemented a working LRU cache by storing timestamps along with results in the cache.

**General**

- [+] Discussed multiple caching strategies (LRU, MRU) and some of their trade-offs
- [~+] Detailed the trade-offs with storing an infinite number of arguments and returned results

## Sample Solution

```js
function memoize(fn) {
  const cache = new Map();
  return function (arg) {
    if (cache.has(arg)) {
      return cache.get(arg);
    }
    const fnReturn = fn(arg);
    cache.set(arg, fnReturn);
    return fnReturn;
  };
}

// Memoize with variadic args (reference equality checking) O(M * N) time
function memoizeArgs(fn) {
  const cache = new Map();

  return function (...args) {
    for (let [key, value] of cache.entries()) {
      if (key.length === args.length) {
        if (
          key.every((item, index) => {
            return item === args[index];
          })
        ) {
          return value;
        }
      }
    }

    const value = fn(...args);
    cache.set(args, value);
    return value;
  };
}

// Memoize with variadic args (value equality checking) O(M * N) time
function memoizeArgsValue(fn) {
  const cache = new Map();

  return function (...args) {
    for (let [key, value] of cache.entries()) {
      if (deepEquals(key, args)) {
        return value;
      }
    }

    const value = fn(...args);
    cache.set(args, value);
    return value;
  };
}

// Memoize with variadic args - O(M) time
class Trie {
  root = new Map();
  valueKey = Symbol();

  set(keys, value) {
    let node = this.root;
    for (const key of keys) {
      const child = node.get(key) || new Map();
      node.set(key, child);
      node = child;
    }
    node.set(this.valueKey, value);
  }

  get(keys) {
    let node = this.root;
    for (const key of keys) {
      node = node.get(key);
      if (node == null) {
        break;
      }
    }
    return node != null ? node.get(this.valueKey) : undefined;
  }

  has(keys) {
    return this.get(keys) !== undefined;
  }
}

function memoize(fn) {
  const cache = new Trie();
  return function (...args) {
    if (cache.has(args)) {
      return cache.get(args);
    }
    const value = fn(...args);
    cache.set(args, value);
    return value;
  };
}
```
