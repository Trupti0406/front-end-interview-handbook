---
slug: text-in-range
title: Text in Range
languages: [html, js]
companies: []
premium: true
duration: 30
published: false
importance: low
difficulty: hard
---

The user has selected a section of text that may span across multiple paragraphs. There may be images or other non-text nodes in the middle. We want to get the contents of that text.

## Setup

- The user has selected a section of text that may span across multiple paragraphs. There may be images or other non-text nodes in the middle. We want to get the contents of that text.
- Given references to two text nodes (not elements!), A and B, return the string of text in between A and B, inclusive.
- A is guaranteed to be before B in document order.

## Classes of solutions

- [naive solution] Perform an in-order traversal from the root. Start recording when you reach A and stop recording when you reach B. https://jsfiddle.net/mathlete84/shskx2oe/
- [better solution] Find the lowest common ancestor (LCA) of A and B. Perform an in-order traversal from the LCA. Start recording when you reach A and stop recording when you reach B. This solution is more efficient because it visits fewer nodes. https://jsfiddle.net/mathlete84/7L1nxokn
- [optimization on better solution^] Find the lowest common ancestor (LCA) of A and B and store the path between LCA and A. Do an in-order traversal starting from LCA, but don't visit nodes that are to the left of A (using the path between LCA and A). Stop recording and traversing when you reach B. This solution visits fewer nodes (not the entire subtree underneath LCA), but we're trading complexity for efficiency. https://jsfiddle.net/voideanvalue/y62s52hr/
- [optimal solution] Walk the tree from A to B along the leaves. This is far more efficient if A has lots of previous siblings and B has lots of subsequent siblings. https://jsfiddle.net/spicyj/x71y0vzf/
- [optimal solution 2] For each nextSibling of A or its parents, traverse all of its descendants recursively. Stop when you get to B. Similar efficiency to the pure-walking version but may be easier to think about. https://jsfiddle.net/spicyj/cdx2rw9y/
- [creative solution] Get all elements on the page. Iterate through the elements and start recording when the element's firstChild matches A. Stop recording when the element's firstChild matches B. https://jsfiddle.net/mathlete84/5uu12a94/

- [LeetCode example](<https://leetcode.com/discuss/interview-question/1055231/Facebook-Onsite-Interview-Question%3A-getTextBetweenNodes(node1-node2)>)

## Opportunities for Signal

- DOM/JS expertise
  - Knowing the difference between nodes and elements.
  - Knowing nodeTypes (element is 1, textNode is 3)
  - DOM API's (nextSibling, nodeValue, childNodes, getElementsByTagName, querySelectorAll, etc.)
- Problem Solving
  - Ability to minimize number of nodes visited in a traversal
  - Recognition that using LCA is a simple optimization
- Coding
  - Comfort with recursion
  - Ability to manage complex state and reason about code. In all solutions, there's a lot to keep track of.
  - Efficient way to compute LCA. The ideal solution is O(n), where n is the depth. If the solution relies on indexOf, it's most likely O(n^2).
  - Cleanliness. The amount of code is non-trivial, so look for clarity, decomposition, etc.
  - Handling edge cases.
    - Does the recursion terminate correctly?
    - Are they including A and B's text in the output?
    - Are they including any extra text?

Test Cases. This problem is different from a lot of the other UIE ninjas in that coming up with good test cases and then reasoning about how the code reacts to them is really important to a successful implementation.

## Suggested Interview Flow

- Expected time is 40 min for this question.
- Get the candidate to articulate their solution before coding.
- If they come up with the naive solution, let them implement it. This shouldn't take more than 15-20 min. If they struggle badly, make a call whether to continue or bail and ask an easier unrelated question. If continuing, ask them to optimize.
- If they come up with the better solution, let them assume the existence of the getLCA(a, b) function and ask them to implement the naive solution. If they do well on that, have them implement getLCA afterwards. The reason for this is that there is more signal in the traversal portion than the lca portion, and it gives you an opportunity to bail if they completely mess up the traversal.
- If they come up with the optimal solution, make them explain it in detail with diagrams. If you are confident that they have a strong grasp of the correct algorithm, only then do you let them implement it. The reason for this is that there are a ton of edge cases with this solution, so if someone attempts this without having a strong grasp of the algorithm you can waste a lot of time without getting signal. If they can't explain it well or are getting confused, steer them towards one of the simpler solutions.
- If they come up with the creative solution, ask them to optimize. They should implement LCA.

## Evaluation

- Inability to come up with any working solution (verbally) = strong negative signal
- Inability to implement naive solution = average negative signal
- Inability to improve upon naive solution (verbally) = weak negative signal
- Clean implementation of naive solution = weak positive signal
- Clean implementation of better/creative solution = average positive signal
- Clean implementation of optimal solution = strong positive signal
